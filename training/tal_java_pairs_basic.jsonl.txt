{"text": "Hello World", "<TAL>BEGIN\n  WRITE (*, *) \"Hello, World!\";\nEND;\n</TAL>\n<Java>\nSystem.out.println(\"Hello, World!\");\n</Java>"}
{"text": "Integer data type", "<TAL>INT myVar := 42;\n</TAL>\n<Java>int myVar = 42;\n</Java>"}
{"text": "basic int assignment", "<TAL>INT a := 5;\nINT b := 10;\nINT sum;\nsum := a + b;\nWRITE (*, *) sum;\n</TAL>\n<Java>\nint a = 5;\nint b = 10;\nint sum = a + b;\nSystem.out.println(sum);\n</Java>"}
{"text": "basic If-then-else", "<TAL>INT x := 10;\nIF x > 5 THEN\n  WRITE (*, *) \"x is greater than 5\";\nENDIF;\n</TAL>\n<Java>\nint x = 10;\nif (x > 5) {\n    System.out.println(\"x is greater than 5\");\n}\n</Java>"}
{"text": "basic for loop", "<TAL>INT i;\nFOR i := 1 TO 5 DO\n  WRITE (*, *) i;\nENDDO;\n</TAL>\n<Java>\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n</Java>"}
{"text":"basic while loop", "<TAL>INT i := 1;\nWHILE i <= 5 DO\n  WRITE (*, *) i;\n  i := i + 1;\nENDWHILE;\n</TAL>\n<Java>\nint i = 1;\nwhile (i <= 5) {\n    System.out.println(i);\n    i++;\n}\n</Java>"}
{"text":"calling a procedure", "<TAL>PROC myProc (x) VOID;\n  INT x;\nBEGIN\n  WRITE (*, *) x * 2;\nEND;\nCALL myProc(5);\n</TAL>\n<Java>\npublic static void myProc(int x) {\n    System.out.println(x * 2);\n}\nmyProc(5);\n</Java>"}
{"text":"basic array", "<TAL>INT myArray[0:4];\nmyArray[0] := 10;\n</TAL>\n<Java>\nint[] myArray = new int[5];\nmyArray[0] = 10;\n</Java>"}
{"text": "basic string", "<TAL>STRING .myString[0:9] := \"Greetings!\";\nWRITE (*, *) myString;\n</TAL>\n<Java>\nString myString = \"Greetings!\";\nSystem.out.println(myString);\n</Java>"}
{"text": "basic case", "<TAL>INT choice := 2;\nCASE choice OF\n  1: WRITE (*, *) \"Option 1\";\n  2: WRITE (*, *) \"Option 2\";\n  ELSE WRITE (*, *) \"Default\";\nENDCASE;\n</TAL>\n<Java>\nint choice = 2;\nswitch (choice) {\n    case 1:\n        System.out.println(\"Option 1\");\n        break;\n    case 2:\n        System.out.println(\"Option 2\");\n        break;\n    default:\n        System.out.println(\"Default\");\n}\n</Java>"}
{"text":"Print statement", "<TAL>\nINT a := 12;\nINT b := 10;\nINT result;\nresult := a & b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a & b;\nSystem.out.println(result);\n</Java>"}
{"text":"basic logical or", "<TAL>INT a := 12;\nINT b := 10;\nINT result;\nresult := a ! b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a | b;\nSystem.out.println(result);\n</Java>"}
{"text": "basic xor", "<TAL>INT a := 12;\nINT b := 10;\nINT result;\nresult := a # b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a ^ b;\nSystem.out.println(result);\n</Java>"}
{"text":"left shift", "<TAL>INT value := 5;\nINT result;\nresult := value << 2;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint value = 5;\nint result = value << 2;\nSystem.out.println(result);\n</Java>"}
{"text": "bitset", "<TAL>INT value := 10;\nINT mask := 2;\nINT result;\nIF (value & mask) <> 0 THEN\n  WRITE (*, *) \"Second bit is set\";\nELSE\n  WRITE (*, *) \"Second bit is not set\";\nENDIF;\n</TAL>\n<Java>\nint value = 10;\nint mask = 2;\nif ((value & mask) != 0) {\n    System.out.println(\"Second bit is set\");\n} else {\n    System.out.println(\"Second bit is not set\");\n}\n</Java>"}
{"text": "array init", "<TAL>INT myArray[0:4];\nmyArray[0] := 1;\nmyArray[1] := 2;\nmyArray[2] := 3;\nmyArray[3] := 4;\nmyArray[4] := 5;\nWRITE (*, *) myArray[2];\n</TAL>\n<Java>\nint[] myArray = new int[5];\nmyArray[0] = 1;\nmyArray[1] = 2;\nmyArray[2] = 3;\nmyArray[3] = 4;\nmyArray[4] = 5;\nSystem.out.println(myArray[2]);\n</Java>"}
{"text":"2d array init", "<TAL>INT myArray[0:4] := [1, 2, 3, 4, 5];\nINT i;\nFOR i := 0 TO 4 DO\n  WRITE (*, *) myArray[i];\nENDDO;\n</TAL>\n<Java>\nint[] myArray = {1, 2, 3, 4, 5};\nfor (int i = 0; i <= 4; i++) {\n    System.out.println(myArray[i]);\n}\n</Java>"}
{"text":"basic matrix", "<TAL>INT matrix[0:2,0:2];\nmatrix[0,0] := 1;\nmatrix[0,1] := 2;\nmatrix[1,0] := 3;\nmatrix[1,1] := 4;\nmatrix[2,0] := 5;\nmatrix[2,1] := 6;\nWRITE (*, *) matrix[1,1];\n</TAL>\n<Java>\nint[][] matrix = new int[3][3];\nmatrix[0][0] = 1;\nmatrix[0][1] = 2;\nmatrix[1][0] = 3;\nmatrix[1][1] = 4;\nmatrix[2][0] = 5;\nmatrix[2][1] = 6;\nSystem.out.println(matrix[1][1]);\n</Java>"}
{"text": "do loop" , "<TAL>\nINT source[0:3] := [10, 20, 30, 40];\nINT target[0:3];\nINT i;\nFOR i := 0 TO 3 DO\n  target[i] := source[i];\nENDDO;\nWRITE (*, *) target[2];\n</TAL>\n<Java>\nint[] source = {10, 20, 30, 40};\nint[] target = new int[4];\nfor (int i = 0; i <= 3; i++) {\n    target[i] = source[i];\n}\nSystem.out.println(target[2]);\n</Java>"}
{"text": "additions", "<TAL>INT myArray[0:4] := [1, 2, 3, 4, 5];\nINT sum := 0;\nINT i;\nFOR i := 0 TO 4 DO\n  sum := sum + myArray[i];\nENDDO;\nWRITE (*, *) sum;\n</TAL>\n<Java>\nint[] myArray = {1, 2, 3, 4, 5};\nint sum = 0;\nfor (int i = 0; i <= 4; i++) {\n    sum += myArray[i];\n}\nSystem.out.println(sum);\n</Java>"}
{"text": "minCostPath", "<TAL>PROC minCostPath (cost, rows, cols, m, n, result) VOID;\n  INT .cost[0:99,0:99];\n  INT rows, cols;\n  INT m, n;\n  INT .result;\nBEGIN\n  INT dp[0:99,0:99];\n  INT i, j;\n  dp[0,0] := cost[0,0];\n  FOR i := 1 TO m DO\n    dp[i,0] := dp[i-1,0] + cost[i,0];\n  ENDDO;\n  FOR j := 1 TO n DO\n    dp[0,j] := dp[0,j-1] + cost[0,j];\n  ENDDO;\n  FOR i := 1 TO m DO\n    FOR j := 1 TO n DO\n      IF dp[i-1,j] < dp[i,j-1] THEN\n        dp[i,j] := dp[i-1,j] + cost[i,j];\n      ELSE\n        dp[i,j] := dp[i,j-1] + cost[i,j];\n      ENDIF;\n    ENDDO;\n  ENDDO;\n  result := dp[m,n];\nEND;\n</TAL>\n<Java>\npublic static int minCostPath(int[][] cost, int rows, int cols, int m, int n) {\n    int[][] dp = new int[rows][cols];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = cost[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[m][n];\n}\n</Java>"}
{"text": "MBPP: Simple TAL procedure to swap two INT values\n", "<TAL>PROC swap(a, b);\nINT .a, .b;\nBEGIN\n  INT temp;\n  temp := a;\n  a := b;\n  b := temp;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Simple Java method to swap two integers\n  // Uses IntWrapper to simulate pointer semantics\n  public static void swap(IntWrapper a, IntWrapper b) {\n    int temp = a.value;\n    a.value = b.value;\n    b.value = temp;\n  }\n  \n  // Helper class to simulate pointer behavior\n  public static class IntWrapper {\n    public int value;\n    \n    public IntWrapper(int value) {\n      this.value = value;\n    }\n  }\n}\n</Java>"}
{"text": "Procedure to move a string", "<TAL>PROC moveString(source, dest, len);\nSTRING .source, .dest;\nINT len;\nBEGIN\n  dest ':=' source FOR len;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to copy bytes from source to destination\n  public static void moveString(byte[] source, byte[] dest, int len) {\n    // Check bounds to prevent IndexOutOfBoundsException\n    if (source.length < len || dest.length < len) {\n      len = Math.min(source.length, dest.length);\n    }\n    \n    System.arraycopy(source, 0, dest, 0, len);\n  }\n}\n</Java>"}
{"text":"Procedure to find maximum value in an array", "<TAL>INT PROC findMax(array, len);\nINT .array;\nINT len;\nBEGIN\n  INT i, max;\n  max := array[0];\n  FOR i := 1 TO len - 1 DO\n    IF array[i] > max THEN\n      max := array[i];\n  RETURN max;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to find maximum value in an array\n  public static int findMax(int[] array, int len) {\n    if (array == null || len <= 0 || array.length < len) {\n      throw new IllegalArgumentException("Invalid array or length");\n    }\n    \n    int max = array[0];\n    for (int i = 1; i < len; i++) {\n      if (array[i] > max) {\n        max = array[i];\n      }\n    }\n    return max;\n  }\n}\n</Java>"}
{"text":"Procedure with pointer arithmetic to manipulate an array", "<TAL>PROC incrementArray(array, len);\nINT .array;\nINT len;\nBEGIN\n  INT .ptr;\n  INT i;\n  ptr := @array;\n  FOR i := 0 TO len - 1 DO\n  BEGIN\n    ptr[i] := ptr[i] + 1;\n  END;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to increment all values in an array\n  // Simulating pointer arithmetic using array indexing\n  public static void incrementArray(int[] array, int len) {\n    if (array == null || len <= 0 || array.length < len) {\n      throw new IllegalArgumentException("Invalid array or length");\n    }\n    \n    // In Java we don't need a separate pointer\n    // but we can use the array reference directly\n    for (int i = 0; i < len; i++) {\n      array[i] = array[i] + 1;\n    }\n  }\n}\n</Java>"}
{"text":"Procedure using bit operations", "<TAL>INT PROC getBits(value, startBit, numBits);\nINT value, startBit, numBits;\nBEGIN\n  RETURN (value '<<' (16 - startBit - numBits)) '>>' (16 - numBits);\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to extract bits from an integer\n  public static int getBits(int value, int startBit, int numBits) {\n    // First shift left to remove bits we don't want\n    // Then shift right to position the bits we want at the rightmost position\n    return (value << (16 - startBit - numBits)) >>> (16 - numBits);\n    // Note: Java >>> is unsigned right shift, similar to TAL '>>' operation\n  }\n}\n</Java>"}
{"text":  "procedure to allocate and use a buffer for I/O", "<TAL>PROC readFile(fileNum, len);\nINT fileNum, len;\nBEGIN\n  INT .buffer[0:255];\n  INT bytesRead;\n  \n  CALL READ(fileNum, buffer, len, bytesRead);\n  \n  IF < THEN\n  BEGIN\n    ! Handle error\n    CALL FILEINFO(fileNum, error);\n    RETURN;\n  END;\n  \n  ! Process buffer data\n  ! ...\nEND;\n</TAL>\n<Java>\nimport java.io.*;\n\npublic class GuardianIO {\n  // Java method simulating TAL file read operation\n  public static void readFile(int fileNum, int len) {\n    // Create a buffer for the file data\n    byte[] buffer = new byte[256];\n    \n    try {\n      // Stub for Guardian READ operation\n      // In a real implementation, this would map to appropriate Java I/O\n      int bytesRead = GuardianStubs.read(fileNum, buffer, len);\n      \n      // Process buffer data\n      // ...\n      \n    } catch (IOException e) {\n      // Handle error\n      int error = GuardianStubs.fileInfo(fileNum);\n      System.err.println("File error: " + error);\n    }\n  }\n  \n  // Stub class for Guardian OS functions\n  private static class GuardianStubs {\n    public static int read(int fileNum, byte[] buffer, int len) throws IOException {\n      // Implementation would connect to actual file I/O\n      // For now just return a dummy value\n      return len;\n    }\n    \n    public static int fileInfo(int fileNum) {\n      // Return dummy error code\n      return 45; // Example error code\n    }\n  }\n}\n</Java>"}
{"text": "Procedure using a structure and pointers", "<TAL>STRUCT employee (*);\nBEGIN\n  INT id;\n  STRING name[0:31];\n  FIXED(2) salary;\nEND;\n\nPROC processEmployee(emp);\nSTRUCT .emp (employee);\nBEGIN\n  INT .intPtr;\n  STRING .namePtr;\n  \n  intPtr := @emp.id;\n  namePtr := @emp.name;\n  \n  ! Process employee data\n  intPtr := intPtr + 1; ! Point to next field (after id)\n  \n  ! Print employee name (first byte)\n  ! Assumes name is null-terminated\n  CALL WRITE(term, namePtr, 32);\nEND;\n</TAL>\n<Java>\nimport java.nio.ByteBuffer;\n\npublic class StructureProcessor {\n  // Java class representing employee structure\n  public static class Employee {\n    public int id;\n    public byte[] name = new byte[32]; // Fixed-size array simulating TAL STRING array\n    public double salary;  // Equivalent to TAL FIXED(2)\n  }\n  \n  // Java method to process employee data\n  public static void processEmployee(Employee emp) {\n    // In Java, we can't do direct pointer arithmetic like in TAL\n    // Instead, we use ByteBuffer for arbitrary memory access simulation\n    ByteBuffer buffer = ByteBuffer.allocate(40); // Size large enough for structure\n    \n    // Put employee data into buffer\n    buffer.putInt(emp.id);\n    buffer.put(emp.name);\n    \n    // Simulate pointer to id\n    buffer.position(0);\n    int idValue = buffer.getInt();\n    \n    // Simulate pointer to name\n    buffer.position(4); // Position after id\n    byte[] nameBytes = new byte[32];\n    buffer.get(nameBytes);\n    \n    // Print employee name\n    try {\n      GuardianStubs.write(1, nameBytes, 32); // Simulate terminal write\n    } catch (IOException e) {\n      System.err.println("Write error: " + e.getMessage());\n    }\n  }\n  \n  // Stub class for Guardian OS functions\n  private static class GuardianStubs {\n    public static void write(int fileNum, byte[] buffer, int len) throws IOException {\n      // In a real implementation, this would map to appropriate Java I/O\n      System.out.write(buffer, 0, len);\n    }\n  }\n}\n</Java>"}
{"text": "Implementation of a simple memory manager", "<TAL>INT memoryPool[0:1023];\nINT nextFree := 0;\n\nINT PROC allocateMemory(size);\nINT size;\nBEGIN\n  INT result;\n  \n  IF (nextFree + size) > 1024 THEN\n    RETURN -1; ! Not enough memory\n  \n  result := nextFree;\n  nextFree := nextFree + size;\n  \n  RETURN result; ! Return offset into memory pool\nEND;\n\nPROC freeMemory(offset, size);\nINT offset, size;\nBEGIN\n  ! Simple implementation - doesn't actually reclaim memory\n  ! In a real implementation, would track free blocks\nEND;\n\nPROC storeData(data, len);\nINT .data, len;\nBEGIN\n  INT offset;\n  INT .destPtr;\n  \n  offset := allocateMemory(len);\n  IF offset = -1 THEN\n    RETURN; ! Failed to allocate\n  \n  destPtr := @memoryPool + offset;\n  destPtr ':=' data FOR len;\nEND;\n</TAL>\n<Java>\npublic class MemoryManager {\n  private static int[] memoryPool = new int[1024];\n  private static int nextFree = 0;\n  \n  /\n   * Allocates memory from the pool\n   * @param size Number of integers to allocate\n   * @return Offset into memory pool or -1 if allocation failed\n   */\n  public static int allocateMemory(int size) {\n    if ((nextFree + size) > 1024) {\n      return -1; // Not enough memory\n    }\n    \n    int result = nextFree;\n    nextFree += size;\n    \n    return result; // Return offset into memory pool\n  }\n  \n  /\n   * Frees memory (stub implementation)\n   * @param offset Offset into memory pool\n   * @param size Number of integers to free\n   */\n  public static void freeMemory(int offset, int size) {\n    // Simple implementation - doesn't actually reclaim memory\n    // In a real implementation, would track free blocks\n  }\n  \n  /\n   * Stores data into the memory pool\n   * @param data Source data array\n   * @param len Number of integers to store\n   * @return true if successful, false otherwise\n   */\n  public static boolean storeData(int[] data, int len) {\n    int offset = allocateMemory(len);\n    if (offset == -1) {\n      return false; // Failed to allocate\n    }\n    \n    // Copy data to memory pool\n    System.arraycopy(data, 0, memoryPool, offset, len);\n    return true;\n  }\n  \n  /\n   * Retrieves data from memory pool\n   * @param offset Offset into memory pool\n   * @param len Number of integers to retrieve\n   * @return Array containing the retrieved data\n   */\n  public static int[] retrieveData(int offset, int len) {\n    if (offset < 0 || offset + len > memoryPool.length) {\n      return null; // Invalid parameters\n    }\n    \n    int[] result = new int[len];\n    System.arraycopy(memoryPool, offset, result, 0, len);\n    return result;\n  }\n}\n</Java>"}
{"text": "Procedure declaration and call", "<TAL>PROC add_values(INT a, INT b) RETURNS INT;\nBEGIN\n  RETURN a + b;\nEND;</TAL><JAVA>int addValues(int a, int b) {\n    return a + b;\n}</JAVA>"}
{"text": "Recursion using factorial", "<TAL>PROC factorial(INT n) RETURNS INT;\nBEGIN\n  IF n = 0 THEN RETURN 1;\n  RETURN n * CALL factorial(n - 1);\nEND;</TAL><JAVA>int factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}</JAVA>"}
{"text": "Equivalenced variable for byte view of int", "<TAL>INT(32) word;\nBYTE byte1 = word[0];</TAL><JAVA>int word = 0xAABBCCDD;\nbyte byte1 = (byte)(word & 0xFF);</JAVA>"}
{"text": "File open, read, and close", "<TAL>FILE infile;\nOPEN infile, 'input.dat', INPUT;\nCALL WRITEREAD(infile, buffer, 0, 100, result);\nCLOSE infile;</TAL><JAVA>BufferedReader infile = new BufferedReader(new FileReader(\"input.dat\"));\nchar[] buffer = new char[100];\ninfile.read(buffer, 0, 100);\ninfile.close();</JAVA>"}
{"text": "<TAL>\nTAL server process that receives and processes messages\nSTRUCT message (*);\nBEGIN\n  INT msgType;\n  INT msgLen;\n  STRING data[0:255];\nEND;\n\nPROC server MAIN;\nBEGIN\n  INT .receiveBuffer[0:150];\n  STRUCT .msgBuffer (message);\n  INT receiveId;\n  INT bytesRead;\n  INT status;\n  \n  ! Open RECEIVE to get messages\n  CALL OPEN(\"
RECEIVE\", receiveId);\n  \n  ! Server loop\n  WHILE 1 DO\n  BEGIN\n    ! Read the next message\n    CALL READX(receiveId, receiveBuffer, 300, bytesRead);\n    \n    IF < THEN\n    BEGIN\n      ! Handle error\n      CALL FILEINFO(receiveId, status);\n      CONTINUE;\n    END;\n    \n    ! Set up structure pointer to interpret received data\n    @msgBuffer := @receiveBuffer;\n    \n    ! Process message based on type\n    CASE msgBuffer.msgType OF\n    BEGIN\n      0 ! Echo message\n        CALL REPLYX(receiveBuffer, bytesRead);\n      \n      1 ! Store data message\n        CALL processStoreRequest(msgBuffer);\n      \n      2 ! Retrieve data message\n        CALL processRetrieveRequest(msgBuffer);\n      \n      OTHERWISE\n        ! Unknown message type\n        CALL REPLYX(\"ERROR: Unknown message type\", 26);\n    END;\n  END;\nEND;\n\nPROC processStoreRequest(msg);\nSTRUCT .msg (message);\nBEGIN\n  ! Process store request\n  ! ...\n  CALL REPLYX(\"OK\", 2);\nEND;\n\nPROC processRetrieveRequest(msg);\nSTRUCT .msg (message);\nBEGIN\n  ! Process retrieve request\n  ! ...\n  CALL REPLYX(\"DATA\", 4);\nEND;\n</TAL>\n<Java>\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class TandemServer {\n  // Java class representing message structure\n  public static class Message {\n    public int msgType;\n    public int msgLen;\n    public byte[] data = new byte[256];\n    \n    // Parse from byte array\n    public void parseFrom(byte[] buffer) {\n      ByteBuffer bb = ByteBuffer.wrap(buffer);\n      msgType = bb.getInt();\n      msgLen = bb.getInt();\n      bb.get(data, 0, Math.min(data.length, buffer.length - 8));\n    }\n    \n    // Convert to byte array\n    public byte[] toByteArray() {\n      ByteBuffer bb = ByteBuffer.allocate(8 + data.length);\n      bb.putInt(msgType);\n      bb.putInt(msgLen);\n      bb.put(data);\n      return bb.array();\n    }\n  }\n  \n  // Main server class\n  public static void main(String[] args) {\n    try {\n      // Create server socket\n      ServerSocket serverSocket = new ServerSocket(9876);\n      System.out.println(\"Server started on port 9876\");\n      \n      // Create thread pool for handling client connections\n      ExecutorService executor = Executors.newFixedThreadPool(10);\n      \n      while (true) {\n        // Accept client connection\n        Socket clientSocket = serverSocket.accept();\n        \n        // Handle client in a separate thread\n        executor.submit(() -> handleClient(clientSocket));\n      }\n    } catch (IOException e) {\n      System.err.println(\"Server error: \" + e.getMessage());\n    }\n  }\n  \n  private static void handleClient(Socket clientSocket) {\n    try {\n      InputStream in = clientSocket.getInputStream();\n      OutputStream out = clientSocket.getOutputStream();\n      \n      // Buffer for receiving data\n      byte[] receiveBuffer = new byte[512];\n      \n      // Read client message\n      int bytesRead = in.read(receiveBuffer);\n      \n      if (bytesRead > 0) {\n        // Parse message\n        Message message = new Message();\n        message.parseFrom(receiveBuffer);\n        \n        // Process message based on type\n        switch (message.msgType) {\n          case 0: // Echo message\n            out.write(receiveBuffer, 0, bytesRead);\n            break;\n            \n          case 1: // Store data message\n            processStoreRequest(message, out);\n            break;\n            \n          case 2: // Retrieve data message\n            processRetrieveRequest(message, out);\n            break;\n            \n          default:\n            // Unknown message type\n            out.write(\"ERROR: Unknown message type\".getBytes());\n        }\n      }\n      \n      clientSocket.close();\n    } catch (IOException e) {\n      System.err.println(\"Client handling error: \" + e.getMessage());\n    }\n  }\n  \n  private static void processStoreRequest(Message message, OutputStream out) throws IOException {\n    // Process store request\n    // ...\n    out.write(\"OK\".getBytes());\n  }\n  \n  private static void processRetrieveRequest(Message message, OutputStream out) throws IOException {\n    // Process retrieve request\n    // ...\n    out.write(\"DATA\".getBytes());\n  }\n}\n</Java>"}
