{"text": "Hello World", "<TAL>BEGIN\n  WRITE (*, *) \"Hello, World!\";\nEND;\n</TAL>\n<Java>\nSystem.out.println(\"Hello, World!\");\n</Java>"}
{"text": "Integer data type", "<TAL>INT myVar := 42;\n</TAL>\n<Java>int myVar = 42;\n</Java>"}
{"text": "basic int assignment", "<TAL>INT a := 5;\nINT b := 10;\nINT sum;\nsum := a + b;\nWRITE (*, *) sum;\n</TAL>\n<Java>\nint a = 5;\nint b = 10;\nint sum = a + b;\nSystem.out.println(sum);\n</Java>"}
{"text": "basic If-then-else", "<TAL>INT x := 10;\nIF x > 5 THEN\n  WRITE (*, *) \"x is greater than 5\";\nENDIF;\n</TAL>\n<Java>\nint x = 10;\nif (x > 5) {\n    System.out.println(\"x is greater than 5\");\n}\n</Java>"}
{"text": "basic for loop", "<TAL>INT i;\nFOR i := 1 TO 5 DO\n  WRITE (*, *) i;\nENDDO;\n</TAL>\n<Java>\nfor (int i = 1; i <= 5; i++) {\n    System.out.println(i);\n}\n</Java>"}
{"text":"basic while loop", "<TAL>INT i := 1;\nWHILE i <= 5 DO\n  WRITE (*, *) i;\n  i := i + 1;\nENDWHILE;\n</TAL>\n<Java>\nint i = 1;\nwhile (i <= 5) {\n    System.out.println(i);\n    i++;\n}\n</Java>"}
{"text":"calling a procedure", "<TAL>PROC myProc (x) VOID;\n  INT x;\nBEGIN\n  WRITE (*, *) x * 2;\nEND;\nCALL myProc(5);\n</TAL>\n<Java>\npublic static void myProc(int x) {\n    System.out.println(x * 2);\n}\nmyProc(5);\n</Java>"}
{"text":"basic array", "<TAL>INT myArray[0:4];\nmyArray[0] := 10;\n</TAL>\n<Java>\nint[] myArray = new int[5];\nmyArray[0] = 10;\n</Java>"}
{"text": "basic string", "<TAL>STRING .myString[0:9] := \"Greetings!\";\nWRITE (*, *) myString;\n</TAL>\n<Java>\nString myString = \"Greetings!\";\nSystem.out.println(myString);\n</Java>"}
{"text": "basic case", "<TAL>INT choice := 2;\nCASE choice OF\n  1: WRITE (*, *) \"Option 1\";\n  2: WRITE (*, *) \"Option 2\";\n  ELSE WRITE (*, *) \"Default\";\nENDCASE;\n</TAL>\n<Java>\nint choice = 2;\nswitch (choice) {\n    case 1:\n        System.out.println(\"Option 1\");\n        break;\n    case 2:\n        System.out.println(\"Option 2\");\n        break;\n    default:\n        System.out.println(\"Default\");\n}\n</Java>"}
{"text":"Print statement", "<TAL>\nINT a := 12;\nINT b := 10;\nINT result;\nresult := a & b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a & b;\nSystem.out.println(result);\n</Java>"}
{"text":"basic logical or", "<TAL>INT a := 12;\nINT b := 10;\nINT result;\nresult := a ! b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a | b;\nSystem.out.println(result);\n</Java>"}
{"text": "basic xor", "<TAL>INT a := 12;\nINT b := 10;\nINT result;\nresult := a # b;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint a = 12;\nint b = 10;\nint result = a ^ b;\nSystem.out.println(result);\n</Java>"}
{"text":"left shift", "<TAL>INT value := 5;\nINT result;\nresult := value << 2;\nWRITE (*, *) result;\n</TAL>\n<Java>\nint value = 5;\nint result = value << 2;\nSystem.out.println(result);\n</Java>"}
{"text": "bitset", "<TAL>INT value := 10;\nINT mask := 2;\nINT result;\nIF (value & mask) <> 0 THEN\n  WRITE (*, *) \"Second bit is set\";\nELSE\n  WRITE (*, *) \"Second bit is not set\";\nENDIF;\n</TAL>\n<Java>\nint value = 10;\nint mask = 2;\nif ((value & mask) != 0) {\n    System.out.println(\"Second bit is set\");\n} else {\n    System.out.println(\"Second bit is not set\");\n}\n</Java>"}
{"text": "array init", "<TAL>INT myArray[0:4];\nmyArray[0] := 1;\nmyArray[1] := 2;\nmyArray[2] := 3;\nmyArray[3] := 4;\nmyArray[4] := 5;\nWRITE (*, *) myArray[2];\n</TAL>\n<Java>\nint[] myArray = new int[5];\nmyArray[0] = 1;\nmyArray[1] = 2;\nmyArray[2] = 3;\nmyArray[3] = 4;\nmyArray[4] = 5;\nSystem.out.println(myArray[2]);\n</Java>"}
{"text":"2d array init", "<TAL>INT myArray[0:4] := [1, 2, 3, 4, 5];\nINT i;\nFOR i := 0 TO 4 DO\n  WRITE (*, *) myArray[i];\nENDDO;\n</TAL>\n<Java>\nint[] myArray = {1, 2, 3, 4, 5};\nfor (int i = 0; i <= 4; i++) {\n    System.out.println(myArray[i]);\n}\n</Java>"}
{"text":"basic matrix", "<TAL>INT matrix[0:2,0:2];\nmatrix[0,0] := 1;\nmatrix[0,1] := 2;\nmatrix[1,0] := 3;\nmatrix[1,1] := 4;\nmatrix[2,0] := 5;\nmatrix[2,1] := 6;\nWRITE (*, *) matrix[1,1];\n</TAL>\n<Java>\nint[][] matrix = new int[3][3];\nmatrix[0][0] = 1;\nmatrix[0][1] = 2;\nmatrix[1][0] = 3;\nmatrix[1][1] = 4;\nmatrix[2][0] = 5;\nmatrix[2][1] = 6;\nSystem.out.println(matrix[1][1]);\n</Java>"}
{"text": "do loop" , "<TAL>\nINT source[0:3] := [10, 20, 30, 40];\nINT target[0:3];\nINT i;\nFOR i := 0 TO 3 DO\n  target[i] := source[i];\nENDDO;\nWRITE (*, *) target[2];\n</TAL>\n<Java>\nint[] source = {10, 20, 30, 40};\nint[] target = new int[4];\nfor (int i = 0; i <= 3; i++) {\n    target[i] = source[i];\n}\nSystem.out.println(target[2]);\n</Java>"}
{"text": "additions", "<TAL>INT myArray[0:4] := [1, 2, 3, 4, 5];\nINT sum := 0;\nINT i;\nFOR i := 0 TO 4 DO\n  sum := sum + myArray[i];\nENDDO;\nWRITE (*, *) sum;\n</TAL>\n<Java>\nint[] myArray = {1, 2, 3, 4, 5};\nint sum = 0;\nfor (int i = 0; i <= 4; i++) {\n    sum += myArray[i];\n}\nSystem.out.println(sum);\n</Java>"}
{"text": "minCostPath", "<TAL>PROC minCostPath (cost, rows, cols, m, n, result) VOID;\n  INT .cost[0:99,0:99];\n  INT rows, cols;\n  INT m, n;\n  INT .result;\nBEGIN\n  INT dp[0:99,0:99];\n  INT i, j;\n  dp[0,0] := cost[0,0];\n  FOR i := 1 TO m DO\n    dp[i,0] := dp[i-1,0] + cost[i,0];\n  ENDDO;\n  FOR j := 1 TO n DO\n    dp[0,j] := dp[0,j-1] + cost[0,j];\n  ENDDO;\n  FOR i := 1 TO m DO\n    FOR j := 1 TO n DO\n      IF dp[i-1,j] < dp[i,j-1] THEN\n        dp[i,j] := dp[i-1,j] + cost[i,j];\n      ELSE\n        dp[i,j] := dp[i,j-1] + cost[i,j];\n      ENDIF;\n    ENDDO;\n  ENDDO;\n  result := dp[m,n];\nEND;\n</TAL>\n<Java>\npublic static int minCostPath(int[][] cost, int rows, int cols, int m, int n) {\n    int[][] dp = new int[rows][cols];\n    dp[0][0] = cost[0][0];\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = cost[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[m][n];\n}\n</Java>"}
{"text": "MBPP: Simple TAL procedure to swap two INT values\n", "<TAL>PROC swap(a, b);\nINT .a, .b;\nBEGIN\n  INT temp;\n  temp := a;\n  a := b;\n  b := temp;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Simple Java method to swap two integers\n  // Uses IntWrapper to simulate pointer semantics\n  public static void swap(IntWrapper a, IntWrapper b) {\n    int temp = a.value;\n    a.value = b.value;\n    b.value = temp;\n  }\n  \n  // Helper class to simulate pointer behavior\n  public static class IntWrapper {\n    public int value;\n    \n    public IntWrapper(int value) {\n      this.value = value;\n    }\n  }\n}\n</Java>"}
{"text": "Procedure to move a string", "<TAL>PROC moveString(source, dest, len);\nSTRING .source, .dest;\nINT len;\nBEGIN\n  dest ':=' source FOR len;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to copy bytes from source to destination\n  public static void moveString(byte[] source, byte[] dest, int len) {\n    // Check bounds to prevent IndexOutOfBoundsException\n    if (source.length < len || dest.length < len) {\n      len = Math.min(source.length, dest.length);\n    }\n    \n    System.arraycopy(source, 0, dest, 0, len);\n  }\n}\n</Java>"}
{"text":"Procedure to find maximum value in an array", "<TAL>INT PROC findMax(array, len);\nINT .array;\nINT len;\nBEGIN\n  INT i, max;\n  max := array[0];\n  FOR i := 1 TO len - 1 DO\n    IF array[i] > max THEN\n      max := array[i];\n  RETURN max;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to find maximum value in an array\n  public static int findMax(int[] array, int len) {\n    if (array == null || len <= 0 || array.length < len) {\n      throw new IllegalArgumentException("Invalid array or length");\n    }\n    \n    int max = array[0];\n    for (int i = 1; i < len; i++) {\n      if (array[i] > max) {\n        max = array[i];\n      }\n    }\n    return max;\n  }\n}\n</Java>"}
{"text":"Procedure with pointer arithmetic to manipulate an array", "<TAL>PROC incrementArray(array, len);\nINT .array;\nINT len;\nBEGIN\n  INT .ptr;\n  INT i;\n  ptr := @array;\n  FOR i := 0 TO len - 1 DO\n  BEGIN\n    ptr[i] := ptr[i] + 1;\n  END;\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to increment all values in an array\n  // Simulating pointer arithmetic using array indexing\n  public static void incrementArray(int[] array, int len) {\n    if (array == null || len <= 0 || array.length < len) {\n      throw new IllegalArgumentException("Invalid array or length");\n    }\n    \n    // In Java we don't need a separate pointer\n    // but we can use the array reference directly\n    for (int i = 0; i < len; i++) {\n      array[i] = array[i] + 1;\n    }\n  }\n}\n</Java>"}
{"text":"Procedure using bit operations", "<TAL>INT PROC getBits(value, startBit, numBits);\nINT value, startBit, numBits;\nBEGIN\n  RETURN (value '<<' (16 - startBit - numBits)) '>>' (16 - numBits);\nEND;\n</TAL>\n<Java>\npublic class TandemUtils {\n  // Java method to extract bits from an integer\n  public static int getBits(int value, int startBit, int numBits) {\n    // First shift left to remove bits we don't want\n    // Then shift right to position the bits we want at the rightmost position\n    return (value << (16 - startBit - numBits)) >>> (16 - numBits);\n    // Note: Java >>> is unsigned right shift, similar to TAL '>>' operation\n  }\n}\n</Java>"}
{"text":  "procedure to allocate and use a buffer for I/O", "<TAL>PROC readFile(fileNum, len);\nINT fileNum, len;\nBEGIN\n  INT .buffer[0:255];\n  INT bytesRead;\n  \n  CALL READ(fileNum, buffer, len, bytesRead);\n  \n  IF < THEN\n  BEGIN\n    ! Handle error\n    CALL FILEINFO(fileNum, error);\n    RETURN;\n  END;\n  \n  ! Process buffer data\n  ! ...\nEND;\n</TAL>\n<Java>\nimport java.io.*;\n\npublic class GuardianIO {\n  // Java method simulating TAL file read operation\n  public static void readFile(int fileNum, int len) {\n    // Create a buffer for the file data\n    byte[] buffer = new byte[256];\n    \n    try {\n      // Stub for Guardian READ operation\n      // In a real implementation, this would map to appropriate Java I/O\n      int bytesRead = GuardianStubs.read(fileNum, buffer, len);\n      \n      // Process buffer data\n      // ...\n      \n    } catch (IOException e) {\n      // Handle error\n      int error = GuardianStubs.fileInfo(fileNum);\n      System.err.println("File error: " + error);\n    }\n  }\n  \n  // Stub class for Guardian OS functions\n  private static class GuardianStubs {\n    public static int read(int fileNum, byte[] buffer, int len) throws IOException {\n      // Implementation would connect to actual file I/O\n      // For now just return a dummy value\n      return len;\n    }\n    \n    public static int fileInfo(int fileNum) {\n      // Return dummy error code\n      return 45; // Example error code\n    }\n  }\n}\n</Java>"}
{"text": "Procedure using a structure and pointers", "<TAL>STRUCT employee (*);\nBEGIN\n  INT id;\n  STRING name[0:31];\n  FIXED(2) salary;\nEND;\n\nPROC processEmployee(emp);\nSTRUCT .emp (employee);\nBEGIN\n  INT .intPtr;\n  STRING .namePtr;\n  \n  intPtr := @emp.id;\n  namePtr := @emp.name;\n  \n  ! Process employee data\n  intPtr := intPtr + 1; ! Point to next field (after id)\n  \n  ! Print employee name (first byte)\n  ! Assumes name is null-terminated\n  CALL WRITE(term, namePtr, 32);\nEND;\n</TAL>\n<Java>\nimport java.nio.ByteBuffer;\n\npublic class StructureProcessor {\n  // Java class representing employee structure\n  public static class Employee {\n    public int id;\n    public byte[] name = new byte[32]; // Fixed-size array simulating TAL STRING array\n    public double salary;  // Equivalent to TAL FIXED(2)\n  }\n  \n  // Java method to process employee data\n  public static void processEmployee(Employee emp) {\n    // In Java, we can't do direct pointer arithmetic like in TAL\n    // Instead, we use ByteBuffer for arbitrary memory access simulation\n    ByteBuffer buffer = ByteBuffer.allocate(40); // Size large enough for structure\n    \n    // Put employee data into buffer\n    buffer.putInt(emp.id);\n    buffer.put(emp.name);\n    \n    // Simulate pointer to id\n    buffer.position(0);\n    int idValue = buffer.getInt();\n    \n    // Simulate pointer to name\n    buffer.position(4); // Position after id\n    byte[] nameBytes = new byte[32];\n    buffer.get(nameBytes);\n    \n    // Print employee name\n    try {\n      GuardianStubs.write(1, nameBytes, 32); // Simulate terminal write\n    } catch (IOException e) {\n      System.err.println("Write error: " + e.getMessage());\n    }\n  }\n  \n  // Stub class for Guardian OS functions\n  private static class GuardianStubs {\n    public static void write(int fileNum, byte[] buffer, int len) throws IOException {\n      // In a real implementation, this would map to appropriate Java I/O\n      System.out.write(buffer, 0, len);\n    }\n  }\n}\n</Java>"}
{"text": "Implementation of a simple memory manager", "<TAL>INT memoryPool[0:1023];\nINT nextFree := 0;\n\nINT PROC allocateMemory(size);\nINT size;\nBEGIN\n  INT result;\n  \n  IF (nextFree + size) > 1024 THEN\n    RETURN -1; ! Not enough memory\n  \n  result := nextFree;\n  nextFree := nextFree + size;\n  \n  RETURN result; ! Return offset into memory pool\nEND;\n\nPROC freeMemory(offset, size);\nINT offset, size;\nBEGIN\n  ! Simple implementation - doesn't actually reclaim memory\n  ! In a real implementation, would track free blocks\nEND;\n\nPROC storeData(data, len);\nINT .data, len;\nBEGIN\n  INT offset;\n  INT .destPtr;\n  \n  offset := allocateMemory(len);\n  IF offset = -1 THEN\n    RETURN; ! Failed to allocate\n  \n  destPtr := @memoryPool + offset;\n  destPtr ':=' data FOR len;\nEND;\n</TAL>\n<Java>\npublic class MemoryManager {\n  private static int[] memoryPool = new int[1024];\n  private static int nextFree = 0;\n  \n  /\n   * Allocates memory from the pool\n   * @param size Number of integers to allocate\n   * @return Offset into memory pool or -1 if allocation failed\n   */\n  public static int allocateMemory(int size) {\n    if ((nextFree + size) > 1024) {\n      return -1; // Not enough memory\n    }\n    \n    int result = nextFree;\n    nextFree += size;\n    \n    return result; // Return offset into memory pool\n  }\n  \n  /\n   * Frees memory (stub implementation)\n   * @param offset Offset into memory pool\n   * @param size Number of integers to free\n   */\n  public static void freeMemory(int offset, int size) {\n    // Simple implementation - doesn't actually reclaim memory\n    // In a real implementation, would track free blocks\n  }\n  \n  /\n   * Stores data into the memory pool\n   * @param data Source data array\n   * @param len Number of integers to store\n   * @return true if successful, false otherwise\n   */\n  public static boolean storeData(int[] data, int len) {\n    int offset = allocateMemory(len);\n    if (offset == -1) {\n      return false; // Failed to allocate\n    }\n    \n    // Copy data to memory pool\n    System.arraycopy(data, 0, memoryPool, offset, len);\n    return true;\n  }\n  \n  /\n   * Retrieves data from memory pool\n   * @param offset Offset into memory pool\n   * @param len Number of integers to retrieve\n   * @return Array containing the retrieved data\n   */\n  public static int[] retrieveData(int offset, int len) {\n    if (offset < 0 || offset + len > memoryPool.length) {\n      return null; // Invalid parameters\n    }\n    \n    int[] result = new int[len];\n    System.arraycopy(memoryPool, offset, result, 0, len);\n    return result;\n  }\n}\n</Java>"}
{"text": "Procedure declaration and call", "<TAL>PROC add_values(INT a, INT b) RETURNS INT;\nBEGIN\n  RETURN a + b;\nEND;</TAL><JAVA>int addValues(int a, int b) {\n    return a + b;\n}</JAVA>"}
{"text": "Recursion using factorial", "<TAL>PROC factorial(INT n) RETURNS INT;\nBEGIN\n  IF n = 0 THEN RETURN 1;\n  RETURN n * CALL factorial(n - 1);\nEND;</TAL><JAVA>int factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}</JAVA>"}
{"text": "Equivalenced variable for byte view of int", "<TAL>INT(32) word;\nBYTE byte1 = word[0];</TAL><JAVA>int word = 0xAABBCCDD;\nbyte byte1 = (byte)(word & 0xFF);</JAVA>"}
{"text": "File open, read, and close", "<TAL>FILE infile;\nOPEN infile, 'input.dat', INPUT;\nCALL WRITEREAD(infile, buffer, 0, 100, result);\nCLOSE infile;</TAL><JAVA>BufferedReader infile = new BufferedReader(new FileReader(\"input.dat\"));\nchar[] buffer = new char[100];\ninfile.read(buffer, 0, 100);\ninfile.close();</JAVA>"}
{"text": "<TAL>\nTAL server process that receives and processes messages\nSTRUCT message (*);\nBEGIN\n  INT msgType;\n  INT msgLen;\n  STRING data[0:255];\nEND;\n\nPROC server MAIN;\nBEGIN\n  INT .receiveBuffer[0:150];\n  STRUCT .msgBuffer (message);\n  INT receiveId;\n  INT bytesRead;\n  INT status;\n  \n  ! Open RECEIVE to get messages\n  CALL OPEN(\"RECEIVE\", receiveId);\n  \n  ! Server loop\n  WHILE 1 DO\n  BEGIN\n    ! Read the next message\n    CALL READX(receiveId, receiveBuffer, 300, bytesRead);\n    \n    IF < THEN\n    BEGIN\n      ! Handle error\n      CALL FILEINFO(receiveId, status);\n      CONTINUE;\n    END;\n    \n    ! Set up structure pointer to interpret received data\n    @msgBuffer := @receiveBuffer;\n    \n    ! Process message based on type\n    CASE msgBuffer.msgType OF\n    BEGIN\n      0 ! Echo message\n        CALL REPLYX(receiveBuffer, bytesRead);\n      \n      1 ! Store data message\n        CALL processStoreRequest(msgBuffer);\n      \n      2 ! Retrieve data message\n        CALL processRetrieveRequest(msgBuffer);\n      \n      OTHERWISE\n        ! Unknown message type\n        CALL REPLYX(\"ERROR: Unknown message type\", 26);\n    END;\n  END;\nEND;\n\nPROC processStoreRequest(msg);\nSTRUCT .msg (message);\nBEGIN\n  ! Process store request\n  ! ...\n  CALL REPLYX(\"OK\", 2);\nEND;\n\nPROC processRetrieveRequest(msg);\nSTRUCT .msg (message);\nBEGIN\n  ! Process retrieve request\n  ! ...\n  CALL REPLYX(\"DATA\", 4);\nEND;\n</TAL>\n<Java>\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class TandemServer {\n  // Java class representing message structure\n  public static class Message {\n    public int msgType;\n    public int msgLen;\n    public byte[] data = new byte[256];\n    \n    // Parse from byte array\n    public void parseFrom(byte[] buffer) {\n      ByteBuffer bb = ByteBuffer.wrap(buffer);\n      msgType = bb.getInt();\n      msgLen = bb.getInt();\n      bb.get(data, 0, Math.min(data.length, buffer.length - 8));\n    }\n    \n    // Convert to byte array\n    public byte[] toByteArray() {\n      ByteBuffer bb = ByteBuffer.allocate(8 + data.length);\n      bb.putInt(msgType);\n      bb.putInt(msgLen);\n      bb.put(data);\n      return bb.array();\n    }\n  }\n  \n  // Main server class\n  public static void main(String[] args) {\n    try {\n      // Create server socket\n      ServerSocket serverSocket = new ServerSocket(9876);\n      System.out.println(\"Server started on port 9876\");\n      \n      // Create thread pool for handling client connections\n      ExecutorService executor = Executors.newFixedThreadPool(10);\n      \n      while (true) {\n        // Accept client connection\n        Socket clientSocket = serverSocket.accept();\n        \n        // Handle client in a separate thread\n        executor.submit(() -> handleClient(clientSocket));\n      }\n    } catch (IOException e) {\n      System.err.println(\"Server error: \" + e.getMessage());\n    }\n  }\n  \n  private static void handleClient(Socket clientSocket) {\n    try {\n      InputStream in = clientSocket.getInputStream();\n      OutputStream out = clientSocket.getOutputStream();\n      \n      // Buffer for receiving data\n      byte[] receiveBuffer = new byte[512];\n      \n      // Read client message\n      int bytesRead = in.read(receiveBuffer);\n      \n      if (bytesRead > 0) {\n        // Parse message\n        Message message = new Message();\n        message.parseFrom(receiveBuffer);\n        \n        // Process message based on type\n        switch (message.msgType) {\n          case 0: // Echo message\n            out.write(receiveBuffer, 0, bytesRead);\n            break;\n            \n          case 1: // Store data message\n            processStoreRequest(message, out);\n            break;\n            \n          case 2: // Retrieve data message\n            processRetrieveRequest(message, out);\n            break;\n            \n          default:\n            // Unknown message type\n            out.write(\"ERROR: Unknown message type\".getBytes());\n        }\n      }\n      \n      clientSocket.close();\n    } catch (IOException e) {\n      System.err.println(\"Client handling error: \" + e.getMessage());\n    }\n  }\n  \n  private static void processStoreRequest(Message message, OutputStream out) throws IOException {\n    // Process store request\n    // ...\n    out.write(\"OK\".getBytes());\n  }\n  \n  private static void processRetrieveRequest(Message message, OutputStream out) throws IOException {\n    // Process retrieve request\n    // ...\n    out.write(\"DATA\".getBytes());\n  }\n}\n</Java>"}
{"text":"LITERAL Declaration - TAL literals are constants defined at the beginning of a program. In Java, we can use final variables or static final class constants.", "<TAL>LITERAL true = -1, \nfalse = 0,\nbuffer_length = 80, \ntable_size = 128;</TAL><JAVA>public class Constants {\n    public static final int TRUE = -1;\n    public static final int FALSE = 0;\n    public static final int BUFFER_LENGTH = 80;\n    public static final int TABLE_SIZE = 128;\n}</JAVA>"}
{"text":"DEFINE Declaration - TAL uses DEFINE for text substitution similar to C macros. Java does not have direct macros but can use methods or constants instead.", "<TAL>DEFINE increment(x) = x := x + 1 #;\nDEFINE wordval(a, b) = (a '<<' 12) LOR b #;</TAL><JAVA>public class Macros {\n    // For simple operations, use methods\n    public static void increment(AtomicInteger x) {\n        x.incrementAndGet();\n    }\n    \n    public static int wordVal(int a, int b) {\n        return (a << 12) | b;\n    }\n}</JAVA>"}
{"text":"Simple Variable Declaration - TAL has several data types with explicit declaration. Java uses similar type declarations.", "<TAL>INT count;\nSTRING byte;  \nINT(32) doubleword;\nFIXED(2) price;\nREAL temperature;</TAL><JAVA>int count;\nbyte byteval;  // Java byte is 8-bit signed\nint doubleword; // Java int is 32-bit\nBigDecimal price = new BigDecimal("0.00"); // For fixed decimal point\nfloat temperature;</JAVA>"}
{"text":"Array Declaration - TAL arrays can have custom bounds. Java arrays are always zero-based.", "<TAL>STRING .buffer[0:99];\nINT array[-5:5];\nINT(32) values[0:4];</TAL><JAVA>// Simple zero-based array\nbyte[] buffer = new byte[100];\n\n// For custom bounds, use wrapper class or adjust index\nclass BoundedArray {\n    private int[] data;\n    private int lowerBound;\n    \n    public BoundedArray(int lower, int upper) {\n        data = new int[upper - lower + 1];\n        lowerBound = lower;\n    }\n    \n    public int get(int index) {\n        return data[index - lowerBound];\n    }\n    \n    public void set(int index, int value) {\n        data[index - lowerBound] = value;\n    }\n}\n\nBoundedArray array = new BoundedArray(-5, 5);\nint[] values = new int[5];</JAVA>"}
{"text":"Initialization - TAL allows initialization of variables during declaration. Java has the same concept.", "<TAL>INT count := 0;\nSTRING letter := "A";\nINT(32) doubleword := 655380;</TAL><JAVA>int count = 0;\nchar letter = 'A';\nint doubleword = 655380;</JAVA>"}
{"text":"Assignment Statement - TAL uses := for assignment. Java uses the = operator.", "<TAL>count := 5;\nprice := 10.25;\nbuffer[5] := 65;</TAL><JAVA>count = 5;\nprice = new BigDecimal("10.25");\nbuffer[5] = 65;</JAVA>"}
{"text":"Procedures and Functions - TAL has PROC for procedures and typed PROC for functions. Java uses methods within classes.", "<TAL>PROC print_message;\nBEGIN\n  !Procedure code here\nEND;\n\nINT PROC calculate(x, y);\nINT x, y;\nBEGIN\n  RETURN x * y;\nEND;</TAL><JAVA>public class Operations {\n    public void printMessage() {\n        // Method code here\n    }\n\n    public int calculate(int x, int y) {\n        return x * y;\n    }\n}</JAVA>"}
{"text":"Conditional Statements - TAL uses IF-THEN-ELSE. Java has similar constructs.", "<TAL>IF a < b THEN\n  c := a\nELSE\n  c := b;</TAL><JAVA>if (a < b) {\n    c = a;\n} else {\n    c = b;\n}</JAVA>"}
{"text":"CASE Statement - TAL uses CASE for multiple branch logic. Java uses switch/case.", "<TAL>CASE vary OF BEGIN\n  !0! varyO := 0;\n  !1! vary1 := 1;\n  OTHERWISE\n    CALL error_handler;\nEND;</TAL><JAVA>switch (vary) {\n    case 0:\n        varyO = 0;\n        break;\n    case 1:\n        vary1 = 1;\n        break;\n    default:\n        errorHandler();\n        break;\n}</JAVA>"}
{"text":"Loops - TAL has FOR, WHILE, and DO-UNTIL. Java has for, while, and do-while loops.", "<TAL>FOR index := 0 TO len - 1 DO\n  array[index] := 0;\n\nWHILE i <> 0 DO BEGIN\n  i := i - 1;\nEND;\n\nDO\n  count := count + 1\nUNTIL count > 10;</TAL><JAVA>for (int index = 0; index <= len - 1; index++) {\n    array[index] = 0;\n}\n\nwhile (i != 0) {\n    i = i - 1;\n}\n\ndo {\n    count = count + 1;\n} while (!(count > 10)); // Java's do-while tests for continuation</JAVA>"}
{"text":"Bit Operations - TAL has bit manipulation operations. Java has similar bit operators.", "<TAL>INT result;\nresult := value.<7:12>;       ! Bit extraction\nvalue.<10:11> := 0;           ! Bit deposit\nshifted := value '<<' 8;      ! Unsigned left shift\nshifted := value '>>' 2;      ! Unsigned right shift</TAL><JAVA>int result;\n// Bit extraction - mask and shift\nresult = (value >> 7) & 0x3F; // Extract bits 7-12\n\n// Bit deposit - clear bits then OR\nvalue = (value & ~(0x3 << 10)) | (0 << 10); // Set bits 10-11 to 0\n\n// Shifts\nint shifted = value << 8;     // Left shift\nint shifted = value >>> 2;    // Unsigned right shift</JAVA>"}
{"text":"Structures - TAL structures group related data. Java uses classes or records.", "<TAL>STRUCT employee;\nBEGIN\n  INT id;\n  STRING name[0:30];\n  FIXED(2) salary;\nEND;</TAL><JAVA>class Employee {\n    private int id;\n    private String name;\n    private BigDecimal salary;\n    \n    public Employee() {\n        salary = new BigDecimal("0.00");\n    }\n}</JAVA>"}
{"text":"Pointers - TAL has direct pointer operations. Java uses references and has no direct pointer manipulation.", "<TAL>INT .ptr;             ! Declare pointer\n@ptr := @array[0];      ! Set pointer to array address\nptr[3] := 42;           ! Access via pointer</TAL><JAVA>// Java doesn't have direct pointers\n// References to objects are similar but more limited\nint[] array = new int[10];\n// Create a reference to the same array\nint[] arrayRef = array;\n// Modify through the reference\narrayRef[3] = 42;</JAVA>"}
{"text":"String Operations - TAL has string scanning and moving operations. Java uses String methods.", "<TAL>STRING .buffer[0:79] := 80 * [" "];\nSCAN buffer UNTIL "" -> @next_addr;\nbuffer ':=' "Hello, World!";</TAL><JAVA>char[] buffer = new char[80];\nArrays.fill(buffer, ' ');\n\n// Find character in string\nint pos = new String(buffer).indexOf('');\n// For mutable operations, use StringBuilder\nStringBuilder sb = new StringBuilder(80);\nsb.append("Hello, World!");</JAVA>"}
{"text":"Move Statement - TAL has specific move statements for copying data. Java uses System.arraycopy or Arrays methods.", "<TAL>array[0] ':=' inarray[0] FOR length;  ! Left-to-right move\narray[max] '=:' array[max-1] FOR max;  ! Right-to-left move</TAL><JAVA>// Left-to-right move equivalent to arraycopy\nSystem.arraycopy(inarray, 0, array, 0, length);\n\n// Right-to-left move needs manual implementation\n// when source and destination overlap\nfor (int i = max; i > 0; i--) {\n    array[i] = array[i-1];\n}</JAVA>"}
{"text":"Parameter Passing - TAL passes by value or reference. Java passes primitives by value and objects by reference.", "<TAL>PROC example(buffer, length);\nINT .buffer;    ! Reference parameter\nINT length;     ! Value parameter\nBEGIN\n  buffer[0] := length;\nEND;</TAL><JAVA>void example(int[] buffer, int length) {\n    // buffer is passed by reference (actually reference by value)\n    // length is passed by value\n    buffer[0] = length;\n}</JAVA>"}
{"text":"Subprocedures - TAL has subprocedures within procedures. Java uses nested or inner classes and methods.", "<TAL>PROC outer;\nBEGIN\n  INT shared;\n  \n  SUBPROC inner;\n  BEGIN\n    shared := 5;  ! Access outer's variable\n  END;\n  \n  CALL inner;\nEND;</TAL><JAVA>void outer() {\n    final int[] shared = new int[1]; // Use array for mutable value\n    \n    // Local method in Java 8+\n    class Inner {\n        void run() {\n            shared[0] = 5;  // Access outer's variable\n        }\n    }\n    \n    new Inner().run();\n}</JAVA>"}
{"text":"Modular Programming - TAL supports separate compilation with NAME and BLOCK declarations. Java uses packages and imports.", "<TAL>NAME calculator_module;\n\nBLOCK math_functions;\nLITERAL pi = 3.14159;\nEND BLOCK;\n\nPROC square(x);\nINT x;\nBEGIN\n  RETURN x * x;\nEND;</TAL><JAVA>package com.example.calculator;\n\npublic class MathFunctions {\n    public static final double PI = 3.14159;\n    \n    public static int square(int x) {\n        return x * x;\n    }\n}</JAVA>"}
{"text":"Error Handling - TAL uses ASSERTION for conditional error checking. Java uses exceptions and assertions.", "<TAL>?ASSERTION = 5, DEBUG\n\nASSERT 10 $CARRY;</TAL><JAVA>// Using Java assertions (enabled with -ea flag)\nassert !carryFlag : "Carry flag should not be set";\n\n// Using exceptions\nif (carryFlag) {\n    throw new IllegalStateException("Carry flag should not be set");\n}</JAVA>"}
{"text":"System Calls - TAL makes operating system procedure calls. Java uses native methods or runtime classes.", "<TAL>?SOURCE $SYSTEM.SYSTEM.EXTDECS(MYTERM, OPEN, WRITE)\n\nCALL MYTERM(buffer);\nCALL OPEN(buffer, hometerm);\nCALL WRITE(hometerm, buffer, len, count);</TAL><JAVA>// Java would use standard library classes\nimport java.io.;\n\nFile file = new File("output.txt");\ntry (FileOutputStream out = new FileOutputStream(file)) {\n    out.write(buffer, 0, len);\n} catch (IOException e) {\n    e.printStackTrace();\n}</JAVA>"}
{"text":"Register Stack Operations - TAL has direct stack manipulation. Java does not expose the register stack.", "<TAL>STACK x, y;    ! Push values onto register stack\nSTORE a, b;     ! Pop values from register stack</TAL><JAVA>// Java doesn't provide direct stack manipulation\n// A stack data structure would be used instead\nStack<Integer> stack = new Stack<>();\nstack.push(x);\nstack.push(y);\nb = stack.pop();\na = stack.pop();</JAVA>"}
{"text":"Machine Instructions - TAL allows direct code insertion. Java doesn't allow direct machine code, but JNI can call native code.", "<TAL>CODE (RDE; ANRI %577; SETE);</TAL><JAVA>// Java doesn't support inline assembly\n// JNI would be used for native code\npublic class NativeCode {\n    static {\n        System.loadLibrary("nativelib");\n    }\n    \n    // Declare native method\n    private native void executeNativeCode();\n}</JAVA>"}
{"text":"Privileged Procedures - TAL supports privileged mode execution. Java uses SecurityManager for privileged operations.", "<TAL>PROC privileged_proc PRIV;\nBEGIN\n  ! Privileged instructions\nEND;</TAL><JAVA>// Java uses AccessController for privileged operations\nimport java.security.;\n\nAccessController.doPrivileged(new PrivilegedAction<Void>() {\n    public Void run() {\n        // Privileged code here\n        return null;\n    }\n});</JAVA>"}
{"text":"Label Declaration and GOTO - TAL uses labels and GOTO statements for flow control. Java has labeled breaks/continues but generally avoids GOTO constructs.", "<TAL>LABEL error_handler;\n\n! Some code\nIF a > b THEN\n  GOTO error_handler;\n! More code\n\nerror_handler:\n  ! Error handling code</TAL><JAVA>// Java doesn't have direct GOTO but can use labeled breaks\nouter: {\n    // Some code\n    if (a > b) {\n        break outer; // Jump to end of block\n    }\n    // More code\n}\n// Error handling code here\n\n// Alternative approach using exceptions\ntry {\n    // Some code\n    if (a > b) {\n        throw new Exception("Error condition");\n    }\n    // More code\n} catch (Exception e) {\n    // Error handling code\n}</JAVA>"}
{"text":"Standard Functions - TAL has built-in standard functions. Java has methods in standard library classes.", "<TAL>INT x, y, result;\nresult := $MAX(x, y);     ! Maximum of two values\nresult := $ABS(x);        ! Absolute value\nresult := $UDBL(x);       ! Convert to unsigned INT(32)</TAL><JAVA>int x, y, result;\nresult = Math.max(x, y);  // Maximum of two values\nresult = Math.abs(x);     // Absolute value\n// For unsigned conversion (Java doesn't have direct unsigned types)\nlong unsignedResult = Integer.toUnsignedLong(x);</JAVA>"}
{"text":"Character Test Functions - TAL has built-in functions for testing characters. Java has Character class methods.", "<TAL>STRING char;\nIF $ALPHA(char) THEN      ! Test for alphabetic\n  ! Do something\nIF $NUMERIC(char) THEN    ! Test for numeric\n  ! Do something</TAL><JAVA>char ch;\nif (Character.isAlphabetic(ch)) {\n    // Do something\n}\nif (Character.isDigit(ch)) {\n    // Do something\n}</JAVA>"}
{"text":"RETURN Statement - TAL uses RETURN to exit procedures. Java uses return statement similarly.", "<TAL>PROC example;\nBEGIN\n  IF error THEN\n    RETURN;   ! Exit procedure early\n  \n  ! More code\n  RETURN;     ! Normal exit\nEND;\n\nINT PROC calculate;\nBEGIN\n  RETURN result;  ! Return a value\nEND;</TAL><JAVA>void example() {\n    if (error) {\n        return;   // Exit method early\n    }\n    \n    // More code\n    return;     // Normal exit (optional)\n}\n\nint calculate() {\n    return result;  // Return a value\n}</JAVA>"}
{"text":"USE and DROP Statements - TAL can explicitly reserve and free index registers. Java has no direct register management.", "<TAL>USE x;              ! Reserve index register\nFOR x := 0 TO len - 1 DO\n  array[x] := 0;\nDROP x;             ! Free index register</TAL><JAVA>// Java doesn't provide direct register management\n// The JVM handles register allocation automatically\nfor (int x = 0; x <= len - 1; x++) {\n    array[x] = 0;\n}</JAVA>"}
{"text":"Scan Operation - TAL has SCAN and RSCAN operations. Java uses String methods like indexOf.", "<TAL>STRING .buffer[0:49] := ["Smith, Maurice ", 0];\nSTRING .first, .last, .comma;\n\nSCAN buffer UNTIL "," -> @comma;   ! Find comma\nRSCAN comma[-1] WHILE " " -> @last;   ! Scan right to left</TAL><JAVA>String buffer = "Smith, Maurice ";\nint commaPos = buffer.indexOf(',');\n// To simulate right-to-left scan:\nint lastPos = commaPos - 1;\nwhile (lastPos >= 0 && buffer.charAt(lastPos) == ' ') {\n    lastPos--;\n}</JAVA>"}
{"text":"VARIABLE Procedure Parameters - TAL allows optional parameters with VARIABLE attribute. Java uses method overloading or optional parameters.", "<TAL>PROC errmsg (msg, count, errnum) VARIABLE;\nINT .msg;     ! Required parameter\nINT count;    ! Required parameter\nINT errnum;   ! Optional parameter\n\nBEGIN\n  IF NOT $PARAM(errnum) THEN \n    errnum := 0;  ! Default value\nEND;</TAL><JAVA>// Method overloading approach\npublic void errMsg(String msg, int count) {\n    errMsg(msg, count, 0);  // Call with default value\n}\n\npublic void errMsg(String msg, int count, int errNum) {\n    // Full implementation\n}\n\n// Or using Java Optional\npublic void errMsg(String msg, int count, Optional<Integer> errNum) {\n    int actualErrNum = errNum.orElse(0);  // Default if not present\n}</JAVA>"}
{"text":"EXTENSIBLE Procedures - TAL procedures can be declared EXTENSIBLE to allow parameter additions. Java can use inheritance or variable argument lists.", "<TAL>PROC x (a, b) EXTENSIBLE;\nINT a, b;\nBEGIN\n  ! Procedure code\nEND;</TAL><JAVA>// Using varargs for extensible parameter list\npublic void x(int a, int b, Object... additionalParams) {\n    // Method code\n    \n    // Check for additional parameters\n    if (additionalParams.length > 0) {\n        // Handle additional parameters\n    }\n}</JAVA>"}
{"text":"Fixed-Point Arithmetic - TAL has FIXED type for fixed-point calculations. Java uses BigDecimal.", "<TAL>FIXED(2) price := 19.95F;\nFIXED(2) total;\nINT quantity := 3;\n\ntotal := price * quantity;</TAL><JAVA>import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nBigDecimal price = new BigDecimal("19.95");\nBigDecimal total;\nint quantity = 3;\n\n// Set scale to handle 2 decimal places\nprice = price.setScale(2, RoundingMode.HALF_UP);\ntotal = price.multiply(BigDecimal.valueOf(quantity));</JAVA>"}
{"text":"System Global Pointers - TAL has special system global pointers for privileged code. Java uses JNI for system-level access.", "<TAL>INT .SG newname;   ! System global pointer</TAL><JAVA>// Java doesn't have direct system global pointers\n// JNI (Java Native Interface) would be used instead\npublic class SystemAccess {\n    static {\n        System.loadLibrary("systemaccess");\n    }\n    \n    // Native method to access system memory\n    private native int readSystemMemory(long address);\n}</JAVA>"}
{"text":"Compiler Directives - TAL uses compiler directives for controlling compilation. Java uses annotations and compiler flags.", "<TAL>?SYNTAX           ! Check syntax only\n?CODE             ! Show instruction codes\n?INSPECT          ! Enable symbolic debugging</TAL><JAVA>// Java uses annotations and compiler flags\n@SuppressWarnings("unchecked")\npublic void method() {\n    // Method implementation\n}\n\n// Compiler flags are passed to javac\n// javac -g MyClass.java        // Enable debugging\n// javac -Xlint       // Enable specific warnings</JAVA>"}
{"text":"SOURCE Directive - TAL uses SOURCE to include other files. Java uses import statements.", "<TAL>?SOURCE $SYSTEM.SYSTEM.EXTDECS(WRITE, READ)\n?SOURCE utilitysrc</TAL><JAVA>import java.io.IOException;\nimport com.example.utils.Utilities;</JAVA>"}
{"text":"BLOCK Declaration for Named Data Blocks - TAL uses BLOCK to create shared data. Java uses static fields in classes.", "<TAL>NAME calcunit;\n\nBLOCK defaultvol;\n  INT .volarray[0:7];\n  INT .outarray[0:34];\nEND BLOCK;</TAL><JAVA>package com.example.calc;\n\npublic class DefaultVolume {\n    // Shared data accessible to all classes\n    public static int[] volArray = new int[8];\n    public static int[] outArray = new int[35];\n}</JAVA>"}
{"text":"Template Structure - TAL has template structures that define a layout without allocating memory. Java uses classes or interfaces.", "<TAL>STRUCT inventory ();\nBEGIN\n  INT item;\n  INT price;\nEND;</TAL><JAVA>// Java interface (contract without implementation)\ninterface Inventory {\n    int getItem();\n    int getPrice();\n}\n\n// Or abstract class\nabstract class InventoryTemplate {\n    protected int item;\n    protected int price;\n}</JAVA>"}
{"text":"Structure Pointers - TAL has structure pointers that allow accessing structure data through a pointer. Java uses object references.", "<TAL>STRUCT emp ();\nBEGIN\n  INT id;\n  STRING name[0:30];\nEND;\n\nINT .empptr (emp) := @employee;</TAL><JAVA>class Employee {\n    private int id;\n    private String name;\n    \n    // Getters and setters\n}\n\n// Create a reference to an Employee\nEmployee employee = new Employee();\nEmployee employeeRef = employee; // Reference to the same object</JAVA>"}
{"text":"Substructures - TAL allows nested structures. Java supports nested classes.", "<TAL>STRUCT warehouse;\nBEGIN\n  STRUCT inventory[0:49];\n  BEGIN\n    INT itemNumber;\n    INT price;\n    INT onHand;\n  END;\nEND;</TAL><JAVA>class Warehouse {\n    private Inventory[] inventoryItems = new Inventory[50];\n    \n    // Nested class\n    class Inventory {\n        private int itemNumber;\n        private int price;\n        private int onHand;\n    }\n}</JAVA>"}
{"text":"Redefinitions - TAL allows redefining structure items. Java can use inheritance or interfaces for similar behavior.", "<TAL>STRUCT record;\nBEGIN\n  STRUCT wholeName;\n  BEGIN\n    STRING firstName[0:10];\n    STRING middleName[0:10];\n    STRING lastName[0:15];\n  END;\n  \n  STRUCT initials = wholeName;\n  BEGIN\n    STRING firstInitial;\n    FILLER 10;\n    STRING middleInitial;\n    FILLER 10;\n    STRING lastInitial;\n    FILLER 15;\n  END;\nEND;</TAL><JAVA>class Record {\n    // One view of the data\n    class WholeName {\n        char[] firstName = new char[11];\n        char[] middleName = new char[11];\n        char[] lastName = new char[16];\n    }\n    \n    // Another view using the same memory (Java can't do this directly)\n    // Would need to implement manual mapping or use ByteBuffer\n    class Initials {\n        private ByteBuffer buffer;\n        \n        public Initials(WholeName name) {\n            // Wrap the same memory\n            buffer = ByteBuffer.wrap(name.toString().getBytes());\n        }\n        \n        public char getFirstInitial() {\n            return (char)buffer.get(0);\n        }\n        \n        // Other methods\n    }\n}</JAVA>"}
{"text":"Base-Address Equivalencing - TAL allows equivalencing variables to base addresses. Java has no direct equivalent.", "<TAL>INT item1 = 'G' + 15;    ! Global base\nINT local = 'L' + 5;      ! Local base\nINT stack = 'S' - 2;      ! Stack base</TAL><JAVA>// Java has no direct equivalent to base address equivalencing\n// The closest would be using unsafe operations or native methods\nimport sun.misc.Unsafe;\n\nclass UnsafeOperations {\n    private static Unsafe unsafe;\n    \n    static {\n        try {\n            Field f = Unsafe.class.getDeclaredField("theUnsafe");\n            f.setAccessible(true);\n            unsafe = (Unsafe) f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    // Accessing memory at specified offset from object base\n    public static int getIntAtOffset(Object object, long offset) {\n        return unsafe.getInt(object, offset);\n    }\n}</JAVA>"}
{"text":"Conditional Compilation - TAL uses IF, IFNOT, and SETTOG for conditional compilation. Java uses preprocessor or build tools.", "<TAL>?SETTOG 1\n?IF 1\nPROC debug_proc;\nBEGIN\n  ! Debug code\nEND;\n?ENDIF 1</TAL><JAVA>// Java doesn't have direct preprocessor\n// But can use annotation processing or build flags\n\n// Using a constant\npublic class Debug {\n    private static final boolean DEBUG_ENABLED = true;\n    \n    public void debugMethod() {\n        if (DEBUG_ENABLED) {\n            // Debug code\n        }\n    }\n}</JAVA>"}
{"text":"Sample TAL Procedure - A complete procedure example converting to Java method.", "<TAL>INT PROC Ascii(v, rjust, stg);\nINT v;          ! INT value to convert\nINT rjust;      ! Right justify result flag\nSTRING .stg;    ! Target string\nBEGIN\n  STRING .b[0:5] := [5*[" "],"0"];\n  INT n;        ! Number of digits converted\n  INT sgn := 0; ! Nonzero if 'v' is negative\n  INT k := 5;   ! Index for converted digit\n  \n  IF v < 0 THEN\n  BEGIN\n    sgn := 1;\n    v := -v;\n  END;\n  \n  WHILE v DO\n  BEGIN\n    b[k] := $UDBL(v) '\' 10 + "0"; ! Convert a character\n    v := v / 10;                      ! Compute remainder\n    k := k - 1;                       ! Count converted character\n  END;\n  \n  IF sgn THEN\n  BEGIN\n    b[k] := "-";\n    k := k - 1;\n  END;\n  \n  IF NOT (n := 5-k) THEN\n    n := 1;\n  \n  IF rjust THEN\n    stg[n-1] '=:' b[5] FOR n\n  ELSE\n    stg ':=' b[6-n] FOR n;\n  \n  RETURN n;\nEND;</TAL><JAVA>/**\n * Converts an integer value to ASCII and stores in target.\n * @param v The integer value to convert\n * @param rjust Whether to right-justify the result\n * @param target The target character array\n * @return Number of characters in the result\n */\npublic int ascii(int v, boolean rjust, char[] target) {\n    char[] buffer = new char[6];\n    Arrays.fill(buffer, 0, 5, ' ');\n    buffer[5] = '0';\n    \n    int n;          // Number of digits converted\n    boolean isNeg = false;  // True if 'v' is negative\n    int k = 5;      // Index for converted digit\n    \n    if (v < 0) {\n        isNeg = true;\n        v = -v;\n    }\n    \n    while (v > 0) {\n        buffer[k] = (char)('0' + (v % 10));  // Convert a character\n        v = v / 10;                          // Compute remainder\n        k--;\n    }\n    \n    if (isNeg) {\n        buffer[k] = '-';\n        k--;\n    }\n    \n    n = 5 - k;\n    if (n == 0) {\n        n = 1;\n    }\n    \n    if (rjust) {\n        // Right justify - copy from right to left\n        for (int i = 0; i < n; i++) {\n            target[n-1-i] = buffer[5-i];\n        }\n    } else {\n        // Left justify - copy from left to right\n        for (int i = 0; i < n; i++) {\n            target[i] = buffer[6-n+i];\n        }\n    }\n    \n    return n;\n}</JAVA>"}
{"text":"TAL's Main Program Structure - Converting TAL's MAIN procedure to Java's main method.", "<TAL>INT hometerm, leftside,\n    num_xferred,\n    count,\n    asterisk,\n    buffer[0:40];   ! I/O buffer\nSTRING\n    .sbuffer := @buffer '<<' 1,  ! STRING pointer\n    blanks[0:71] := 72 * [" "];  ! Blanks\n?SOURCE $SYSTEM.SYSTEM.EXTDECS(MYTERM,OPEN,WRITEREAD,WRITE,STOP)\n\nPROC main_proc MAIN;\nBEGIN\n  CALL MYTERM(buffer);\n  CALL OPEN(buffer, hometerm);\n  \n  WHILE 1 DO BEGIN\nRetryClaude hit the max length for a message and has paused its response. You can write Continue to keep the chat going.YKContinueEditI'll continue creating more TAL to Java mappings in JSONL format with one example per line:
{"text":"Fixed-Point Rounding - TAL's ROUND directive affects FIXED value scaling. Java's BigDecimal has similar rounding options.", "<TAL>?ROUND\nFIXED(2) a := 10.235F;  ! With ROUND directive, rounds to 10.24</TAL><JAVA>import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nBigDecimal a = new BigDecimal("10.235");\n// Set scale with rounding mode\na = a.setScale(2, RoundingMode.HALF_UP);  // Results in 10.24</JAVA>"}
{"text":"READ-ONLY Arrays - TAL can declare read-only arrays in code space. Java uses final arrays or immutable collections.", "<TAL>STRING prompt = 'P' := ["Enter Character: ", 0];\nINT error = 'P' := ["ILLEGAL INPUT"];</TAL><JAVA>// Using final arrays\npublic static final char[] PROMPT = "Enter Character: ".toCharArray();\npublic static final String ERROR = "ILLEGAL INPUT";\n\n// Using immutable collections\npublic static final List<String> PROMPT = Collections.unmodifiableList(\n    Arrays.asList("Enter Character: "));</JAVA>"}
{"text":"Entry Points - TAL procedures can have multiple entry points. Java doesn't support entry points but can use separate methods.", "<TAL>PROC myprog;\nBEGIN\n  ENTRY point1, point2;\n  INT a, b;\n  \n  ! Some code\n  \n  point1:\n    a := 5;\n  \n  point2:\n    b := 10;\nEND;</TAL><JAVA>// Java doesn't support entry points\n// Use separate methods instead\npublic class MyProgram {\n    private int a;\n    private int b;\n    \n    // Normal method\n    public void myProg() {\n        // Some code\n        point1();\n    }\n    \n    // Entry point converted to method\n    public void point1() {\n        a = 5;\n        point2();\n    }\n    \n    // Entry point converted to method\n    public void point2() {\n        b = 10;\n    }\n}</JAVA>"}
{"text":"$TYPE Function - TAL can determine variable types at runtime. Java has instanceof and Class.isInstance().", "<TAL>INT type1;\ntype1 := $TYPE(var1);   ! Returns value indicating type</TAL><JAVA>// Java uses dynamic type checking\nif (variable instanceof String) {\n    // It's a String\n}\n\n// Getting class information\nClass<?> type = variable.getClass();\nString typeName = type.getName();</JAVA>"}
{"text":"$LEN Function - TAL returns byte length of structures. Java has similar concepts.", "<TAL>INT size;\nsize := $LEN(record);   ! Returns structure size in bytes</TAL><JAVA>// Java doesn't directly expose object memory size\n// For arrays, we can get length\nint size = array.length;\n\n// Instrumentation API can get approximate object size\nimport java.lang.instrument.Instrumentation;\n\npublic class ObjectSizeFetcher {\n    private static Instrumentation instrumentation;\n    \n    public static void premain(String args, Instrumentation inst) {\n        instrumentation = inst;\n    }\n    \n    public static long getObjectSize(Object obj) {\n        return instrumentation.getObjectSize(obj);\n    }\n}</JAVA>"}
{"text":"$OFFSET Function - TAL gets offset of structure item. Java doesn't expose memory layout directly.", "<TAL>INT offset;\noffset := $OFFSET(record.field);  ! Gets byte offset</TAL><JAVA>// Java doesn't directly expose memory layout or field offsets\n// The closest equivalent requires unsafe operations\n\nimport sun.misc.Unsafe;\nimport java.lang.reflect.Field;\n\nclass FieldOffset {\n    private static Unsafe unsafe;\n    \n    static {\n        try {\n            Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            f.setAccessible(true);\n            unsafe = (Unsafe) f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    // Get field offset\n    public static long getOffset(Class<?> clazz, String fieldName) throws NoSuchFieldException {\n        return unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName));\n    }\n}</JAVA>"}
{"text":"$OCCURS Function - TAL returns number of structure occurrences. Java uses array length.", "<TAL>INT count;\ncount := $OCCURS(array);  ! Returns array size</TAL><JAVA>// For arrays\nint count = array.length;\n\n// For collections\nint count = list.size();</JAVA>"}
{"text":"Standard Indirection - TAL has standard addressing for current data segment. Java manages references to objects.", "<TAL>INT .pointer;\n@pointer := @array[0];  ! Set pointer to array address</TAL><JAVA>// Java references are implicit pointers to objects\nint[] array = new int[10];\nint[] reference = array;  // Reference points to same array</JAVA>"}
{"text":"Extended Indirection - TAL supports 32-bit extended addressing. Java hides memory addressing from developers.", "<TAL>INT .EXT extptr;\n@extptr := %200000D;  ! 32-bit extended address</TAL><JAVA>// Java doesn't expose memory addresses\n// Memory management is handled by the JVM\n\n// Unsafe can be used for low-level memory access (not recommended)\nimport sun.misc.Unsafe;\n\nclass ExtendedMemory {\n    private static Unsafe unsafe;\n    \n    static {\n        try {\n            Field f = Unsafe.class.getDeclaredField("theUnsafe");\n            f.setAccessible(true);\n            unsafe = (Unsafe) f.get(null);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    public static void writeToAddress(long address, int value) {\n        unsafe.putInt(address, value);\n    }\n}</JAVA>"}
{"text":"FILLER Declaration - TAL uses FILLER to create placeholder bytes. Java would use padding fields.", "<TAL>STRUCT record;\nBEGIN\n  STRING data[0:2];\n  FILLER 1;  ! Pad byte for alignment\n  INT word;\nEND;</TAL><JAVA>class Record {\n    private byte[] data = new byte[3];\n    private byte padding;  // Explicit pad byte\n    private int word;\n}</JAVA>"}
{"text":"System Requirements - TAL programs may depend on microcode. Java uses runtime libraries.", "<TAL>! Program requires optional microcode:\n! - Decimal arithmetic option\n! - Floating-point option</TAL><JAVA>// Java dependencies are declared using import statements\n// or in build configuration files like pom.xml or build.gradle\n\nimport java.math.BigDecimal;  // For decimal arithmetic\nimport java.util.concurrent.;  // For concurrency utilities\n\n// In Maven pom.xml\n/\n<dependencies>\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-math3</artifactId>\n        <version>3.6.1</version>\n    </dependency>\n</dependencies>\n*/</JAVA>"}
{"text":"Data Units - TAL works with bit, byte, word, doubleword, and quadword units. Java abstracts these details.", "<TAL>! Data units in TAL:\n! Bit field - 1-16 bits\n! Byte - 8 bits\n! Word - 16 bits\n! Doubleword - 32 bits\n! Quadword - 64 bits</TAL><JAVA>// Java primitive data types:\n// byte - 8 bits\n// short - 16 bits\n// int - 32 bits\n// long - 64 bits\n// float - 32 bits\n// double - 64 bits\n// char - 16 bits\n// boolean - 1 bit (but JVM implementation dependent)\n\n// Working with bits\nint value = 0x1234;\nint mask = 0x0F00;  // Bits 8-11\nint extracted = (value & mask) >> 8;  // Extract bits 8-11</JAVA>"}
{"text":"Main Process Environment - TAL accesses process environment registers. Java abstracts the process environment.", "<TAL>! TAL accesses process environment:\n! - Program Counter (P) Register\n! - Instruction (I) Register\n! - Local (L) Register\n! - Stack (S) Register</TAL><JAVA>// Java abstracts process environment details\n// Thread information can be accessed\n\nThread currentThread = Thread.currentThread();\nThreadGroup group = currentThread.getThreadGroup();\nStackTraceElement[] stack = Thread.currentThread().getStackTrace();\n\n// Runtime information\nRuntime runtime = Runtime.getRuntime();\nlong memoryUsed = runtime.totalMemory() - runtime.freeMemory();</JAVA>"}
{"text":"Storage Allocation Rules - TAL has explicit rules for variable storage. Java handles this automatically.", "<TAL>! TAL storage allocation rules:\n! - Global variables at offset from G[0]\n! - Local variables at offset from L[1]\n! - Sublocal variables at offset from S[0]</TAL><JAVA>// Java handles memory allocation automatically\n\n// Variables have different scopes and lifetimes:\nclass MyClass {\n    // Class (static) variables - exist for entire program\n    static int classVar;\n    \n    // Instance variables - exist for object lifetime\n    int instanceVar;\n    \n    void method() {\n        // Local variables - exist for method duration\n        int localVar;\n        \n        // Block-scoped variables - exist for block duration\n        if (true) {\n            int blockVar;\n        }\n    }\n}</JAVA>"}
{"text":"Primary and Secondary Storage - TAL uses primary and secondary storage areas. Java abstracts memory management.", "<TAL>! TAL storage areas:\n! - Global primary area: 256 words\n! - Local primary area: 127 words\n! - Sublocal primary area: 31 words\n! - Global/local secondary areas for indirect data</TAL><JAVA>// Java abstracts memory management\n// Variables are stored based on scope:\n\npublic class Memory {\n    // Class/static variables stored in method area/metaspace\n    static int staticVar;\n    \n    // Instance variables stored in heap\n    int instanceVar;\n    Object reference;\n    \n    public void method() {\n        // Local primitives stored on thread stack\n        int localVar;\n        \n        // Local objects: reference on stack, object on heap\n        String localObj = new String("Hello");\n    }\n}</JAVA>"}
{"text":"CROSSREF Directive - TAL generates cross-reference listings. Java IDEs provide similar information.", "<TAL>?CROSSREF\n?CROSSREF VARIABLES, UNREF</TAL><JAVA>// Java IDEs provide cross-reference info through features like:\n// - Find Usages (IntelliJ IDEA)\n// - References (Visual Studio Code)\n// - Call Hierarchy (Eclipse)\n\n// Tools like JaCoCo can generate code coverage reports\n// Static analysis tools like SonarQube can find unused code</JAVA>"}
{"text":"CODE and ICODE Directives - TAL can list machine instructions. Java can use disassemblers.", "<TAL>?CODE      ! Show instruction codes in octal\n?ICODE     ! Show instruction mnemonics</TAL><JAVA>// Java bytecode can be viewed using tools like:\n// - javap (JDK tool)\n// - IntelliJ IDEA bytecode viewer\n// - JD-GUI decompiler\n\n// Using javap:\n// javap -c MyClass.class\n\n// For JIT-compiled code (more advanced):\n// java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MyClass</JAVA>"}
{"text":"Reserved Words - TAL has specific reserved words. Java also has reserved keywords.", "<TAL>! TAL reserved words include:\n! BEGIN, CALL, CASE, DO, END, FOR, IF, INT, PROC, RETURN, WHILE</TAL><JAVA>// Java reserved keywords include:\n// abstract, assert, boolean, break, byte, case, catch, char,\n// class, const, continue, default, do, double, else, enum,\n// extends, final, finally, float, for, if, implements, import,\n// instanceof, int, interface, long, native, new, package,\n// private, protected, public, return, short, static, strictfp,\n// super, switch, synchronized, this, throw, throws, transient,\n// try, void, volatile, while</JAVA>"}
{"text":"Bit Field Access - TAL directly accesses bit fields. Java uses bit operations.", "<TAL>INT word;\nINT bits;\n\n! Extract bits 4-7\nbits := word.<4:7>;\n\n! Deposit bits 12-15\nword.<12:15> := bits;</TAL><JAVA>int word;\nint bits;\n\n// Extract bits 4-7 (4 bits)\nbits = (word >> 4) & 0x0F;\n\n// Deposit bits 12-15\nword = (word & ~(0x0F << 12)) | ((bits & 0x0F) << 12);\n\n// Java 17+ bit operations (preview feature)\n// int bits = (int)BitOperations.extractBits(word, 4, 8);</JAVA>"}
{"text":"Constant Lists - TAL supports constant lists for arrays. Java uses array initializers.", "<TAL>INT array1[0:3] := [1, 2, 3, 4];\nSTRING .buffer[0:49] := 50 * [" "];\nINT nestedArray[0:9] := [3 * [2 * [1], 2 * [0]]];</TAL><JAVA>int[] array1 = {1, 2, 3, 4};\n\nchar[] buffer = new char[50];\nArrays.fill(buffer, ' ');\n\n// For nested initialization, must use loops or helpers\nint[] nestedArray = new int[10];\n// Fill with pattern [1,1,0,0,1,1,0,0,1,1,0,0]\nfor (int i = 0; i < 3; i++) {\n    nestedArray[i4] = 1;\n    nestedArray[i4+1] = 1;\n    // 0 is default value\n}</JAVA>"}
{"text":"Number Bases - TAL supports different base notations. Java supports decimal, hex, octal, and binary.", "<TAL>INT decimal := 47;\nINT binary := %B101111;\nINT octal := %57;\nINT hex := %H2F;</TAL><JAVA>int decimal = 47;\nint binary = 0b101111;\nint octal = 057;\nint hex = 0x2F;</JAVA>"}
{"text":"MAP Directive - TAL can display identifier maps. Java uses reflection.", "<TAL>?MAP       ! Display identifier maps\n?NOMAP     ! Suppress identifier maps</TAL><JAVA>// Java reflection can inspect classes at runtime\n\nClass<?> cls = MyClass.class;\n\n// Get all fields\nField[] fields = cls.getDeclaredFields();\nfor (Field field : fields) {\n    System.out.println(field.getName() + ": " + field.getType());\n}\n\n// Get all methods\nMethod[] methods = cls.getDeclaredMethods();\nfor (Method method : methods) {\n    System.out.println(method.getName());\n}</JAVA>"}
{"text":"MAIN and RESIDENT Attributes - TAL procedures can be MAIN or RESIDENT. Java has main method and can use classloaders.", "<TAL>PROC main_proc MAIN;\nBEGIN\n  ! First procedure to execute when program runs\nEND;\n\nPROC always_in_memory RESIDENT;\nBEGIN\n  ! Stays in main memory\nEND;</TAL><JAVA>public class MainClass {\n    // Java entry point method\n    public static void main(String[] args) {\n        // First method to execute when program runs\n    }\n}\n\n// Java doesn't have direct equivalent of RESIDENT\n// ClassLoaders control class loading/unloading\n// System classes are loaded by bootstrap classloader</JAVA>"}
{"text":"INTERRUPT Attribute - TAL has procedures for interrupt handling. Java uses exception handling.", "<TAL>PROC int_handler INTERRUPT;\nBEGIN\n  ! Handle hardware interrupt\nEND;</TAL><JAVA>// Java doesn't directly handle hardware interrupts\n// Signal handling requires JNI/native code\n\n// Exception handling is conceptually similar\ntry {\n    // Code that might be interrupted\n} catch (Exception e) {\n    // Handle the exception\n} finally {\n    // Always executed\n}</JAVA>"}
{"text":"Format of Source Code - TAL has flexible format. Java also has flexible formatting but with conventions.", "<TAL>INT a,\n    b,\n    c: char1, char2, char3;\nPROC format_example MAIN; BEGIN\n  a := 1;\n  b := 2;\n  c := a + b; char1 := "A"; char2 := "B"; char3 := "C";\nEND;</TAL><JAVA>// Java has flexible formatting but conventions exist\n\n// Conventional Java style\npublic class FormatExample {\n    private int a, b, c;\n    private char char1, char2, char3;\n    \n    public static void main(String[] args) {\n        FormatExample example = new FormatExample();\n        example.run();\n    }\n    \n    public void run() {\n        a = 1;\n        b = 2;\n        c = a + b;\n        char1 = 'A';\n        char2 = 'B';\n        char3 = 'C';\n    }\n}</JAVA>"}
{"text":"Procedure Entry Sequence - TAL handles procedure entry and parameters in stack. Java uses JVM stack frame.", "<TAL>! On entry to procedure:\n! - System saves caller's environment\n! - Parameter passing through parameter area\n! - Local data space allocated</TAL><JAVA>// Java method invocation:\n// - JVM creates new stack frame\n// - Parameters passed on stack\n// - Local variables allocated in frame\n// - Return address saved\n\npublic void method(int param1, String param2) {\n    int localVar = param1 + 5;\n    // Method body\n    return; // JVM restores previous stack frame\n}</JAVA>"}
{"text":"Byte and Word Addressing - TAL has explicit byte and word addressing. Java abstracts memory addressing.", "<TAL>! STRING variables have byte addresses\n! Other variables have word addresses</TAL><JAVA>// Java abstracts memory addressing\n// Primitive types have specific sizes:\nbyte b;     // 8 bits\nshort s;    // 16 bits\nint i;      // 32 bits\nlong l;     // 64 bits\nfloat f;    // 32 bits\ndouble d;   // 64 bits\nchar c;     // 16 bits\nboolean bo; // JVM implementation dependent</JAVA>"}
{"text":"Group Comparison - TAL can compare groups of elements. Java uses Arrays.equals and similar methods.", "<TAL>IF array1 = array2 FOR 10 -> @pointer THEN\n  ! Arrays match for first 10 elements</TAL><JAVA>// Compare arrays\nboolean match = Arrays.equals(array1, 0, 10, array2, 0, 10);\nif (match) {\n    // Arrays match for first 10 elements\n}\n\n// For more complex comparisons with partial matches\nint mismatchIdx = -1;\nfor (int i = 0; i < 10; i++) {\n    if (array1[i] != array2[i]) {\n        mismatchIdx = i;\n        break;\n    }\n}</JAVA>"}
{"text":"SG Equivalencing - TAL allows access to system global data. Java normally restricts system access but JNI provides options.", "<TAL>INT .SG sysptr;    ! System global pointer\nINT sysvar = 'SG' + 5;  ! 'SG' equivalenced variable</TAL><JAVA>// Java doesn't provide direct system memory access\n// JNI or JNA can be used for native system access\n\npublic class SystemAccess {\n    static {\n        System.loadLibrary("systemaccess");\n    }\n    \n    // Native method to access system memory\n    private native int readSystemValue(int offset);\n    private native void writeSystemValue(int offset, int value);\n}</JAVA>"}
{"text":"Object File Control - TAL has directives to control object file generation. Java uses compiler flags and build tools.", "<TAL>?ABORT     ! Terminate compilation on error\n?COMPACT   ! Move procedures to fill gaps\n?PEP = 60  ! Specify PEP table size\n?SYMBOLS   ! Include symbol table</TAL><JAVA>// Java compilation options (javac flags)\n// -g                   Include debugging info\n// -Xlint               Enable warnings\n// -Werror              Treat warnings as errors\n\n// Build tools like Maven or Gradle for project-level settings\n/\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <source>11</source>\n                <target>11</target>\n                <debug>true</debug>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n/</JAVA>"}
{"text":"CALL Statement - TAL uses CALL to invoke procedures. Java uses method invocation.", "<TAL>CALL compute_tax (item, rate, result);\nCALL FILEINFO (filenum, error, , devnum);</TAL><JAVA>computeTax(item, rate, result);\nfileInfo(fileNum, error, null, devNum);</JAVA>"}
{"text":"Functions for Privileged Operations - TAL has special privileged functions. Java uses security and native interfaces.", "<TAL>INT result;\nresult := $AXADR(variable);    ! Get absolute extended address\nresult := $BOUNDS(param, count);  ! Check parameter bounds\nresult := $PSEM(sem_addr, interval);  ! Request semaphore\nresult := $SWITCHES;  ! Get SWITCH register</TAL><JAVA>// Java SecurityManager and AccessController for privileges\n\nimport java.security.;\n\n// Privileged action\nString result = AccessController.doPrivileged(\n    new PrivilegedAction<String>() {\n        public String run() {\n            // Protected operation\n            return System.getProperty("user.home");\n        }\n    }\n);\n\n// JNI for native system operations\npublic class NativeOps {\n    static {\n        System.loadLibrary("nativeops");\n    }\n    \n    public native int getSystemSwitches();\n}</JAVA>"}
{"text":"$SCALE Function - TAL scales FIXED values by moving decimal points. Java has BigDecimal scaling.", "<TAL>FIXED(3) a := 12.345F;\nFIXED(5) b;\n\nb := $SCALE(a, 2);  ! Scale up by 2 decimal places</TAL><JAVA>import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\nBigDecimal a = new BigDecimal("12.345");\nBigDecimal b;\n\n// Scale up by 2 decimal places\nb = a.setScale(5, RoundingMode.HALF_UP);  // 12.34500</JAVA>"}
{"text":"Hardware Indicator Testing - TAL can test hardware condition codes. Java abstracts hardware details.", "<TAL>! Test for arithmetic overflow\nIF $OVERFLOW THEN\n  ! Handle overflow\n\n! Test for carry bit\nIF $CARRY THEN\n  ! Handle carry condition</TAL><JAVA>// Java doesn't expose hardware indicators\n// Overflow must be handled with explicit checks\n\n// Checking for integer overflow\ntry {\n    int result = Math.addExact(a, b);  // Throws on overflow\n} catch (ArithmeticException e) {\n    // Handle overflow\n}\n\n// Alternative approach with manual checking\nlong longResult = (long)a + (long)b;\nif (longResult > Integer.MAX_VALUE || longResult < Integer.MIN_VALUE) {\n    // Handle overflow\n}</JAVA>"}
{"text":"Example TAL Program - Complete TAL program converted to Java equivalent.", "<TAL>INT hometerm, leftside,\n    num_xferred,\n    count,\n    asterisk,\n    buffer[0:40];   ! I/O buffer\nSTRING\n    .sbuffer := @buffer '<<' 1,  ! STRING pointer to I/O buffer\n    blanks[0:71] := 72 * [" "];  ! Blanks for initialization\n?SOURCE $SYSTEM.SYSTEM.EXTDECS(MYTERM,OPEN,WRITEREAD,WRITE,STOP)\n\nPROC main_proc MAIN;\nBEGIN\n  CALL MYTERM(buffer);\n  CALL OPEN(buffer, hometerm);\n  \n  WHILE 1 DO BEGIN\n    sbuffer ':=' "ENTER STRING" ->\n    CALL WRITEREAD(hometerm, buffer, 12, 68, num_xferred);\n    \n    sbuffer[num_xferred] := 0;  ! Delimit the input\n    SCAN sbuffer UNTIL "" -> asterisk;  ! Scan for asterisk\n    \n    IF NOT $CARRY THEN BEGIN\n      ! Asterisk found code\n    END;\n  END;\nEND;</TAL><JAVA>import java.io.;\nimport java.util.Arrays;\n\npublic class MainProgram {\n    private static BufferedReader reader;\n    private static PrintWriter writer;\n    private static int homeTerminal;\n    private static int numTransferred;\n    private static int asteriskPosition;\n    private static char[] buffer = new char[41];\n    \n    public static void main(String[] args) throws IOException {\n        // Initialize terminal I/O\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new PrintWriter(System.out, true);\n        \n        // Equivalent of terminal setup\n        homeTerminal = 0; // stdin/stdout in Java\n        \n        // Main program loop\n        while (true) {\n            // Prompt for input\n            writer.print("ENTER STRING");\n            \n            // Read input\n            String input = reader.readLine();\n            numTransferred = input.length();\n            \n            // Copy to buffer\n            input.getChars(0, Math.min(numTransferred, buffer.length - 1), buffer, 0);\n            buffer[numTransferred] = '\0';  // Null terminator\n            \n            // Scan for asterisk\n            asteriskPosition = -1;\n            for (int i = 0; i < numTransferred; i++) {\n                if (buffer[i] == '') {\n                    asteriskPosition = i;\n                    break;\n                }\n            }\n            \n            // Handle asterisk found\n            if (asteriskPosition >= 0) {\n                // Asterisk found code\n            }\n        }\n    }\n}</JAVA>"}
