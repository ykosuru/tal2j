{"text": "<TAL>\nPROC MinCostPath (cost[][], m, n) RETURNS INT;\nVAR\n    i, j : INT;\n    minVal : INT;\n    minCost[100][100] : INT;\nBEGIN\n    minCost[0][0] := cost[0][0];\n\n    FOR i := 1 TO m DO\n        minCost[i][0] := minCost[i - 1][0] + cost[i][0];\n    END;\n\n    FOR j := 1 TO n DO\n        minCost[0][j] := minCost[0][j - 1] + cost[0][j];\n    END;\n\n    FOR i := 1 TO m DO\n        FOR j := 1 TO n DO\n            minVal := min(minCost[i - 1][j], minCost[i][j - 1]);\n            minCost[i][j] := minVal + cost[i][j];\n        END;\n    END;\n\n    RETURN minCost[m][n];\nEND;\n</TAL>\n<Java>\npublic class MinCostPath {\n    public static int minCost(int[][] cost, int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        dp[0][0] = cost[0][0];\n\n        for (int i = 1; i <= m; i++) {\n            dp[i][0] = dp[i - 1][0] + cost[i][0];\n        }\n\n        for (int j = 1; j <= n; j++) {\n            dp[0][j] = dp[0][j - 1] + cost[0][j];\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC FindSimilarElements(tupleList1[][], tupleList2[][], result[][]) RETURNS INT;\nVAR\n    i, j, k : INT;\n    count : INT;\nBEGIN\n    count := 0;\n    FOR i := 0 TO LENGTH(tupleList1) - 1 DO\n        FOR j := 0 TO LENGTH(tupleList2) - 1 DO\n            IF tupleList1[i][0] = tupleList2[j][0] AND\n               tupleList1[i][1] = tupleList2[j][1] THEN\n                result[count][0] := tupleList1[i][0];\n                result[count][1] := tupleList1[i][1];\n                count := count + 1;\n            END;\n        END;\n    END;\n    RETURN count;\nEND;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class SimilarTuples {\n    public static List<int[]> findSimilarElements(List<int[]> list1, List<int[]> list2) {\n        List<int[]> result = new ArrayList<>();\n        for (int[] tuple1 : list1) {\n            for (int[] tuple2 : list2) {\n                if (Arrays.equals(tuple1, tuple2)) {\n                    result.add(tuple1);\n                }\n            }\n        }\n        return result;\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC IsNonPrime(num INT) RETURNS BOOL;\nVAR\n    i : INT;\nBEGIN\n    IF num <= 1 THEN\n        RETURN TRUE;\n    END;\n    FOR i := 2 TO num - 1 DO\n        IF num MOD i = 0 THEN\n            RETURN TRUE;\n        END;\n    END;\n    RETURN FALSE;\nEND;\n\nPROC FindNonPrimes(arr[], result[], size INT) RETURNS INT;\nVAR\n    i, count : INT;\nBEGIN\n    count := 0;\n    FOR i := 0 TO size - 1 DO\n        IF IsNonPrime(arr[i]) THEN\n            result[count] := arr[i];\n            count := count + 1;\n        END;\n    END;\n    RETURN count;\nEND;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class NonPrimeFinder {\n    public static boolean isNonPrime(int num) {\n        if (num <= 1) return true;\n        for (int i = 2; i < num; i++) {\n            if (num % i == 0) return true;\n        }\n        return false;\n    }\n\n    public static List<Integer> findNonPrimes(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        for (int num : numbers) {\n            if (isNonPrime(num)) {\n                result.add(num);\n            }\n        }\n        return result;\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC FindLargestUsingHeap(numbers[], size INT, k INT, result[]) RETURNS INT;\nVAR\n    i, j, temp : INT;\n    heap[100] : INT;\nBEGIN\n    FOR i := 0 TO size - 1 DO\n        heap[i] := numbers[i];\n    END;\n\n    FOR i := size / 2 - 1 DOWNTO 0 DO\n        CALL Heapify(heap, size, i);\n    END;\n\n    FOR i := size - 1 DOWNTO size - k DO\n        result[size - 1 - i] := heap[0];\n        heap[0] := heap[i];\n        CALL Heapify(heap, i, 0);\n    END;\n    RETURN k;\nEND;\n\nPROC Heapify(arr[], n INT, i INT);\nVAR\n    largest, l, r, temp : INT;\nBEGIN\n    largest := i;\n    l := 2 * i + 1;\n    r := 2 * i + 2;\n\n    IF l < n AND arr[l] > arr[largest] THEN\n        largest := l;\n    END;\n    IF r < n AND arr[r] > arr[largest] THEN\n        largest := r;\n    END;\n\n    IF largest <> i THEN\n        temp := arr[i];\n        arr[i] := arr[largest];\n        arr[largest] := temp;\n        CALL Heapify(arr, n, largest);\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class LargestUsingHeap {\n    public static List<Integer> findLargest(int[] numbers, int k) {\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        for (int num : numbers) {\n            maxHeap.add(num);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n            result.add(maxHeap.poll());\n        }\n        return result;\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC NumWaysToFillDomino(n INT) RETURNS INT;\nVAR\n    dp[100] : INT;\n    i : INT;\nBEGIN\n    IF n MOD 2 <> 0 THEN\n        RETURN 0;\n    END;\n\n    dp[0] := 1;\n    dp[2] := 3;\n\n    FOR i := 4 TO n STEP 2 DO\n        dp[i] := 4 * dp[i - 2] - dp[i - 4];\n    END;\n\n    RETURN dp[n];\nEND;\n</TAL>\n<Java>\npublic class DominoTiling {\n    public static int numWaysToFillDomino(int n) {\n        if (n % 2 != 0) return 0;\n\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[2] = 3;\n\n        for (int i = 4; i <= n; i += 2) {\n            dp[i] = 4 * dp[i - 2] - dp[i - 4];\n        }\n\n        return dp[n];\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC DifferByOneBit(a INT, b INT) RETURNS BOOL;\nVAR\n    xor_result INT;\nBEGIN\n    xor_result := a XOR b;\n    IF xor_result <> 0 AND (xor_result AND (xor_result - 1)) = 0 THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END;\nEND;\n</TAL>\n<Java>\npublic class BitDifferenceChecker {\n    public static boolean differByOneBit(int a, int b) {\n        int xor = a ^ b;\n        return xor != 0 && (xor & (xor - 1)) == 0;\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC find_long_words (input_string, result_array, result_count) FIXED;\nSTRING .input_string[];\nSTRING .result_array[][*];\nINT .result_count;\nBEGIN\n  STRING pattern[0:10];\n  STRING temp_word[0:255];\n  INT pos, len, i;\n  pattern := "[a-zA-Z]{4,}";\n  result_count := 0;\n  pos := 0;\n  len := $LEN(input_string);\n  WHILE pos < len DO\n    CALL $REGEX_MATCH(input_string, pattern, pos, temp_word);\n    IF $REGEX_FOUND THEN\n      result_array[result_count] := temp_word;\n      result_count := result_count + 1;\n      pos := $REGEX_END_POS;\n    ELSE\n      pos := pos + 1;\n    ENDIF;\n  ENDWHILE;\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class WordFinder {\n    public static List<String> findLongWords(String input) {\n        List<String> result = new ArrayList<>();\n        Pattern pattern = Pattern.compile("\\b[a-zA-Z]{4,}\\b");\n        Matcher matcher = pattern.matcher(input);\n        while (matcher.find()) {\n            result.add(matcher.group());\n        }\n        return result;\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE list FIXED BINARY(20) ARRAY[10];\nDECLARE result FIXED BINARY(20) ARRAY[10];\nDECLARE i FIXED BINARY(20);\n\nFOR i = 1 TO 10 DO\n    result(i) = list(i) * list(i);\nEND;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class SquareElements {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        List<Integer> result = list.stream()\.map(x -> x * x)\n                                   .collect(Collectors.toList());\n        System.out.println(result);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str FIXED CHAR(100);\nDECLARE n FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE rotated FIXED CHAR(100);\nDECLARE min_rotations FIXED BINARY(20) INIT 0;\n\nn = LENGTH(str);\n\nFOR i = 1 TO n DO\n    rotated = SUBSTRING(str, i) + SUBSTRING(str, 1, i-1);\n    IF rotated = str THEN\n        min_rotations = i;\n        BREAK;\n    END;\nEND;\n</TAL>\n<Java>\npublic class MinimumRotations {\n    public static void main(String[] args) {\n        String str = \"abcabc\";\n        int n = str.length();\n        int minRotations = 0;\n\n        for (int i = 1; i <= n; i++) {\n            String rotated = str.substring(i) + str.substring(0, i);\n            if (rotated.equals(str)) {\n                minRotations = i;\n                break;\n            }\n        }\n\n        System.out.println(minRotations);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE dataset FIXED BINARY(20) ARRAY[100];\nDECLARE n FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE temp FIXED BINARY(20);\nDECLARE smallest FIXED BINARY(20) ARRAY[10];\n\nFOR i = 1 TO n DO\n    smallest(i) = dataset(i);\nEND;\n\nFOR i = 1 TO n DO\n    FOR j = i + 1 TO n DO\n        IF smallest(i) > smallest(j) THEN\n            temp = smallest(i);\n            smallest(i) = smallest(j);\n            smallest(j) = temp;\n        END;\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class SmallestItems {\n    public static void main(String[] args) {\n        List<Integer> dataset = Arrays.asList(9, 2, 7, 4, 5, 1, 8, 3, 6);\n        int n = 3; // Number of smallest items to get\n\n        List<Integer> smallest = dataset.stream()\n                                        .sorted()\n                                        .limit(n)\n                                        .collect(Collectors.toList());\n\n        System.out.println(smallest);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str FIXED CHAR(100);\nDECLARE char_to_remove FIXED CHAR(1);\nDECLARE first_pos FIXED BINARY(20);\nDECLARE last_pos FIXED BINARY(20);\nDECLARE modified_str FIXED CHAR(100);\n\nfirst_pos = POSITION(char_to_remove IN str);\nlast_pos = REVERSE_POSITION(char_to_remove IN str);\n\nIF first_pos > 0 AND last_pos > 0 THEN\n    modified_str = SUBSTRING(str, 1, first_pos-1) + SUBSTRING(str, first_pos+1, last_pos-first_pos-1) + SUBSTRING(str, last_pos+1);\nEND;\n</TAL>\n<Java>\npublic class RemoveFirstAndLastOccurrence {\n    public static void main(String[] args) {\n        String str = \"abacadae\";\n        char charToRemove = 'a';\n\n        int firstPos = str.indexOf(charToRemove);\n        int lastPos = str.lastIndexOf(charToRemove);\n\n        if (firstPos != -1 && lastPos != -1) {\n            str = str.substring(0, firstPos) + str.substring(firstPos + 1, lastPos) + str.substring(lastPos + 1);\n        }\n\n        System.out.println(str);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE matrix FIXED BINARY(20) ARRAY[5, 5];\nDECLARE row_sum FIXED BINARY(20) ARRAY[5];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE temp FIXED BINARY(20);\n\nFOR i = 1 TO 5 DO\n    row_sum(i) = 0;\n    FOR j = 1 TO 5 DO\n        row_sum(i) = row_sum(i) + matrix(i, j);\n    END;\nEND;\n\nFOR i = 1 TO 4 DO\n    FOR j = i + 1 TO 5 DO\n        IF row_sum(i) > row_sum(j) THEN\n            FOR k = 1 TO 5 DO\n                temp = matrix(i, k);\n                matrix(i, k) = matrix(j, k);\n                matrix(j, k) = temp;\n            END;\n            temp = row_sum(i);\n            row_sum(i) = row_sum(j);\n            row_sum(j) = temp;\n        END;\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortMatrix {\n    public static void main(String[] args) {\n        int[][] matrix = {\n            {5, 1, 2, 3, 4},\n            {8, 3, 1, 6, 7},\n            {4, 4, 4, 4, 4},\n            {9, 0, 1, 2, 3},\n            {1, 2, 3, 4, 5}\n        };\n\n        Integer[] rowSums = new Integer[matrix.length];\n        for (int i = 0; i < matrix.length; i++) {\n            rowSums[i] = Arrays.stream(matrix[i]).sum();\n        }\n\n        Integer[] sortedIndices = new Integer[matrix.length];\n        for (int i = 0; i < matrix.length; i++) {\n            sortedIndices[i] = i;\n        }\n\n        Arrays.sort(sortedIndices, Comparator.comparingInt(i -> rowSums[i]));\n\n        int[][] sortedMatrix = new int[matrix.length][matrix[0].length];\n        for (int i = 0; i < sortedIndices.length; i++) {\n            sortedMatrix[i] = matrix[sortedIndices[i]];\n        }\n\n        for (int[] row : sortedMatrix) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE dictionary FIXED CHAR(100) ARRAY[100];\nDECLARE word_count FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE max_count FIXED BINARY(20) INIT 0;\nDECLARE most_common_word FIXED CHAR(100);\n\nFOR i = 1 TO 100 DO\n    word_count(i) = 0;\nEND;\n\nFOR i = 1 TO 100 DO\n    FOR j = i + 1 TO 100 DO\n        IF dictionary(i) = dictionary(j) THEN\n            word_count(i) = word_count(i) + 1;\n        END;\n    END;\nEND;\n\nFOR i = 1 TO 100 DO\n    IF word_count(i) > max_count THEN\n        max_count = word_count(i);\n        most_common_word = dictionary(i);\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Collections;\n\npublic class MostCommonWord {\n    public static void main(String[] args) {\n        String[] dictionary = {\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"};\n        Map<String, Integer> wordCount = new HashMap<>();\n\n        for (String word : dictionary) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        String mostCommonWord = Collections.max(wordCount.entrySet(), Map.Entry.comparingByValue()).getKey();\n        System.out.println(mostCommonWord);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE base FIXED BINARY(20);\nDECLARE height FIXED BINARY(20);\nDECLARE length FIXED BINARY(20);\nDECLARE volume FIXED BINARY(20);\n\nvolume = (base * height * length) / 2;\n\nDISPLAY volume;\n</TAL>\n<Java>\npublic class TriangularPrismVolume {\n    public static void main(String[] args) {\n        double base = 5.0;\n        double height = 3.0;\n        double length = 10.0;\n\n        double volume = (base * height * length) / 2;\n        System.out.println(volume);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str FIXED CHAR(100);\nDECLARE i FIXED BINARY(20);\nDECLARE start_pos FIXED BINARY(20) INIT 1;\nDECLARE split_str FIXED CHAR(100) ARRAY[100];\nDECLARE split_index FIXED BINARY(20) INIT 1;\n\nFOR i = 1 TO LENGTH(str) DO\n    IF str(i) >= 'a' AND str(i) <= 'z' THEN\n        split_str(split_index) = SUBSTRING(str, start_pos, i - start_pos);\n        split_index = split_index + 1;\n        start_pos = i + 1;\n    END;\nEND;\n\nsplit_str(split_index) = SUBSTRING(str, start_pos, LENGTH(str) - start_pos + 1);\n</TAL>\n<Java>\npublic class SplitStringAtLowercase {\n    public static void main(String[] args) {\n        String str = \"HelloWorldThisIsJava\";\n        String[] result = str.split(\"(?=[a-z])\");\n\n        for (String s : result) {\n            System.out.println(s);\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str FIXED CHAR(100);\nDECLARE i FIXED BINARY(20);\nDECLARE start_pos FIXED BINARY(20) INIT 1;\nDECLARE result FIXED CHAR(100) ARRAY[100];\nDECLARE result_index FIXED BINARY(20) INIT 1;\n\nFOR i = 1 TO LENGTH(str) DO\n    IF (str(i) >= 'a' AND str(i) <= 'z') AND (i = 1 OR str(i-1) = '_') THEN\n        start_pos = i;\n    END;\n    IF str(i) < 'a' OR str(i) > 'z' THEN\n        IF i > start_pos THEN\n            result(result_index) = SUBSTRING(str, start_pos, i - start_pos);\n            result_index = result_index + 1;\n        END;\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class FindLowercaseSequences {\n    public static void main(String[] args) {\n        String str = \"this_is_a_test_string_example\";\n        Pattern pattern = Pattern.compile(\"[a-z]+(?:_[a-z]+)*\");\n        Matcher matcher = pattern.matcher(str);\n\n        while (matcher.find()) {\n            System.out.println(matcher.group());\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE side FIXED BINARY(20);\nDECLARE perimeter FIXED BINARY(20);\n\nperimeter = 4 * side;\n\nDISPLAY perimeter;\n</TAL>\n<Java>\npublic class SquarePerimeter {\n    public static void main(String[] args) {\n        double side = 5.0;\n        double perimeter = 4 * side;\n        System.out.println(perimeter);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str1 FIXED CHAR(100);\nDECLARE str2 FIXED CHAR(100);\nDECLARE result FIXED CHAR(100);\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE found FIXED BINARY(1);\n\nresult = '';\nFOR i = 1 TO LENGTH(str1) DO\n    found = 0;\n    FOR j = 1 TO LENGTH(str2) DO\n        IF str1(i) = str2(j) THEN\n            found = 1;\n            BREAK;\n        END;\n    END;\n    IF found = 0 THEN\n        result = result + str1(i);\n    END;\nEND;\n</TAL>\n<Java>\npublic class RemoveCharacters {\n    public static void main(String[] args) {\n        String str1 = \"hello world\";\n        String str2 = \"aeiou\";\n        StringBuilder result = new StringBuilder();\n\n        for (char c : str1.toCharArray()) {\n            if (str2.indexOf(c) == -1) {\n                result.append(c);\n            }\n        }\n\n        System.out.println(result.toString());\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE arr FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE duplicate FIXED BINARY(1) INIT 0;\n\nFOR i = 1 TO LENGTH(arr) DO\n    FOR j = i + 1 TO LENGTH(arr) DO\n        IF arr(i) = arr(j) THEN\n            duplicate = 1;\n            BREAK;\n        END;\n    END;\n    IF duplicate = 1 THEN\n        BREAK;\n    END;\nEND;\n\nDISPLAY duplicate;\n</TAL>\n<Java>\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class FindDuplicates {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5, 2};\n        Set<Integer> seen = new HashSet<>();\n        boolean hasDuplicate = false;\n\n        for (int num : arr) {\n            if (!seen.add(num)) {\n                hasDuplicate = true;\n                break;\n            }\n        }\n\n        System.out.println(hasDuplicate);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE num FIXED BINARY(20);\nDECLARE is_woodball FIXED BINARY(1) INIT 0;\n\nIF num MOD 5 = 0 AND num MOD 3 = 0 THEN\n    is_woodball = 1;\nEND;\n\nDISPLAY is_woodball;\n</TAL>\n<Java>\npublic class WoodballCheck {\n    public static void main(String[] args) {\n        int num = 15;\n        boolean isWoodball = (num % 5 == 0) && (num % 3 == 0);\n\n        System.out.println(isWoodball);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE n FIXED BINARY(20);\nDECLARE m FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE multiple FIXED BINARY(20);\n\nFOR i = 1 TO m DO\n    multiple = n * i;\n    DISPLAY multiple;\nEND;\n</TAL>\n<Java>\npublic class MultiplesOfN {\n    public static void main(String[] args) {\n        int n = 5;\n        int m = 10;\n\n        for (int i = 1; i <= m; i++) {\n            System.out.println(n * i);\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE arr FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE duplicate FIXED BINARY(1) INIT 0;\nDECLARE first_duplicate FIXED BINARY(20);\n\nFOR i = 1 TO LENGTH(arr) DO\n    FOR j = i + 1 TO LENGTH(arr) DO\n        IF arr(i) = arr(j) THEN\n            first_duplicate = arr(i);\n            duplicate = 1;\n            BREAK;\n        END;\n    END;\n    IF duplicate = 1 THEN\n        BREAK;\n    END;\nEND;\n\nDISPLAY first_duplicate;\n</TAL>\n<Java>\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class FirstDuplicate {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5, 6, 2, 7};\n        Set<Integer> seen = new HashSet<>();\n        int firstDuplicate = -1;\n\n        for (int num : arr) {\n            if (!seen.add(num)) {\n                firstDuplicate = num;\n                break;\n            }\n        }\n\n        System.out.println(firstDuplicate);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE list_of_lists FIXED BINARY(20) ARRAY[10][10];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE max_sum FIXED BINARY(20) INIT 0;\nDECLARE current_sum FIXED BINARY(20);\n\nFOR i = 1 TO 10 DO\n    current_sum = 0;\n    FOR j = 1 TO 10 DO\n        current_sum = current_sum + list_of_lists(i,j);\n    END;\n    IF current_sum > max_sum THEN\n        max_sum = current_sum;\n    END;\nEND;\n\nDISPLAY max_sum;\n</TAL>\n<Java>\npublic class MaxSumInListOfLists {\n    public static void main(String[] args) {\n        int[][] listOfLists = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n\n        int maxSum = Integer.MIN_VALUE;\n\n        for (int[] list : listOfLists) {\n            int currentSum = 0;\n            for (int num : list) {\n                currentSum += num;\n            }\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n        }\n\n        System.out.println(maxSum);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE binary_number FIXED CHAR(32);\nDECLARE decimal_number FIXED BINARY(20) INIT 0;\nDECLARE i FIXED BINARY(20);\nDECLARE power FIXED BINARY(20) INIT 1;\n\nFOR i = LENGTH(binary_number) TO 1 STEP -1 DO\n    IF binary_number(i) = '1' THEN\n        decimal_number = decimal_number + power;\n    END;\n    power = power * 2;\nEND;\n\nDISPLAY decimal_number;\n</TAL>\n<Java>\npublic class BinaryToDecimal {\n    public static void main(String[] args) {\n        String binary = \"1101\";\n        int decimal = 0;\n        int power = 1;\n\n        for (int i = binary.length() - 1; i >= 0; i--) {\n            if (binary.charAt(i) == '1') {\n                decimal += power;\n            }\n            power *= 2;\n        }\n\n        System.out.println(decimal);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE arr FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE product FIXED BINARY(20) INIT 1;\nDECLARE is_repeated FIXED BINARY(1);\n\nFOR i = 1 TO LENGTH(arr) DO\n    is_repeated = 0;\n    FOR j = 1 TO LENGTH(arr) DO\n        IF i <> j AND arr(i) = arr(j) THEN\n            is_repeated = 1;\n            BREAK;\n        END;\n    END;\n    IF is_repeated = 0 THEN\n        product = product * arr(i);\n    END;\nEND;\n\nDISPLAY product;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ProductOfNonRepeatedElements {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 2, 4, 5};\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        int product = 1;\n\n        for (int num : arr) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        for (int num : arr) {\n            if (frequencyMap.get(num) == 1) {\n                product *= num;\n            }\n        }\n\n        System.out.println(product);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE tuple_list FIXED CHAR(100) ARRAY[10];\nDECLARE k FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE has_all_k_elements FIXED BINARY(1) INIT 1;\n\nFOR i = 1 TO LENGTH(tuple_list) DO\n    IF LENGTH(tuple_list(i)) <> k THEN\n        has_all_k_elements = 0;\n        BREAK;\n    END;\nEND;\n\nDISPLAY has_all_k_elements;\n</TAL>\n<Java>\nimport java.util.List;\nimport java.util.Arrays;\n\npublic class CheckTupleList {\n    public static void main(String[] args) {\n        List<int[]> tupleList = Arrays.asList(\n            new int[]{1, 2, 3},\n            new int[]{4, 5, 6},\n            new int[]{7, 8, 9}\n        );\n        int k = 3;\n        boolean hasAllKElements = true;\n\n        for (int[] tuple : tupleList) {\n            if (tuple.length != k) {\n                hasAllKElements = false;\n                break;\n            }\n        }\n\n        System.out.println(hasAllKElements);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE list_of_strings FIXED CHAR(100) ARRAY[10];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE new_string FIXED CHAR(100);\nDECLARE ch FIXED CHAR(1);\n\nFOR i = 1 TO LENGTH(list_of_strings) DO\n    new_string = '';\n    FOR j = 1 TO LENGTH(list_of_strings(i)) DO\n        ch = list_of_strings(i)(j);\n        IF ch >= '0' AND ch <= '9' THEN\n            CONTINUE;\n        END;\n        new_string = new_string + ch;\n    END;\n    DISPLAY new_string;\nEND;\n</TAL>\n<Java>\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RemoveDigits {\n    public static void main(String[] args) {\n        List<String> listOfStrings = new ArrayList<>();\n        listOfStrings.add(\"abc123\");\n        listOfStrings.add(\"def456\");\n        listOfStrings.add(\"ghi789\");\n\n        List<String> result = new ArrayList<>();\n\n        for (String str : listOfStrings) {\n            String newString = str.replaceAll(\"[0-9]\", \"\");\n            result.add(newString);\n        }\n\n        System.out.println(result);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE n FIXED BINARY(20);\nDECLARE r FIXED BINARY(20);\nDECLARE binomial FIXED BINARY(20) INIT 1;\nDECLARE i FIXED BINARY(20);\nDECLARE factorial_n FIXED BINARY(20) INIT 1;\nDECLARE factorial_r FIXED BINARY(20) INIT 1;\nDECLARE factorial_n_r FIXED BINARY(20) INIT 1;\n\nFOR i = 1 TO n DO\n    factorial_n = factorial_n * i;\nEND;\nFOR i = 1 TO r DO\n    factorial_r = factorial_r * i;\nEND;\nFOR i = 1 TO (n - r) DO\n    factorial_n_r = factorial_n_r * i;\nEND;\n\nbinomial = factorial_n / (factorial_r * factorial_n_r);\nDISPLAY binomial;\n</TAL>\n<Java>\npublic class BinomialCoefficient {\n    public static void main(String[] args) {\n        int n = 5;\n        int r = 2;\n        int binomial = 1;\n\n        int factorialN = 1;\n        int factorialR = 1;\n        int factorialNR = 1;\n\n        for (int i = 1; i <= n; i++) {\n            factorialN *= i;\n        }\n\n        for (int i = 1; i <= r; i++) {\n            factorialR *= i;\n        }\n\n        for (int i = 1; i <= (n - r); i++) {\n            factorialNR *= i;\n        }\n\n        binomial = factorialN / (factorialR * factorialNR);\n\n        System.out.println(binomial);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE arr FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE count FIXED BINARY(20);\nDECLARE odd_element FIXED BINARY(20);\n\nFOR i = 1 TO LENGTH(arr) DO\n    count = 0;\n    FOR j = 1 TO LENGTH(arr) DO\n        IF arr(i) = arr(j) THEN\n            count = count + 1;\n        END;\n    END;\n    IF MOD(count, 2) = 1 THEN\n        odd_element = arr(i);\n        DISPLAY odd_element;\n        BREAK;\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class OddOccurrenceElement {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 2, 1, 3, 3};\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n        for (int num : arr) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() % 2 == 1) {\n                System.out.println(entry.getKey());\n                break;\n            }\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE input_string FIXED CHAR(100);\nDECLARE n FIXED BINARY(20);\nDECLARE count FIXED BINARY(20) INIT 0;\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\n\nFOR i = 1 TO LENGTH(input_string) DO\n    FOR j = i TO LENGTH(input_string) DO\n        IF input_string(i) = input_string(j) THEN\n            count = count + 1;\n        END;\n    END;\nEND;\n\nDISPLAY count;\n</TAL>\n<Java>\npublic class SubstringsWithSameStartEnd {\n    public static void main(String[] args) {\n        String inputString = \"ababa\";\n        int count = 0;\n\n        for (int i = 0; i < inputString.length(); i++) {\n            for (int j = i; j < inputString.length(); j++) {\n                if (inputString.charAt(i) == inputString.charAt(j)) {\n                    count++;\n                }\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE list FIXED BINARY(20) ARRAY[100];\nDECLARE k FIXED BINARY(20);\nDECLARE frequency_map FIXED BINARY(20) ARRAY[100];\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE max_elements FIXED BINARY(20) ARRAY[100];\nDECLARE max_count FIXED BINARY(20);\n\nFOR i = 1 TO LENGTH(list) DO\n    frequency_map(list(i)) = frequency_map(list(i)) + 1;\nEND;\n\nFOR i = 1 TO LENGTH(frequency_map) DO\n    IF frequency_map(i) > max_count THEN\n        max_count = frequency_map(i);\n        max_elements = i;\n    END;\nEND;\n\nDISPLAY max_elements;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class TopKFrequentNumbers {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5);\n        int k = 3;\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : list) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>(\n            (a, b) -> a.getValue() - b.getValue()\n        );\n\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            heap.offer(entry);\n            if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n\n        while (!heap.isEmpty()) {\n            System.out.println(heap.poll().getKey());\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE num FIXED BINARY(20);\nDECLARE divisor FIXED BINARY(20) INIT 2;\nDECLARE largest_prime FIXED BINARY(20) INIT 1;\nDECLARE temp FIXED BINARY(20);\n\nWHILE num > 1 DO\n    IF MOD(num, divisor) = 0 THEN\n        largest_prime = divisor;\n        num = num / divisor;\n    ELSE\n        divisor = divisor + 1;\n    END;\nEND;\n\nDISPLAY largest_prime;\n</TAL>\n<Java>\npublic class LargestPrimeFactor {\n    public static void main(String[] args) {\n        int num = 56;\n        int largestPrime = 1;\n\n        for (int divisor = 2; divisor <= num; divisor++) {\n            while (num % divisor == 0) {\n                largestPrime = divisor;\n                num /= divisor;\n            }\n        }\n\n        System.out.println(largestPrime);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE num FIXED BINARY(20);\nDECLARE result FIXED CHAR(100) INIT '';\nDECLARE remainder FIXED BINARY(20);\n\nWHILE num > 0 DO\n    remainder = MOD(num, 2);\n    result = CHAR(remainder) || result;\n    num = num / 2;\nEND;\n\nDISPLAY result;\n</TAL>\n<Java>\npublic class DecimalToBinary {\n    public static void main(String[] args) {\n        int num = 29;\n        StringBuilder result = new StringBuilder();\n\n        while (num > 0) {\n            result.insert(0, num % 2);\n            num /= 2;\n        }\n\n        System.out.println(result.toString());\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE arr FIXED BINARY(20) ARRAY[100];\nDECLARE n FIXED BINARY(20);\nDECLARE low FIXED BINARY(20) INIT 1;\nDECLARE high FIXED BINARY(20) INIT LENGTH(arr);\nDECLARE mid FIXED BINARY(20);\nDECLARE missing_number FIXED BINARY(20);\n\nWHILE low <= high DO\n    mid = (low + high) / 2;\n    IF arr(mid) != mid THEN\n        missing_number = mid;\n        high = mid - 1;\n    ELSE\n        low = mid + 1;\n    END;\nEND;\n\nDISPLAY missing_number;\n</TAL>\n<Java>\npublic class MissingNumber {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 6};\n        int low = 0;\n        int high = arr.length - 1;\n        int missingNumber = -1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] != mid + 1) {\n                missingNumber = mid + 1;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        System.out.println(missingNumber);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE n FIXED BINARY(20);\nDECLARE rectangular_number FIXED BINARY(20) INIT 0;\nDECLARE i FIXED BINARY(20);\n\nFOR i = 1 TO n DO\n    rectangular_number = rectangular_number + i;\nEND;\n\nDISPLAY rectangular_number;\n</TAL>\n<Java>\npublic class NthRectangularNumber {\n    public static void main(String[] args) {\n        int n = 5;\n        int rectangularNumber = 0;\n\n        for (int i = 1; i <= n; i++) {\n            rectangularNumber += i;\n        }\n\n        System.out.println(rectangularNumber);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE numerator FIXED BINARY(20);\nDECLARE denominator FIXED BINARY(20);\nDECLARE n FIXED BINARY(20);\nDECLARE digit FIXED BINARY(20);\nDECLARE remainder FIXED BINARY(20) INIT 0;\nDECLARE count FIXED BINARY(20) INIT 0;\n\nWHILE count < n DO\n    remainder = remainder * 10;\n    digit = MOD(remainder, denominator);\n    remainder = remainder + numerator;\n    count = count + 1;\nEND;\n\nDISPLAY digit;\n</TAL>\n<Java>\npublic class NthDigitInFraction {\n    public static void main(String[] args) {\n        int numerator = 1;\n        int denominator = 7;\n        int n = 3;\n        int remainder = 0;\n        int count = 0;\n        int digit = 0;\n\n        while (count < n) {\n            remainder = remainder * 10;\n            digit = remainder / denominator;\n            remainder = remainder % denominator;\n            count++;\n        }\n\n        System.out.println(digit);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE mixed_list ARRAY[10] OF STRING;\nDECLARE sorted_list ARRAY[10] OF STRING;\nDECLARE temp STRING;\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\n\n! Filling the mixed list with data\nASSIGN mixed_list[1] = 'apple';\nASSIGN mixed_list[2] = '3';\nASSIGN mixed_list[3] = 'banana';\nASSIGN mixed_list[4] = '2';\nASSIGN mixed_list[5] = '1';\nASSIGN mixed_list[6] = 'cherry';\nASSIGN mixed_list[7] = '5';\nASSIGN mixed_list[8] = '4';\nASSIGN mixed_list[9] = 'orange';\n\n! Sorting the list\nFOR i = 1 TO 9 DO\n    FOR j = i + 1 TO 9 DO\n        IF mixed_list[i] > mixed_list[j] THEN\n            temp = mixed_list[i];\n            mixed_list[i] = mixed_list[j];\n            mixed_list[j] = temp;\n        END;\n    END;\nEND;\n\nDISPLAY mixed_list;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class MixedListSort {\n    public static void main(String[] args) {\n        String[] mixedList = {\"apple\", \"3\", \"banana\", \"2\", \"1\", \"cherry\", \"5\", \"4\", \"orange\"};\n\n        Arrays.sort(mixedList, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                if (isNumeric(o1) && isNumeric(o2)) {\n                    return Integer.compare(Integer.parseInt(o1), Integer.parseInt(o2));\n                } else {\n                    return o1.compareTo(o2);\n                }\n            }\n        });\n\n        System.out.println(Arrays.toString(mixedList));\n    }\n\n    public static boolean isNumeric(String str) {\n        try {\n            Integer.parseInt(str);\n            return true;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE num_list ARRAY[10] OF FIXED BINARY(20);\nDECLARE even_num FIXED BINARY(20);\nDECLARE odd_num FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE result FIXED BINARY(20);\n\n! Initialize the list\nASSIGN num_list[1] = 10;\nASSIGN num_list[2] = 15;\nASSIGN num_list[3] = 20;\nASSIGN num_list[4] = 25;\nASSIGN num_list[5] = 30;\nASSIGN num_list[6] = 35;\nASSIGN num_list[7] = 40;\nASSIGN num_list[8] = 45;\nASSIGN num_list[9] = 50;\n\n! Find first even and odd numbers\nFOR i = 1 TO 9 DO\n    IF MOD(num_list[i], 2) = 0 THEN\n        even_num = num_list[i];\n        BREAK;\n    END;\nEND;\n\nFOR i = 1 TO 9 DO\n    IF MOD(num_list[i], 2) <> 0 THEN\n        odd_num = num_list[i];\n        BREAK;\n    END;\nEND;\n\n! Perform division\nIF odd_num <> 0 THEN\n    result = even_num / odd_num;\n    DISPLAY result;\nELSE\n    DISPLAY 'Division by zero error';\nEND;\n</TAL>\n<Java>\npublic class DivisionEvenOdd {\n    public static void main(String[] args) {\n        int[] numList = {10, 15, 20, 25, 30, 35, 40, 45, 50};\n        int evenNum = 0;\n        int oddNum = 0;\n\n        for (int num : numList) {\n            if (num % 2 == 0) {\n                evenNum = num;\n                break;\n            }\n        }\n\n        for (int num : numList) {\n            if (num % 2 != 0) {\n                oddNum = num;\n                break;\n            }\n        }\n\n        if (oddNum != 0) {\n            double result = (double) evenNum / oddNum;\n            System.out.println(result);\n        } else {\n            System.out.println(\"Division by zero error\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE str STRING;\nDECLARE freq_table ARRAY[26] OF FIXED BINARY(20);\nDECLARE max_count FIXED BINARY(20);\nDECLARE total_chars FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\n\n! Input string\nASSIGN str = 'aabbcc';\n\n! Initialize frequency table\nFOR i = 1 TO 26 DO\n    freq_table[i] = 0;\nEND;\n\n! Count frequency of each character\nFOR i = 1 TO LENGTH(str) DO\n    freq_table[ASC(SUBSTRING(str, i, 1)) - ASC('a') + 1] = freq_table[ASC(SUBSTRING(str, i, 1)) - ASC('a') + 1] + 1;\nEND;\n\n! Find the character with the maximum frequency\nmax_count = 0;\nFOR i = 1 TO 26 DO\n    IF freq_table[i] > max_count THEN\n        max_count = freq_table[i];\n    END;\nEND;\n\n! Check if rearranging is possible\ntotal_chars = LENGTH(str);\nIF max_count <= (total_chars + 1) / 2 THEN\n    DISPLAY 'Rearranging is possible';\nELSE\n    DISPLAY 'Rearranging is not possible';\nEND;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RearrangingString {\n    public static void main(String[] args) {\n        String str = \"aabbcc\";\n        Map<Character, Integer> freqMap = new HashMap<>();\n\n        for (char ch : str.toCharArray()) {\n            freqMap.put(ch, freqMap.getOrDefault(ch, 0) + 1);\n        }\n\n        int maxCount = 0;\n        int totalChars = str.length();\n        for (int count : freqMap.values()) {\n            maxCount = Math.max(maxCount, count);\n        }\n\n        if (maxCount <= (totalChars + 1) / 2) {\n            System.out.println(\"Rearranging is possible\");\n        } else {\n            System.out.println(\"Rearranging is not possible\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE list_of_lists ARRAY[100] OF ARRAY[100] OF FIXED BINARY(20);\nDECLARE freq_table ARRAY[100] OF FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE element FIXED BINARY(20);\n\n! Input list of lists\nASSIGN list_of_lists[1] = [1, 2, 2, 3];\nASSIGN list_of_lists[2] = [3, 3, 4];\nASSIGN list_of_lists[3] = [5, 5, 5];\n\n! Initialize frequency table\nFOR i = 1 TO 100 DO\n    freq_table[i] = 0;\nEND;\n\n! Count frequency of elements\nFOR i = 1 TO 3 DO\n    FOR j = 1 TO LENGTH(list_of_lists[i]) DO\n        element = list_of_lists[i][j];\n        freq_table[element] = freq_table[element] + 1;\n    END;\nEND;\n\n! Display frequency count\nFOR i = 1 TO 100 DO\n    IF freq_table[i] > 0 THEN\n        DISPLAY 'Element: ' || i || ', Frequency: ' || freq_table[i];\n    END;\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class FrequencyCounter {\n    public static void main(String[] args) {\n        List<List<Integer>> listOfLists = new ArrayList<>();\n        List<Integer> list1 = List.of(1, 2, 2, 3);\n        List<Integer> list2 = List.of(3, 3, 4);\n        List<Integer> list3 = List.of(5, 5, 5);\n        listOfLists.add(list1);\n        listOfLists.add(list2);\n        listOfLists.add(list3);\n\n        Map<Integer, Integer> freqMap = new HashMap<>();\n\n        for (List<Integer> list : listOfLists) {\n            for (Integer element : list) {\n                freqMap.put(element, freqMap.getOrDefault(element, 0) + 1);\n            }\n        }\n\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            System.out.println(\"Element: \" + entry.getKey() + \", Frequency: \" + entry.getValue());\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE numbers ARRAY[10] OF FIXED BINARY(20);\nDECLARE filtered_numbers ARRAY[10] OF FIXED BINARY(20);\nDECLARE i FIXED BINARY(20);\nDECLARE index FIXED BINARY(20) INITIAL(1);\n\n! Input array of numbers\nASSIGN numbers[1] = 1;\nASSIGN numbers[2] = 2;\nASSIGN numbers[3] = 3;\nASSIGN numbers[4] = 4;\nASSIGN numbers[5] = 5;\nASSIGN numbers[6] = 6;\nASSIGN numbers[7] = 7;\nASSIGN numbers[8] = 8;\nASSIGN numbers[9] = 9;\nASSIGN numbers[10] = 10;\n\n! Filter even numbers\nFOR i = 1 TO 10 DO\n    IF numbers[i] MOD 2 = 0 THEN\n        filtered_numbers[index] = numbers[i];\n        index = index + 1;\n    END;\nEND;\n\n! Display filtered even numbers\nFOR i = 1 TO index-1 DO\n    DISPLAY 'Even Number: ' || filtered_numbers[i];\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class EvenNumberFilter {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        Predicate<Integer> isEven = n -> n % 2 == 0;\n\n        List<Integer> evenNumbers = new ArrayList<>();\n        for (Integer number : numbers) {\n            if (isEven.test(number)) {\n                evenNumbers.add(number);\n            }\n        }\n\n        System.out.println(\"Filtered Even Numbers: \" + evenNumbers);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE numbers ARRAY[10] OF FIXED BINARY(20);\nDECLARE sum_repeated FIXED BINARY(20) INITIAL(0);\nDECLARE i FIXED BINARY(20);\nDECLARE j FIXED BINARY(20);\nDECLARE count FIXED BINARY(20);\n\n! Input array of numbers\nASSIGN numbers[1] = 1;\nASSIGN numbers[2] = 2;\nASSIGN numbers[3] = 3;\nASSIGN numbers[4] = 2;\nASSIGN numbers[5] = 4;\nASSIGN numbers[6] = 3;\nASSIGN numbers[7] = 5;\nASSIGN numbers[8] = 1;\nASSIGN numbers[9] = 6;\nASSIGN numbers[10] = 7;\n\n! Find and sum repeated elements\nFOR i = 1 TO 9 DO\n    count = 0;\n    FOR j = i+1 TO 10 DO\n        IF numbers[i] = numbers[j] THEN\n            count = count + 1;\n        END;\n    END;\n    IF count > 0 THEN\n        sum_repeated = sum_repeated + numbers[i];\n    END;\nEND;\n\n! Display the sum of repeated elements\nDISPLAY 'Sum of repeated elements: ' || sum_repeated;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RepeatedElementsSum {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 2, 4, 3, 5, 1, 6, 7};\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n        for (int num : numbers) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        int sumRepeated = 0;\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() > 1) {\n                sumRepeated += entry.getKey();\n            }\n        }\n\n        System.out.println(\"Sum of repeated elements: \" + sumRepeated);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE input_string FIXED STRING(100);\nDECLARE regex_pattern FIXED STRING(20) INITIAL '[a-z]+(_[a-z]+)*';\nDECLARE matches FIXED STRING(100);\n\n! Input string\nASSIGN input_string = 'hello_world_this_is_tal_example';\n\n! Regex matching logic (not directly supported in TAL, so this is a placeholder for actual logic)\n! Assuming TAL has custom handling for regex (which would depend on your environment's capabilities)\n\n! Display matches (assuming we can handle regex and find sequences)\nDISPLAY 'Sequences of lowercase letters joined with underscores: ' || matches;\n</TAL>\n<Java>\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexExample {\n    public static void main(String[] args) {\n        String input = \"hello_world_this_is_tal_example\";\n        Pattern pattern = Pattern.compile(\"[a-z]+(_[a-z]+)*\");\n        Matcher matcher = pattern.matcher(input);\n\n        System.out.println(\"Sequences of lowercase letters joined with underscores:\");\n        while (matcher.find()) {\n            System.out.println(matcher.group());\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE input_string FIXED STRING(100);\nDECLARE word_to_match FIXED STRING(20);\nDECLARE position FIXED BIN(15);\n\n! Input string and word to match\nASSIGN input_string = 'hello_world_example';\nASSIGN word_to_match = 'hello';\n\n! Find if the word matches at the beginning of the string\nASSIGN position = FUNCTION 'POS' (input_string, word_to_match);\n\n! If position is 1, the word is at the beginning\nIF position = 1 THEN\n    DISPLAY 'The word matches at the beginning of the string.';\nELSE\n    DISPLAY 'The word does not match at the beginning of the string.';\nEND;\n</TAL>\n<Java>\npublic class MatchWordAtStart {\n    public static void main(String[] args) {\n        String input = \"hello_world_example\";\n        String wordToMatch = \"hello\";\n\n        if (input.startsWith(wordToMatch)) {\n            System.out.println(\"The word matches at the beginning of the string.\");\n        } else {\n            System.out.println(\"The word does not match at the beginning of the string.\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE numbers ARRAY OF FIXED BIN(15) DIM(5);\nDECLARE gcd_result FIXED BIN(15);\nDECLARE i FIXED BIN(15);\nDECLARE current_gcd FIXED BIN(15);\nDECLARE temp FIXED BIN(15);\n\n! Input array\nASSIGN numbers[1] = 24;\nASSIGN numbers[2] = 36;\nASSIGN numbers[3] = 60;\nASSIGN numbers[4] = 48;\nASSIGN numbers[5] = 72;\n\n! Initialize gcd_result with the first element\nASSIGN gcd_result = numbers[1];\n\n! Loop through the array to calculate gcd of the elements\nFOR i = 2 TO 5\n    ! Find gcd of current gcd_result and the next element\n    ASSIGN current_gcd = gcd_result;\n    ASSIGN temp = numbers[i];\n    WHILE temp <> 0 DO\n        ASSIGN current_gcd = MOD(current_gcd, temp);\n        ASSIGN temp = current_gcd;\n    END;\n    ASSIGN gcd_result = current_gcd;\nEND;\n\nDISPLAY 'The GCD of the array is: ' || gcd_result;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GCDOfArray {\n    public static void main(String[] args) {\n        int[] numbers = {24, 36, 60, 48, 72};\n\n        int gcdResult = numbers[0];\n        for (int i = 1; i < numbers.length; i++) {\n            gcdResult = findGCD(gcdResult, numbers[i]);\n        }\n\n        System.out.println(\"The GCD of the array is: \" + gcdResult);\n    }\n\n    public static int findGCD(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE STRING INPUT_STRING;\nDECLARE STRING CHAR_COUNTS[256];\nDECLARE INTEGER I, MAX_COUNT, LENGTH;\nDECLARE STRING RESULT;\n\nINPUT_STRING = 'aabbcc'; /* Example input string */\nLENGTH = LENGTH OF INPUT_STRING;\nFOR I = 1 TO LENGTH DO\n    CHAR_COUNTS[ASCII OF INPUT_STRING[I]] = CHAR_COUNTS[ASCII OF INPUT_STRING[I]] + 1;\nEND FOR;\n\nMAX_COUNT = 0;\nFOR I = 0 TO 255 DO\n    IF CHAR_COUNTS[I] > MAX_COUNT THEN\n        MAX_COUNT = CHAR_COUNTS[I];\n    END IF;\nEND FOR;\n\nIF MAX_COUNT > (LENGTH + 1) / 2 THEN\n    RESULT = 'No'; /* Cannot rearrange */\nELSE\n    RESULT = 'Yes'; /* Can rearrange */\nEND IF;\nRETURN RESULT;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RearrangementChecker {\n    public static String canRearrange(String input) {\n        Map<Character, Integer> charCounts = new HashMap<>();\n        int length = input.length();\n\n        for (int i = 0; i < length; i++) {\n            char c = input.charAt(i);\n            charCounts.put(c, charCounts.getOrDefault(c, 0) + 1);\n        }\n\n        int maxCount = 0;\n        for (int count : charCounts.values()) {\n            maxCount = Math.max(maxCount, count);\n        }\n\n        if (maxCount > (length + 1) / 2) {\n            return \"No\"; /* Cannot rearrange */\n        } else {\n            return \"Yes\"; /* Can rearrange */\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE LIST OF LIST OF INTEGER INPUT_LIST;\nDECLARE INTEGER ELEMENT, COUNT;\nDECLARE MAP OF INTEGER TO INTEGER FREQUENCY_MAP;\nDECLARE INTEGER I, J;\n\nINPUT_LIST = {{1, 2, 3}, {3, 4, 5}, {1, 5, 6}}; /* Example input list of lists */\nFREQUENCY_MAP = NEW MAP OF INTEGER TO INTEGER;\n\nFOR I = 1 TO LENGTH OF INPUT_LIST DO\n    FOR J = 1 TO LENGTH OF INPUT_LIST[I] DO\n        ELEMENT = INPUT_LIST[I][J];\n        IF FREQUENCY_MAP CONTAINS KEY ELEMENT THEN\n            FREQUENCY_MAP[ELEMENT] = FREQUENCY_MAP[ELEMENT] + 1;\n        ELSE\n            FREQUENCY_MAP[ELEMENT] = 1;\n        END IF;\n    END FOR;\nEND FOR;\n\nRETURN FREQUENCY_MAP;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class FrequencyCounter {\n    public static Map<Integer, Integer> countFrequency(int[][] input) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n        for (int i = 0; i < input.length; i++) {\n            for (int j = 0; j < input[i].length; j++) {\n                int element = input[i][j];\n                frequencyMap.put(element, frequencyMap.getOrDefault(element, 0) + 1);\n            }\n        }\n\n        return frequencyMap;\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER A = 5, B = 7; /* Example numbers for factorials */\nDECLARE INTEGER FACT_A, FACT_B, DIV_RESULT, LAST_DIGIT;\n\n/* Function to calculate factorial */\nDECLARE FUNCTION FACTORIAL(N) RETURNS INTEGER;\nFACTORIAL(N) =\n    DECLARE INTEGER RESULT = 1;\n    FOR INTEGER I = 1 TO N DO\n        RESULT = RESULT * I;\n    END FOR;\n    RETURN RESULT;\nEND FUNCTION;\n\n/* Find factorial of A and B */\nFACT_A = FACTORIAL(A);\nFACT_B = FACTORIAL(B);\n\n/* Divide factorial of B by factorial of A */\nDIV_RESULT = FACT_B / FACT_A;\n\n/* Find the last digit of the result */\nLAST_DIGIT = DIV_RESULT MOD 10;\n\nRETURN LAST_DIGIT;\n</TAL>\n<Java>\npublic class FactorialDivision {\n    public static int factorial(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    public static int lastDigitOfFactorialDivision(int a, int b) {\n        int factA = factorial(a);\n        int factB = factorial(b);\n        int divResult = factB / factA;\n        return divResult % 10;\n    }\n\n    public static void main(String[] args) {\n        int a = 5, b = 7;\n        System.out.println(\"Last digit: \" + lastDigitOfFactorialDivision(a, b));\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM = 5; /* Example input */\nDECLARE INTEGER MASK = 0x55555555; /* Mask to set odd bits */\nDECLARE INTEGER RESULT;\n\n/* Set all odd bits of the given number */\nRESULT = NUM OR MASK;\n\nRETURN RESULT;\n</TAL>\n<Java>\npublic class SetOddBits {\n    public static int setOddBits(int num) {\n        int mask = 0x55555555; // Mask to set odd bits\n        return num | mask;\n    }\n\n    public static void main(String[] args) {\n        int num = 5; // Example input\n        System.out.println(\"Result: \" + setOddBits(num));\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY OF ARRAY OF INTEGER MATRIX = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; /* Example 2D array */\nDECLARE ARRAY OF INTEGER RESULT;\nDECLARE INTEGER ROW, COL;\n\n/* Initialize an empty result array */\nDECLARE INTEGER NROWS = 3; /* Number of rows in the matrix */\nDECLARE INTEGER NCOLS = 3; /* Number of columns in the matrix */\nRESULT = [];\n\n/* Extract the first element from each row */\nFOR ROW = 1 TO NROWS DO\n    RESULT[ROW] = MATRIX[ROW][1]; /* Extract first element of each row */\nEND FOR;\n\nRETURN RESULT;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class ExtractElements {\n    public static List<Integer> extractFirstElement(List<List<Integer>> matrix) {\n        List<Integer> result = new ArrayList<>();\n        for (List<Integer> row : matrix) {\n            result.add(row.get(0)); // Extract the first element of each row\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> matrix = Arrays.asList(\n            Arrays.asList(1, 2, 3),\n            Arrays.asList(4, 5, 6),\n            Arrays.asList(7, 8, 9)\n        );\n        System.out.println(extractFirstElement(matrix));\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER SIDE1 = 5; /* Example side length 1 */\nDECLARE INTEGER SIDE2 = 5; /* Example side length 2 */\nDECLARE INTEGER SIDE3 = 5; /* Example side length 3 */\nDECLARE STRING RESULT;\n\nIF SIDE1 = SIDE2 AND SIDE2 = SIDE3 THEN\n    RESULT = 'Equilateral';\nELSE\n    RESULT = 'Not Equilateral';\nEND IF;\n\nDISPLAY RESULT;\n</TAL>\n<Java>\npublic class TriangleCheck {\n    public static void main(String[] args) {\n        int side1 = 5; // Example side length 1\n        int side2 = 5; // Example side length 2\n        int side3 = 5; // Example side length 3\n\n        if (side1 == side2 && side2 == side3) {\n            System.out.println(\"Equilateral\");\n        } else {\n            System.out.println(\"Not Equilateral\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE REAL BASE = 10.0; /* Example base length */\nDECLARE REAL HEIGHT = 5.0; /* Example height */\nDECLARE REAL AREA;\n\nAREA = BASE * HEIGHT;\nDISPLAY 'Area of the parallelogram: ' || AREA;\n</TAL>\n<Java>\npublic class ParallelogramArea {\n    public static void main(String[] args) {\n        double base = 10.0; // Example base length\n        double height = 5.0; // Example height\n\n        double area = base * height;\n        System.out.println(\"Area of the parallelogram: \" + area);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE STRING INPUT_STRING = 'hello'; /* Example string */\nDECLARE CHAR FIRST_CHAR, LAST_CHAR;\nDECLARE BOOLEAN ARE_EQUAL;\n\nFIRST_CHAR = INPUT_STRING[1]; /* First character of the string */\nLAST_CHAR = INPUT_STRING[INPUT_STRING.LENGTH]; /* Last character of the string */\n\nARE_EQUAL = (FIRST_CHAR = LAST_CHAR);\nDISPLAY 'Are the first and last characters equal? ' || ARE_EQUAL;\n</TAL>\n<Java>\npublic class CheckFirstLastChar {\n    public static void main(String[] args) {\n        String inputString = \"hello\"; // Example string\n\n        char firstChar = inputString.charAt(0); // First character of the string\n        char lastChar = inputString.charAt(inputString.length() - 1); // Last character of the string\n\n        boolean areEqual = (firstChar == lastChar);\n        System.out.println(\"Are the first and last characters equal? \" + areEqual);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER ARRAY INPUT_ARRAY = {4, 2, 2, 8, 3, 3, 1}; /* Example input */\nDECLARE INTEGER COUNT_ARRAY[10] = {0}; /* Count array for digits 0-9 */\nDECLARE INTEGER I, MAX_VALUE, INDEX;\n\nMAX_VALUE = 9; /* The maximum value in the input array (for simplicity, assume values between 0 and 9) */\n\n/* Count the frequency of each element */\nFOR I = 1 TO INPUT_ARRAY.LENGTH DO\n    COUNT_ARRAY[INPUT_ARRAY[I]] = COUNT_ARRAY[INPUT_ARRAY[I]] + 1;\nEND FOR;\n\n/* Reconstruct the sorted array */\nINDEX = 1;\nFOR I = 0 TO MAX_VALUE DO\n    WHILE COUNT_ARRAY[I] > 0 DO\n        INPUT_ARRAY[INDEX] = I;\n        COUNT_ARRAY[I] = COUNT_ARRAY[I] - 1;\n        INDEX = INDEX + 1;\n    END WHILE;\nEND FOR;\n\nDISPLAY 'Sorted Array: ' || INPUT_ARRAY;\n</TAL>\n<Java>\npublic class CountingSort {\n    public static void main(String[] args) {\n        int[] inputArray = {4, 2, 2, 8, 3, 3, 1}; // Example input\n        int[] countArray = new int[10]; // Count array for digits 0-9\n\n        // Count the frequency of each element\n        for (int i = 0; i < inputArray.length; i++) {\n            countArray[inputArray[i]]++; // Increment the count for the element\n        }\n\n        // Reconstruct the sorted array\n        int index = 0;\n        for (int i = 0; i <= 9; i++) { // Assuming values are between 0 and 9\n            while (countArray[i] > 0) {\n                inputArray[index] = i;\n                countArray[i]--;\n                index++;\n            }\n        }\n\n        // Print the sorted array\n        System.out.print(\"Sorted Array: \");\n        for (int num : inputArray) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER FIRST_TERM = 2; /* First term of the geometric series */\nDECLARE INTEGER COMMON_RATIO = 3; /* Common ratio of the geometric series */\nDECLARE INTEGER NTH_TERM, T;\n\nT = 5; /* For example, finding the 5th term */\n\n/* Formula for t-nth term of geometric series: T_n = a * r^(n-1) */\nNth_TERM = FIRST_TERM * (COMMON_RATIO ** (T - 1));\nDISPLAY 'The ' || T || 'th term of the geometric series is: ' || NTH_TERM;\n</TAL>\n<Java>\npublic class GeometricSeries {\n    public static void main(String[] args) {\n        int firstTerm = 2; // First term of the geometric series\n        int commonRatio = 3; // Common ratio of the geometric series\n        int nthTerm;\n        int t = 5; // For example, finding the 5th term\n\n        // Formula for t-nth term of geometric series: T_n = a * r^(n-1)\n        nthTerm = firstTerm * (int)Math.pow(commonRatio, t - 1);\n\n        // Print the nth term of the geometric series\n        System.out.println(\"The \" + t + \"th term of the geometric series is: \" + nthTerm);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM, REVERSE_NUM, RESULT;\nDECLARE STRING STR_NUM;\n\nNUM = 21; /* For example, check if 21 satisfies the condition */\n\n/* Convert number to string to reverse it */\nSTR_NUM = STRING(NUM);\nREVERSE_NUM = 0;\n\n/* Reverse the number */\nFOR I = LENGTH(STR_NUM) TO 1 STEP -1 DO\n    REVERSE_NUM = REVERSE_NUM * 10 + SUBSTRING(STR_NUM, I, I);\nEND;\n\n/* Check if the condition is satisfied: NUM == 2 * REVERSE_NUM - 1 */\nIF NUM == (2 * REVERSE_NUM - 1) THEN\n    DISPLAY 'Yes, the number satisfies the condition.';\nELSE\n    DISPLAY 'No, the number does not satisfy the condition.';\nEND;\n</TAL>\n<Java>\npublic class NumberCheck {\n    public static void main(String[] args) {\n        int num = 21; // For example, check if 21 satisfies the condition\n        int reverseNum = 0;\n        int originalNum = num;\n\n        // Reverse the number\n        while (num != 0) {\n            reverseNum = reverseNum * 10 + num % 10;\n            num /= 10;\n        }\n\n        // Check if the condition is satisfied: NUM == 2 * REVERSE_NUM - 1\n        if (originalNum == 2 * reverseNum - 1) {\n            System.out.println(\"Yes, the number satisfies the condition.\");\n        } else {\n            System.out.println(\"No, the number does not satisfy the condition.\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER ARRAY DIGITS[10];\nDECLARE INTEGER N, I, MAX_DIGIT;\nDECLARE STRING STR_DIGITS;\nDECLARE INTEGER SORTED_DIGITS[10];\n\n/* Example digits */\nDIGITS = [9, 1, 4, 6, 2];\nN = LENGTH(DIGITS);\n\n/* Convert digits to a string for sorting */\nFOR I = 1 TO N DO\n    STR_DIGITS = STRING(DIGITS[I]);\n    SORTED_DIGITS[I] = DIGITS[I];\nEND;\n\n/* Sort digits in descending order (sorting logic can be adapted depending on sorting ability) */\nFOR I = 1 TO N-1 DO\n    FOR J = I+1 TO N DO\n        IF SORTED_DIGITS[I] < SORTED_DIGITS[J] THEN\n            /* Swap */\n            MAX_DIGIT = SORTED_DIGITS[I];\n            SORTED_DIGITS[I] = SORTED_DIGITS[J];\n            SORTED_DIGITS[J] = MAX_DIGIT;\n        END;\n    END;\nEND;\n\n/* Output the largest number formed */\nFOR I = 1 TO N DO\n    DISPLAY STRING(SORTED_DIGITS[I]);\nEND;\n</TAL>\n<Java>\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class LargestNumber {\n    public static void main(String[] args) {\n        Integer[] digits = {9, 1, 4, 6, 2};\n        Arrays.sort(digits, Collections.reverseOrder());\n\n        StringBuilder largestNumber = new StringBuilder();\n        for (int digit : digits) {\n            largestNumber.append(digit);\n        }\n\n        System.out.println(\"Largest number: \" + largestNumber.toString());\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM1, NUM2;\nDECLARE STRING RESULT;\n\nNUM1 = -5;  /* Example input */\nNUM2 = 7;   /* Example input */\n\nIF (NUM1 < 0 AND NUM2 >= 0) OR (NUM1 >= 0 AND NUM2 < 0) THEN\n    RESULT = 'Opposite Signs';\nELSE\n    RESULT = 'Same Sign';\nEND;\n\nDISPLAY RESULT;\n</TAL>\n<Java>\npublic class OppositeSign {\n    public static void main(String[] args) {\n        int num1 = -5;  // Example input\n        int num2 = 7;   // Example input\n\n        if ((num1 < 0 && num2 >= 0) || (num1 >= 0 && num2 < 0)) {\n            System.out.println(\"Opposite Signs\");\n        } else {\n            System.out.println(\"Same Sign\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER N, OCTAGONAL_NUMBER;\n\nN = 5;  /* Example input for nth octagonal number */\n\nOCTAGONAL_NUMBER = N * (3 * N - 2);\n\nDISPLAY OCTAGONAL_NUMBER;\n</TAL>\n<Java>\npublic class OctagonalNumber {\n    public static void main(String[] args) {\n        int n = 5;  // Example input for nth octagonal number\n\n        int octagonalNumber = n * (3 * n - 2);\n\n        System.out.println(\"The \" + n + \"th octagonal number is: \" + octagonalNumber);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY INTEGER ARR[5] = [1, 2, 3, 4, 5];  /* Example array */\nDECLARE INTEGER MAX_LENGTH, CURRENT_LENGTH, I;\nMAX_LENGTH = 1;\nCURRENT_LENGTH = 1;\n\nFOR I = 2 TO 5 DO\n    IF ARR[I] - ARR[I-1] = 1 THEN\n        CURRENT_LENGTH = CURRENT_LENGTH + 1;\n    ELSE\n        IF CURRENT_LENGTH > MAX_LENGTH THEN\n            MAX_LENGTH = CURRENT_LENGTH;\n        END IF;\n        CURRENT_LENGTH = 1;\n    END IF;\nEND FOR;\n\nIF CURRENT_LENGTH > MAX_LENGTH THEN\n    MAX_LENGTH = CURRENT_LENGTH;\nEND IF;\n\nDISPLAY MAX_LENGTH;\n</TAL>\n<Java>\npublic class MaxSubsequenceLength {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};  // Example array\n        int maxLength = 1, currentLength = 1;\n\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] - arr[i - 1] == 1) {\n                currentLength++;\n            } else {\n                if (currentLength > maxLength) {\n                    maxLength = currentLength;\n                }\n                currentLength = 1;\n            }\n        }\n\n        if (currentLength > maxLength) {\n            maxLength = currentLength;\n        }\n\n        System.out.println(\"Maximum subsequence length: \" + maxLength);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY INTEGER digits[5] = [1, 2, 3, 4, 5];  /* Example array */\nDECLARE INTEGER count, length, sum, i, j;\ncount = 0;\n\nFOR i = 1 TO 5 DO\n    FOR j = i TO 5 DO\n        sum = 0;\n        length = j - i + 1;\n        FOR k = i TO j DO\n            sum = sum + digits[k];\n        END FOR;\n        IF sum = length THEN\n            count = count + 1;\n        END IF;\n    END FOR;\nEND FOR;\nDISPLAY count;\n</TAL>\n<Java>\npublic class SubstringSum {\n    public static void main(String[] args) {\n        int[] digits = {1, 2, 3, 4, 5};  // Example array\n        int count = 0;\n\n        for (int i = 0; i < digits.length; i++) {\n            for (int j = i; j < digits.length; j++) {\n                int sum = 0;\n                int length = j - i + 1;\n\n                for (int k = i; k <= j; k++) {\n                    sum += digits[k];\n                }\n\n                if (sum == length) {\n                    count++;\n                }\n            }\n        }\n\n        System.out.println(\"Count of substrings: \" + count);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY INTEGER numbers[5] = [12, 4, 56, 7, 89];  /* Example array */\nDECLARE INTEGER min, i;\nmin = numbers[1];  /* Initialize min with the first element */\nFOR i = 2 TO 5 DO\n    IF numbers[i] < min THEN\n        min = numbers[i];\n    END IF;\nEND FOR;\nDISPLAY min;\n</TAL>\n<Java>\npublic class SmallestNumber {\n    public static void main(String[] args) {\n        int[] numbers = {12, 4, 56, 7, 89};  // Example array\n        int min = numbers[0];  // Initialize min with the first element\n\n        for (int i = 1; i < numbers.length; i++) {\n            if (numbers[i] < min) {\n                min = numbers[i];\n            }\n        }\n\n        System.out.println(\"The smallest number is: \" + min);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY TUPLE numbers[5] = [(1, 2), (4, 5), (7, 8), (3, 9), (6, 10)];  /* Example array of tuples */\nDECLARE INTEGER max_diff, i, diff;\nmax_diff = 0;  /* Initialize max_diff */\nFOR i = 1 TO 4 DO\n    DECLARE INTEGER diff;\n    diff = ABS(numbers[i][1] - numbers[i+1][1]);\n    IF diff > max_diff THEN\n        max_diff = diff;\n    END IF;\nEND FOR;\nDISPLAY max_diff;\n</TAL>\n<Java>\npublic class MaxDifference {\n    public static void main(String[] args) {\n        int[][] numbers = {{1, 2}, {4, 5}, {7, 8}, {3, 9}, {6, 10}};  // Example array of tuples\n        int max_diff = 0;\n\n        for (int i = 0; i < numbers.length - 1; i++) {\n            int diff = Math.abs(numbers[i][1] - numbers[i + 1][1]);\n            if (diff > max_diff) {\n                max_diff = diff;\n            }\n        }\n\n        System.out.println(\"The maximum difference is: \" + max_diff);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY TUPLES[5] = [(1, 4), (3, 2), (5, 6), (4, 3), (2, 1)];  /* Example array of tuples */\nDECLARE ARRAY sorted_tuples[5];\nSORT TUPLES BY 2nd ELEMENT;  /* Sort by the second element of each tuple */\nsorted_tuples = TUPLES;  /* Assign sorted array to sorted_tuples */\nDISPLAY sorted_tuples;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class SortTuples {\n    public static void main(String[] args) {\n        // Example list of tuples\n        List<int[]> tuples = new ArrayList<>();\n        tuples.add(new int[]{1, 4});\n        tuples.add(new int[]{3, 2});\n        tuples.add(new int[]{5, 6});\n        tuples.add(new int[]{4, 3});\n        tuples.add(new int[]{2, 1});\n\n        // Sort the list of tuples based on the second element using lambda\n        tuples.sort((a, b) -> Integer.compare(a[1], b[1]));\n\n        // Display the sorted list\n        for (int[] tuple : tuples) {\n            System.out.println(Arrays.toString(tuple));\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY NUMBERS[5] = [1, 2, 3, 4, 5];  /* Example list */\nDECLARE INTEGER RECURSION_SUM;\nPROCEDURE RECURSION_SUM(NUMBERS, INDEX) BEGIN\n    IF INDEX = 0 THEN\n        RETURN NUMBERS[INDEX];\n    END IF;\n    RETURN NUMBERS[INDEX] + RECURSION_SUM(NUMBERS, INDEX - 1);\nEND PROCEDURE;\nRECURSION_SUM = RECURSION_SUM(NUMBERS, 4);  /* Call with the last index */\nDISPLAY RECURSION_SUM;\n</TAL>\n<Java>\npublic class RecursionListSum {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5};  // Example list\n        int sum = recursionSum(numbers, numbers.length - 1);  // Call with the last index\n        System.out.println(\"Sum: \" + sum);\n    }\n\n    public static int recursionSum(int[] numbers, int index) {\n        if (index == 0) {\n            return numbers[index];  // Base case\n        }\n        return numbers[index] + recursionSum(numbers, index - 1);  // Recursive call\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE ARRAY NUMBERS[5] = [-1, 2, 3, -4, 5];  /* Example list */\nDECLARE INTEGER POSITIVE_COUNT = 0;\nDECLARE INTEGER I;\nFOR I = 0 TO 4 BEGIN\n    IF NUMBERS[I] > 0 THEN\n        POSITIVE_COUNT = POSITIVE_COUNT + 1;\n    END IF;\nEND FOR;\nDISPLAY POSITIVE_COUNT;\n</TAL>\n<Java>\npublic class CountPositiveNumbers {\n    public static void main(String[] args) {\n        int[] numbers = {-1, 2, 3, -4, 5};  // Example list\n        int positiveCount = 0;\n        for (int number : numbers) {\n            if (number > 0) {\n                positiveCount++;\n            }\n        }\n        System.out.println(\"Count of positive numbers: \" + positiveCount);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE TUPLE1[3] = [1, 2, 3];\nDECLARE TUPLE2[3] = [4, 5, 6];\nDECLARE TUPLE_ZIPPED[3];\nDECLARE INTEGER I;\nFOR I = 0 TO 2 BEGIN\n    TUPLE_ZIPPED[I] = [TUPLE1[I], TUPLE2[I]];\nEND FOR;\nDISPLAY TUPLE_ZIPPED;\n</TAL>\n<Java>\nimport java.util.*;\n\npublic class ZipTuples {\n    public static void main(String[] args) {\n        Integer[] tuple1 = {1, 2, 3};\n        Integer[] tuple2 = {4, 5, 6};\n        List<String> zipped = new ArrayList<>();\n        for (int i = 0; i < tuple1.length; i++) {\n            zipped.add(tuple1[i] + \",\" + tuple2[i]);\n        }\n        System.out.println(zipped);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM;\nDECLARE INTEGER PREV_DIGIT, CURRENT_DIGIT, I, LENGTH;\nDECLARE BOOLEAN IS_UNDULATING;\nNUM = 12321;  -- Example number\nLENGTH = NUM.SIZE();\nIS_UNDULATING = TRUE;\nPREV_DIGIT = NUM[0];\nFOR I = 1 TO LENGTH - 1 BEGIN\n    CURRENT_DIGIT = NUM[I];\n    IF PREV_DIGIT = CURRENT_DIGIT THEN BEGIN\n        IS_UNDULATING = FALSE;\n        BREAK;\n    END IF;\n    PREV_DIGIT = CURRENT_DIGIT;\nEND FOR;\nIF IS_UNDULATING THEN BEGIN\n    DISPLAY 'The number is undulating.';\nEND ELSE BEGIN\n    DISPLAY 'The number is not undulating.';\nEND;\n</TAL>\n<Java>\npublic class UndulatingNumber {\n    public static void main(String[] args) {\n        int num = 12321;  // Example number\n        String numStr = Integer.toString(num);\n        boolean isUndulating = true;\n        for (int i = 1; i < numStr.length(); i++) {\n            if (numStr.charAt(i) == numStr.charAt(i - 1)) {\n                isUndulating = false;\n                break;\n            }\n        }\n        if (isUndulating) {\n            System.out.println(\"The number is undulating.\");\n        } else {\n            System.out.println(\"The number is not undulating.\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM;\nDECLARE STRING BINARY_RESULT;\nDECLARE INTEGER REMAINDER;\nDECLARE INTEGER QUOTIENT;\nNUM = 10;  -- Example decimal number\nBINARY_RESULT = '';\nWHILE NUM > 0 BEGIN\n    REMAINDER = NUM MOD 2;\n    BINARY_RESULT = STRING(REMAINDER) + BINARY_RESULT;\n    NUM = NUM / 2;\nEND WHILE;\nDISPLAY 'Binary equivalent: ' + BINARY_RESULT;\n</TAL>\n<Java>\npublic class DecimalToBinary {\n    public static void main(String[] args) {\n        int num = 10;  // Example decimal number\n        StringBuilder binaryResult = new StringBuilder();\n        while (num > 0) {\n            binaryResult.insert(0, num % 2);\n            num = num / 2;\n        }\n        System.out.println(\"Binary equivalent: \" + binaryResult.toString());\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE INTEGER NUM;\nDECLARE INTEGER NEXT_PALINDROME;\nDECLARE STRING NUM_STR;\nDECLARE STRING REVERSE_STR;\nNUM = 123;  -- Example number\nNEXT_PALINDROME = NUM + 1;\nWHILE TRUE BEGIN\n    NUM_STR = STRING(NEXT_PALINDROME);\n    REVERSE_STR = REVERSE(NUM_STR);\n    IF NUM_STR = REVERSE_STR THEN BEGIN\n        DISPLAY 'Next smallest palindrome: ' + STRING(NEXT_PALINDROME);\n        BREAK;\n    END;\n    NEXT_PALINDROME = NEXT_PALINDROME + 1;\nEND;\n</TAL>\n<Java>\npublic class NextPalindrome {\n    public static void main(String[] args) {\n        int num = 123;  // Example number\n        int nextPalindrome = num + 1;\n        while (true) {\n            if (isPalindrome(nextPalindrome)) {\n                System.out.println(\"Next smallest palindrome: \" + nextPalindrome);\n                break;\n            }\n            nextPalindrome++;\n        }\n    }\n\n    public static boolean isPalindrome(int num) {\n        String str = Integer.toString(num);\n        String reversed = new StringBuilder(str).reverse().toString();\n        return str.equals(reversed);\n    }\n}\n</Java>"}
{"text": "<TAL>\nDECLARE DICTIONARY MY_DICT;\nDECLARE INTEGER MAX_DEPTH;\nDECLARE INTEGER CURRENT_DEPTH;\nDECLARE STRING KEY;\nDECLARE DICTIONARY SUB_DICT;\nMY_DICT = { 'a': { 'b': { 'c': 5 } }, 'd': 2 };\nMAX_DEPTH = 0;\nFOR KEY IN MY_DICT BEGIN\n    SUB_DICT = MY_DICT[KEY];\n    CURRENT_DEPTH = 1;\n    WHILE TYPEOF(SUB_DICT) = 'DICTIONARY' BEGIN\n        SUB_DICT = SUB_DICT[KEY];\n        CURRENT_DEPTH = CURRENT_DEPTH + 1;\n    END;\n    MAX_DEPTH = MAX(MAX_DEPTH, CURRENT_DEPTH);\nEND;\nDISPLAY 'Max depth of dictionary: ' + STRING(MAX_DEPTH);\n</TAL>\n<Java>\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class DictionaryDepth {\n    public static void main(String[] args) {\n        Map<String, Object> myDict = new HashMap<>();\n        Map<String, Object> subDict = new HashMap<>();\n        Map<String, Object> nestedDict = new HashMap<>();\n\n        nestedDict.put(\"c\", 5);\n        subDict.put(\"b\", nestedDict);\n        myDict.put(\"a\", subDict);\n        myDict.put(\"d\", 2);\n\n        int maxDepth = getDepth(myDict, 1);\n        System.out.println(\"Max depth of dictionary: \" + maxDepth);\n    }\n\n    public static int getDepth(Map<String, Object> dict, int currentDepth) {\n        int maxDepth = currentDepth;\n        for (Map.Entry<String, Object> entry : dict.entrySet()) {\n            if (entry.getValue() instanceof Map) {\n                maxDepth = Math.max(maxDepth, getDepth((Map<String, Object>) entry.getValue(), currentDepth + 1));\n            }\n        }\n        return maxDepth;\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC FIND_MSB_SET_BIT(INT VALUE) -> INT:\nBEGIN\n   INT MSB_POS;\n   IF VALUE = 0 THEN\n      RETURN 0;\n   END;\n   MSB_POS := 0;\n   WHILE VALUE > 0 DO\n   BEGIN\n      VALUE := VALUE >> 1;\n      MSB_POS := MSB_POS + 1;\n   END;\n   RETURN 1 << (MSB_POS - 1);\nEND;\n\nBEGIN\n   INT NUM := 18;\n   INT RESULT := FIND_MSB_SET_BIT(NUM);\n   DISPLAY \"Most significant set bit: \" + STRING(RESULT);\nEND.\n</TAL>\n<Java>\npublic class MostSignificantSetBit {\n    public static int findMSBSetBit(int value) {\n        if (value == 0)\n            return 0;\n        int msbPos = 0;\n        while (value > 0) {\n            value >>= 1;\n            msbPos++;\n        }\n        return 1 << (msbPos - 1);\n    }\n\n    public static void main(String[] args) {\n        int num = 18;\n        int result = findMSBSetBit(num);\n        System.out.println(\"Most significant set bit: \" + result);\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC checkInversionEquality;\nBEGIN\n  INT arr[10] := [1, 3, 2, 4, 5, 6, 7, 9, 8, 10];\n  INT n := 10;\n  INT i, j;\n  INT leftToRight := 0;\n  INT rightToLeft := 0;\n\n  FOR i := 0 TO n - 1 DO\n    FOR j := i + 1 TO n - 1 DO\n      IF arr[i] > arr[j] THEN\n        leftToRight := leftToRight + 1;\n      FI\n    OD\n  OD\n\n  FOR i := n - 1 DOWNTO 0 DO\n    FOR j := i - 1 DOWNTO 0 DO\n      IF arr[i] > arr[j] THEN\n        rightToLeft := rightToLeft + 1;\n      FI\n    OD\n  OD\n\n  IF leftToRight = rightToLeft THEN\n    PRINT \"Inversion counts match.\";\n  ELSE\n    PRINT \"Inversion counts do not match.\";\n  FI\nEND;\n</TAL>\n<Java>\npublic class InversionChecker {\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 2, 4, 5, 6, 7, 9, 8, 10};\n        int n = arr.length;\n        int leftToRight = 0;\n        int rightToLeft = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (arr[i] > arr[j]) {\n                    leftToRight++;\n                }\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i - 1; j >= 0; j--) {\n                if (arr[i] > arr[j]) {\n                    rightToLeft++;\n                }\n            }\n        }\n\n        if (leftToRight == rightToLeft) {\n            System.out.println(\"Inversion counts match.\");\n        } else {\n            System.out.println(\"Inversion counts do not match.\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC findElementAfterRotations;\nBEGIN\n  INT arr[6] := [1, 2, 3, 4, 5, 6];\n  INT n := 6;\n  INT rotations := 2;\n  INT index := 1;\n  INT newIndex;\n\n  ! Calculate new index after right rotation\n  newIndex := (n - (rotations MOD n) + index) MOD n;\n\n  PRINT \"Element at index after rotation is: \";\n  PRINT arr[newIndex];\nEND;\n</TAL>\n<Java>\npublic class RotationFinder {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5, 6};\n        int n = arr.length;\n        int rotations = 2;\n        int index = 1;\n\n        // Right rotation: compute new index\n        int newIndex = (n - (rotations % n) + index) % n;\n\n        System.out.println(\"Element at index after rotation is: \" + arr[newIndex]);\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC MaxIncreasingSubseqSum;\nBEGIN\n  INT arr[8] := [1, 101, 2, 3, 100, 4, 5, 6];\n  INT n := 8;\n  INT i := 4;\n  INT k := 6;\n  INT dp[8];\n  INT maxSum := 0;\n  INT j;\n\n  FOR j := 0 TO i DO\n    dp[j] := arr[j];\n  OD\n\n  FOR j := 1 TO i DO\n    INT l;\n    FOR l := 0 TO j - 1 DO\n      IF arr[j] > arr[l] AND dp[j] < dp[l] + arr[j] THEN\n        dp[j] := dp[l] + arr[j];\n      FI\n    OD\n  OD\n\n  FOR j := 0 TO i DO\n    IF arr[k] > arr[j] THEN\n      IF maxSum < dp[j] + arr[k] THEN\n        maxSum := dp[j] + arr[k];\n      FI\n    FI\n  OD\n\n  PRINT \"Max increasing sum including k: \";\n  PRINT maxSum;\nEND;\n</TAL>\n<Java>\npublic class MaxSubsequenceSum {\n    public static void main(String[] args) {\n        int[] arr = {1, 101, 2, 3, 100, 4, 5, 6};\n        int n = arr.length;\n        int i = 4;\n        int k = 6;\n\n        int[] dp = new int[n];\n        for (int j = 0; j <= i; j++) {\n            dp[j] = arr[j];\n        }\n\n        for (int j = 1; j <= i; j++) {\n            for (int l = 0; l < j; l++) {\n                if (arr[j] > arr[l] && dp[j] < dp[l] + arr[j]) {\n                    dp[j] = dp[l] + arr[j];\n                }\n            }\n        }\n\n        int maxSum = 0;\n        for (int j = 0; j <= i; j++) {\n            if (arr[k] > arr[j]) {\n                maxSum = Math.max(maxSum, dp[j] + arr[k]);\n            }\n        }\n\n        System.out.println(\"Max increasing sum including k: \" + maxSum);\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC MaxSumNonAdjacent2xN;\nBEGIN\n  INT grid[2][5] := [\n    [1, 2, 3, 4, 5],\n    [2, 3, 4, 5, 6]\n  ];\n  INT n := 5;\n  INT i;\n  INT maxCol[5];\n  INT dp[5];\n\n  ! Step 1: Take max of each column\n  FOR i := 0 TO n - 1 DO\n    IF grid[0][i] > grid[1][i] THEN\n      maxCol[i] := grid[0][i];\n    ELSE\n      maxCol[i] := grid[1][i];\n    FI\n  OD\n\n  ! Step 2: Apply DP for max sum with no adjacent selections\n  dp[0] := maxCol[0];\n  dp[1] := IF maxCol[0] > maxCol[1] THEN maxCol[0] ELSE maxCol[1] FI;\n\n  FOR i := 2 TO n - 1 DO\n    IF dp[i - 2] + maxCol[i] > dp[i - 1] THEN\n      dp[i] := dp[i - 2] + maxCol[i];\n    ELSE\n      dp[i] := dp[i - 1];\n    FI\n  OD\n\n  PRINT \"Max sum with no adjacent elements: \";\n  PRINT dp[n - 1];\nEND;\n</TAL>\n<Java>\npublic class MaxSum2xN {\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 2, 3, 4, 5},\n            {2, 3, 4, 5, 6}\n        };\n        int n = grid[0].length;\n\n        int[] maxCol = new int[n];\n        for (int i = 0; i < n; i++) {\n            maxCol[i] = Math.max(grid[0][i], grid[1][i]);\n        }\n\n        int[] dp = new int[n];\n        dp[0] = maxCol[0];\n        dp[1] = Math.max(maxCol[0], maxCol[1]);\n\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + maxCol[i]);\n        }\n\n        System.out.println(\"Max sum with no adjacent elements: \" + dp[n - 1]);\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC FindLastOccurrence;\nBEGIN\n  INT arr[10] := [1, 2, 2, 2, 3, 4, 4, 4, 5, 5];\n  INT n := 10;\n  INT target := 4;\n  INT low := 0;\n  INT high := n - 1;\n  INT result := -1;\n  INT mid;\n\n  WHILE low <= high DO\n    mid := (low + high) / 2;\n    IF arr[mid] = target THEN\n      result := mid;\n      low := mid + 1;\n    ELSE IF arr[mid] < target THEN\n      low := mid + 1;\n    ELSE\n      high := mid - 1;\n    FI\n  OD\n\n  IF result >= 0 THEN\n    PRINT \"Last occurrence found at index: \";\n    PRINT result;\n  ELSE\n    PRINT \"Element not found.\";\n  FI\nEND;\n</TAL>\n<Java>\npublic class LastOccurrence {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 2, 2, 3, 4, 4, 4, 5, 5};\n        int target = 4;\n        int low = 0, high = arr.length - 1;\n        int result = -1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (arr[mid] == target) {\n                result = mid;\n                low = mid + 1; // Move right to find the last occurrence\n            } else if (arr[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        if (result >= 0) {\n            System.out.println(\"Last occurrence found at index: \" + result);\n        } else {\n            System.out.println(\"Element not found.\");\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC ModifiedRunLengthEncoding;\nBEGIN\n  INT arr[12] := [1, 1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 7];\n  INT n := 12;\n  INT i := 0;\n\n  PRINT \"Modified RLE Output:\";\n\n  WHILE i < n DO\n    INT count := 1;\n    WHILE i + count < n AND arr[i] = arr[i + count] DO\n      count := count + 1;\n    OD\n\n    IF count = 1 THEN\n      PRINT arr[i];\n    ELSE\n      PRINT \"(\";\n      PRINT count;\n      PRINT \", \";\n      PRINT arr[i];\n      PRINT \")\";\n    FI\n\n    i := i + count;\n  OD\nEND;\n</TAL>\n<Java>\npublic class ModifiedRLE {\n    public static void main(String[] args) {\n        int[] arr = {1, 1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 7};\n        int n = arr.length;\n        int i = 0;\n\n        System.out.println(\"Modified RLE Output:\");\n        while (i < n) {\n            int count = 1;\n            while (i + count < n && arr[i] == arr[i + count]) {\n                count++;\n            }\n\n            if (count == 1) {\n                System.out.print(arr[i] + \" \");\n            } else {\n                System.out.print(\"(\" + count + \", \" + arr[i] + \") \");\n            }\n\n            i += count;\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC DifferenceOfSquares;\nBEGIN\n  INT n := 10;\n  INT i;\n  INT sum := 0;\n  INT sumOfSquares := 0;\n  INT squareOfSum;\n  INT result;\n\n  FOR i := 1 TO n DO\n    sum := sum + i;\n    sumOfSquares := sumOfSquares + i * i;\n  OD\n\n  squareOfSum := sum * sum;\n  result := squareOfSum - sumOfSquares;\n\n  PRINT \"Difference is: \";\n  PRINT result;\nEND;\n</TAL>\n<Java>\npublic class DifferenceOfSquares {\n    public static void main(String[] args) {\n        int n = 10;\n        int sum = 0;\n        int sumOfSquares = 0;\n\n        for (int i = 1; i <= n; i++) {\n            sum += i;\n            sumOfSquares += i * i;\n        }\n\n        int squareOfSum = sum * sum;\n        int result = squareOfSum - sumOfSquares;\n\n        System.out.println(\"Difference is: \" + result);\n    }\n}\n</Java>"}
{"text": "<TAL>\nPROC MostFrequentWord;\nBEGIN\n  STRING words[10] := [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\", \"grape\", \"banana\", \"banana\", \"orange\"];\n  STRING uniqueWords[10];\n  INT freq[10];\n  INT n := 10;\n  INT i, j, k := 0;\n  INT maxFreq := 0;\n  STRING mostFreqWord := \"\";\n\n  FOR i := 0 TO n - 1 DO\n    INT found := 0;\n    FOR j := 0 TO k - 1 DO\n      IF words[i] = uniqueWords[j] THEN\n        freq[j] := freq[j] + 1;\n        found := 1;\n        BREAK;\n      FI\n    OD\n\n    IF found = 0 THEN\n      uniqueWords[k] := words[i];\n      freq[k] := 1;\n      k := k + 1;\n    FI\n  OD\n\n  FOR i := 0 TO k - 1 DO\n    IF freq[i] > maxFreq THEN\n      maxFreq := freq[i];\n      mostFreqWord := uniqueWords[i];\n    FI\n  OD\n\n  PRINT \"Most frequent word: \";\n  PRINT mostFreqWord;\n  PRINT \", Count: \";\n  PRINT maxFreq;\nEND;\n</TAL>\n<Java>\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MostFrequentWord {\n    public static void main(String[] args) {\n        String[] words = {\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\", \"grape\", \"banana\", \"banana\", \"orange\"};\n        Map<String, Integer> frequencyMap = new HashMap<>();\n\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n\n        String mostFrequent = \"\";\n        int maxFreq = 0;\n\n        for (Map.Entry<String, Integer> entry : frequencyMap.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n                mostFrequent = entry.getKey();\n            }\n        }\n\n        System.out.println(\"Most frequent word: \" + mostFrequent);\n        System.out.println(\"Count: \" + maxFreq);\n    }\n}\n</Java>"}
