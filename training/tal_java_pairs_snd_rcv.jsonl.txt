{"text":"TAL Server process using RECEIVE", "<TAL>PROC server MAIN;\nBEGIN\n  INT receive_file_num;\n  INT error;\n  INT count_read;\n  STRING .buffer[0:1023];\n  \n  ! Open RECEIVE file\n  CALL OPEN_(\"RECEIVE\", receive_file_num, 1);\n  IF < THEN\n  BEGIN\n    CALL FILE_GETINFO_(receive_file_num, error);\n    CALL LOG_ERROR(\"OPEN error\", error);\n    RETURN;\n  END;\n  \n  ! Process loop\n  WHILE 1 DO\n  BEGIN\n    ! Read the message\n    CALL READUPDATE(receive_file_num, buffer, 1024, count_read);\n    IF < THEN\n    BEGIN\n      CALL FILE_GETINFO_(receive_file_num, error);\n      CALL LOG_ERROR(\"RECEIVE error\", error);\n      CONTINUE;\n    END;\n    \n    ! Process the message\n    CALL process_message(buffer, count_read);\n    \n    ! Reply to the sender\n    CALL REPLY(\"ACK\", 3);\n  END;\n  \n  ! Close RECEIVE\n  CALL CLOSE_(receive_file_num);\nEND;\n\nPROC process_message(msg, len);\nSTRING .msg;\nINT len;\nBEGIN\n  ! Process the received message\n  ! Just display the message in this example\n  msg[len] := 0; ! Null terminate for display\n  CALL WRITE(term_num, msg, len);\nEND;\n</TAL>\n<Java>\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.*;\nimport java.time.Duration;\nimport java.util.*;\n\npublic class KafkaServer {\n    private static final String BOOTSTRAP_SERVERS = \"localhost:9092\";\n    private static final String GROUP_ID = \"server-group\";\n    private static final String REQUEST_TOPIC = \"RECEIVE-TOPIC\";\n    private static final String REPLY_TOPIC_PREFIX = \"REPLY-\";\n    \n    public static void main(String[] args) {\n        // Set up Kafka consumer properties - equivalent to OPEN(RECEIVE)\n        Properties consumerProps = new Properties();\n        consumerProps.put(\"bootstrap.servers\", BOOTSTRAP_SERVERS);\n        consumerProps.put(\"group.id\", GROUP_ID);\n        consumerProps.put(\"key.deserializer\", StringDeserializer.class.getName());\n        consumerProps.put(\"value.deserializer\", StringDeserializer.class.getName());\n        \n        // Set up Kafka producer properties - for sending replies\n        Properties producerProps = new Properties();\n        producerProps.put(\"bootstrap.servers\", BOOTSTRAP_SERVERS);\n        producerProps.put(\"key.serializer\", StringSerializer.class.getName());\n        producerProps.put(\"value.serializer\", StringSerializer.class.getName());\n        \n        try (Consumer<String, String> consumer = new KafkaConsumer<>(consumerProps);\n             Producer<String, String> producer = new KafkaProducer<>(producerProps)) {\n            \n            // Subscribe to the RECEIVE topic\n            consumer.subscribe(Collections.singletonList(REQUEST_TOPIC));\n            System.out.println(\"Server started, listening on topic: \" + REQUEST_TOPIC);\n            \n            // Process loop - equivalent to RECEIVE loop\n            while (true) {\n                // Poll for messages - equivalent to READUPDATE\n                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));\n                \n                for (ConsumerRecord<String, String> record : records) {\n                    // Extract the client ID and message\n                    String clientId = record.key();\n                    String message = record.value();\n                    \n                    // Process the message\n                    processMessage(message, clientId);\n                    \n                    // Send reply - equivalent to REPLY\n                    String replyTopic = REPLY_TOPIC_PREFIX + clientId;\n                    producer.send(new ProducerRecord<>(replyTopic, clientId, \"ACK\"));\n                }\n            }\n        } catch (Exception e) {\n            logError(\"Kafka error\", e.getMessage());\n        }\n    }\n    \n    private static void processMessage(String message, String sender) {\n        // Process the received message\n        System.out.println(\"Received message: \" + message + \" from \" + sender);\n    }\n    \n    private static void logError(String context, String error) {\n        System.err.println(context + \": \" + error);\n    }\n}\n</Java>"}
{"text": "TAL Client process using SEND", "<TAL>PROC client MAIN;\nBEGIN\n  INT server_file_num;\n  INT error;\n  INT count_written;\n  INT bytes_read;\n  STRING .message[0:255];\n  STRING .reply[0:255];\n  \n  ! Prepare the message\n  message ':=' "Hello Server" -> @message[12];\n  \n  ! Open the server process\n  CALL OPEN_("$SERV1", server_file_num, 1);\n  IF < THEN\n  BEGIN\n    CALL FILE_GETINFO_(server_file_num, error);\n    CALL LOG_ERROR("OPEN error", error);\n    RETURN;\n  END;\n  \n  ! Send the message and get reply\n  CALL WRITEREAD(server_file_num, message, 12, 256, bytes_read);\n  IF < THEN\n  BEGIN\n    CALL FILE_GETINFO_(server_file_num, error);\n    CALL LOG_ERROR("SEND error", error);\n    RETURN;\n  END;\n  \n  ! Process the reply\n  reply[bytes_read] := 0; ! Null terminate for display\n  CALL WRITE(term_num, reply, bytes_read);\n  \n  ! Close the file\n  CALL CLOSE_(server_file_num);\nEND;\n</TAL>\n<Java>\nimport org.apache.kafka.clients.consumer.;\nimport org.apache.kafka.clients.producer.;\nimport org.apache.kafka.common.serialization.;\nimport java.time.Duration;\nimport java.util.;\n\npublic class KafkaClient {\n    private static final String BOOTSTRAP_SERVERS = "localhost:9092";\n    private static final String REQUEST_TOPIC = "RECEIVE-TOPIC";\n    private static final String CLIENT_ID = "CLIENT1";\n    private static final String REPLY_TOPIC = "REPLY-" + CLIENT_ID;\n    private static final int TIMEOUT_MS = 10000; // 10 seconds timeout\n    \n    public static void main(String[] args) {\n        sendMessage("Hello Server");\n    }\n    \n    public static void sendMessage(String messageContent) {\n        // Set up Kafka producer properties\n        Properties producerProps = new Properties();\n        producerProps.put("bootstrap.servers", BOOTSTRAP_SERVERS);\n        producerProps.put("key.serializer", StringSerializer.class.getName());\n        producerProps.put("value.serializer", StringSerializer.class.getName());\n        \n        // Set up Kafka consumer properties for receiving reply\n        Properties consumerProps = new Properties();\n        consumerProps.put("bootstrap.servers", BOOTSTRAP_SERVERS);\n        consumerProps.put("group.id", CLIENT_ID);\n        consumerProps.put("key.deserializer", StringDeserializer.class.getName());\n        consumerProps.put("value.deserializer", StringDeserializer.class.getName());\n        consumerProps.put("auto.offset.reset", "latest"); // Only get messages after we subscribe\n        \n        try (Producer<String, String> producer = new KafkaProducer<>(producerProps);\n             Consumer<String, String> consumer = new KafkaConsumer<>(consumerProps)) {\n            \n            // Subscribe to reply topic\n            consumer.subscribe(Collections.singletonList(REPLY_TOPIC));\n            \n            // Send message - equivalent to WRITE part of WRITEREAD\n            producer.send(new ProducerRecord<>(REQUEST_TOPIC, CLIENT_ID, messageContent));\n            producer.flush();\n            System.out.println("Sent message: " + messageContent);\n            \n            // Wait for reply - equivalent to READ part of WRITEREAD\n            long startTime = System.currentTimeMillis();\n            boolean replyReceived = false;\n            \n            while (!replyReceived && System.currentTimeMillis() - startTime < TIMEOUT_MS) {\n                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));\n                \n                for (ConsumerRecord<String, String> record : records) {\n                    if (CLIENT_ID.equals(record.key())) {\n                        // Process the reply\n                        System.out.println("Received reply: " + record.value());\n                        replyReceived = true;\n                        break;\n                    }\n                }\n            }\n            \n            if (!replyReceived) {\n                logError("Reply error", "Timed out waiting for reply");\n            }\n            \n        } catch (Exception e) {\n            logError("Kafka error", e.getMessage());\n        }\n    }\n    \n    private static void logError(String context, String error) {\n        System.err.println(context + ": " + error);\n    }\n}\n</Java>"}
{"text":"TAL Server process with message types", "<TAL>STRUCT msg_header (*);\nBEGIN\n  INT msg_type;\n  INT reply_tag;\n  INT length;\nEND;\n\nSTRUCT data_msg (*);\nBEGIN\n  INT msg_type;\n  INT reply_tag;\n  INT length;\n  STRING data[0:255];\nEND;\n\nPROC server MAIN;\nBEGIN\n  INT receive_file_num;\n  INT bytes_read;\n  INT error;\n  INT .buffer[0:150];\n  STRUCT .msg (msg_header);\n  STRUCT .data_message (data_msg);\n  \n  ! Open RECEIVE\n  CALL OPEN_(\"RECEIVE\", receive_file_num, 1);\n  IF < THEN\n  BEGIN\n    CALL PROCESS_STOP_;\n    RETURN;\n  END;\n  \n  ! Process messages in a loop\n  WHILE 1 DO\n  BEGIN\n    ! Read the next message\n    CALL READUPDATE(receive_file_num, buffer, 300, bytes_read);\n    \n    IF < THEN\n    BEGIN\n      CALL FILE_GETINFO_(receive_file_num, error);\n      CALL LOG_ERROR(\"READ error\", error);\n      CONTINUE;\n    END;\n    \n    ! Set up structure pointer to interpret message\n    @msg := @buffer;\n    \n    ! Process based on message type\n    CASE msg.msg_type OF\n    BEGIN\n      1 ! Get data request\n        CALL handle_get_data(receive_file_num, buffer, bytes_read);\n      \n      2 ! Send data request\n        @data_message := @buffer;\n        CALL handle_send_data(receive_file_num, data_message);\n      \n      3 ! Shutdown request\n        CALL REPLY(buffer, 0);\n        BREAK;\n      \n      OTHERWISE\n        ! Unknown message type\n        CALL REPLY(\"ERROR: Unknown message type\", 26);\n    END;\n  END;\n  \n  CALL CLOSE_(receive_file_num);\nEND;\n\nPROC handle_get_data(file_num, buffer, len);\nINT file_num;\nINT .buffer;\nINT len;\nBEGIN\n  ! Handle request to get data\n  STRING .reply[0:100];\n  \n  ! Prepare reply - for example, just echo the request\n  reply ':=' \"Data requested\" -> @reply[15];\n  \n  ! Send the reply\n  CALL REPLY(reply, 15);\nEND;\n\nPROC handle_send_data(file_num, msg);\nINT file_num;\nSTRUCT .msg (data_msg);\nBEGIN\n  ! Handle data sent by client\n  ! Process msg.data...\n  \n  ! Send acknowledgement\n  CALL REPLY(\"ACK\", 3);\nEND;\n</TAL>\n<Java>\nimport org.apache.kafka.clients.consumer.*;\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.*;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.time.Duration;\nimport java.util.*;\nimport java.io.*;\n\npublic class KafkaTypedServer {\n    // Message type constants\n    private static final int MSG_TYPE_GET_DATA = 1;\n    private static final int MSG_TYPE_SEND_DATA = 2;\n    private static final int MSG_TYPE_SHUTDOWN = 3;\n    \n    private static final String BOOTSTRAP_SERVERS = \"localhost:9092\";\n    private static final String GROUP_ID = \"server-group\";\n    private static final String REQUEST_TOPIC = \"RECEIVE-TOPIC\";\n    private static final String REPLY_TOPIC_PREFIX = \"REPLY-\";\n    private static final ObjectMapper mapper = new ObjectMapper();\n    private static boolean running = true;\n    \n    // Message header structure\n    public static class MessageHeader {\n        public int msgType;\n        public int replyTag;\n        public int length;\n        \n        public MessageHeader() {}\n        \n        public MessageHeader(int msgType, int replyTag, int length) {\n            this.msgType = msgType;\n            this.replyTag = replyTag;\n            this.length = length;\n        }\n    }\n    \n    // Data message structure\n    public static class DataMessage extends MessageHeader {\n        public String data;\n        \n        public DataMessage() {}\n        \n        public DataMessage(int msgType, int replyTag, String data) {\n            super(msgType, replyTag, data != null ? data.length() : 0);\n            this.data = data;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Set up Kafka consumer properties - equivalent to OPEN($RECEIVE)\n        Properties consumerProps = new Properties();\n        consumerProps.put(\"bootstrap.servers\", BOOTSTRAP_SERVERS);\n        consumerProps.put(\"group.id\", GROUP_ID);\n        consumerProps.put(\"key.deserializer\", StringDeserializer.class.getName());\n        consumerProps.put(\"value.deserializer\", StringDeserializer.class.getName());\n        \n        // Set up Kafka producer properties - for sending replies\n        Properties producerProps = new Properties();\n        producerProps.put(\"bootstrap.servers\", BOOTSTRAP_SERVERS);\n        producerProps.put(\"key.serializer\", StringSerializer.class.getName());\n        producerProps.put(\"value.serializer\", StringSerializer.class.getName());\n        \n        try (Consumer<String, String> consumer = new KafkaConsumer<>(consumerProps);\n             Producer<String, String> producer = new KafkaProducer<>(producerProps)) {\n            \n            // Subscribe to the RECEIVE topic\n            consumer.subscribe(Collections.singletonList(REQUEST_TOPIC));\n            System.out.println(\"Server started, listening on topic: \" + REQUEST_TOPIC);\n            \n            // Process loop - equivalent to RECEIVE loop\n            while (running) {\n                // Poll for messages - equivalent to READUPDATE\n                ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));\n                \n                for (ConsumerRecord<String, String> record : records) {\n                    try {\n                        // Extract the client ID and message\n                        String clientId = record.key();\n                        String messageJson = record.value();\n                        \n                        // Parse JSON to determine message type\n                        MessageHeader header = mapper.readValue(messageJson, MessageHeader.class);\n                        String replyTopic = REPLY_TOPIC_PREFIX + clientId;\n                        \n                        // Process based on message type\n                        switch (header.msgType) {\n                            case MSG_TYPE_GET_DATA:\n                                handleGetData(producer, replyTopic, clientId, header);\n                                break;\n                                \n                            case MSG_TYPE_SEND_DATA:\n                                DataMessage dataMsg = mapper.readValue(messageJson, DataMessage.class);\n                                handleSendData(producer, replyTopic, clientId, dataMsg);\n                                break;\n                                \n                            case MSG_TYPE_SHUTDOWN:\n                                // Send empty reply and exit\n                                producer.send(new ProducerRecord<>(replyTopic, clientId, \"\"));\n                                running = false;\n                                break;\n                                \n                            default:\n                                // Unknown message type\n                                producer.send(new ProducerRecord<>(replyTopic, clientId, \n                                    \"ERROR: Unknown message type\"));\n                        }\n                    } catch (Exception e) {\n                        logError(\"Message processing error\", e.getMessage());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            logError(\"Kafka error\", e.getMessage());\n        }\n    }\n    \n    private static void handleGetData(Producer<String, String> producer, \n                                    String replyTopic, String clientId, \n                                    MessageHeader header) throws IOException {\n        // Handle request to get data\n        String replyData = \"Data requested\";\n        String replyJson = mapper.writeValueAsString(new DataMessage(header.msgType, \n                                                              header.replyTag, \n                                                              replyData));\n        producer.send(new ProducerRecord<>(replyTopic, clientId, replyJson));\n    }\n    \n    private static void handleSendData(Producer<String, String> producer, \n                                     String replyTopic, String clientId, \n                                     DataMessage msg) throws IOException {\n        // Handle data sent by client\n        System.out.println(\"Received data: \" + msg.data);\n        \n        // Send acknowledgement\n        String replyJson = mapper.writeValueAsString(new DataMessage(msg.msgType, \n                                                              msg.replyTag, \n                                                              \"ACK\"));\n        producer.send(new ProducerRecord<>(replyTopic, clientId, replyJson));\n    }\n    \n    private static void logError(String context, String error) {\n        System.err.println(context + \": \" + error);\n    }\n}\n</Java>"}
