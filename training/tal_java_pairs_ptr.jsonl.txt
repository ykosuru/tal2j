{"text": "<TAL>\n! TAL procedure demonstrating basic pointer arithmetic\nPROC pointer_basics;\nBEGIN\n  INT .int_array[0:9] := [0,1,2,3,4,5,6,7,8,9];\n  INT .int_ptr;\n  \n  ! Initialize pointer to start of array\n  int_ptr := @int_array;\n  \n  ! Access array using pointer arithmetic\n  int_ptr[5] := 55;        ! Modify 6th element (index 5)\n  int_ptr := int_ptr + 2;  ! Move pointer ahead by 2 elements\n  int_ptr[0] := 22;        ! Modify current element (originally index 2)\n  \n  ! Now int_array contains [0,1,22,3,4,55,6,7,8,9]\n  \n  ! Reset pointer to beginning of array\n  int_ptr := @int_array;\n  \n  ! Print array elements\n  CALL print_array(int_array, 10);\nEND;\n</TAL>\n<Java>\nimport java.util.Arrays;\n\npublic class PointerBasicsExample {\n    public static void main(String[] args) {\n        // Create array (equivalent to TAL int_array)\n        int[] intArray = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        \n        // Directly modify array elements\n        // (Java uses indexed access rather than pointer arithmetic)\n        intArray[5] = 55;  // Modify 6th element (index 5)\n        intArray[2] = 22;  // Modify 3rd element (index 2)\n        \n        // Print array elements\n        printArray(intArray);\n    }\n    \n    private static void printArray(int[] array) {\n        System.out.println(Arrays.toString(array));\n    }\n}\n</Java>"}
{"text": "<TAL>\n! TAL procedure demonstrating pointer manipulation for byte access\nPROC byte_manipulation;\nBEGIN\n  INT word[0:4] := [0, 0, 0, 0, 0];\n  STRING .byte_ptr;\n  INT i;\n  \n  ! Convert word address to byte address\n  byte_ptr := @word '<<' 1;  ! Shift left by 1 to multiply by 2\n  \n  ! Fill array with byte values\n  FOR i := 0 TO 9 DO\n    byte_ptr[i] := i + 65;  ! ASCII 'A' starts at 65\n  \n  ! Print resulting words (should contain ASCII characters)\n  CALL print_words(word, 5);\nEND;\n</TAL>\n<Java>\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\npublic class ByteManipulationExample {\n    public static void main(String[] args) {\n        // Create a ByteBuffer to handle byte-level access\n        // ByteBuffer provides a more elegant way to handle binary data in Java\n        ByteBuffer buffer = ByteBuffer.allocate(10);\n        \n        // Fill buffer with byte values (ASCII 'A' through 'J')\n        for (int i = 0; i < 10; i++) {\n            buffer.put(i, (byte)(i + 65)); // ASCII 'A' starts at 65\n        }\n        \n        // Print the content as a string\n        String result = StandardCharsets.US_ASCII.decode(buffer).toString();\n        System.out.println("Buffer as ASCII: " + result);\n        \n        // Print the content as integers (similar to TAL's word array)\n        System.out.println("Buffer as words:");\n        buffer.rewind();\n        while (buffer.remaining() >= 2) {\n            System.out.println(buffer.getShort()); // Read 2 bytes (word) at a time\n        }\n    }\n}\n</Java>"}
{"text": "<TAL>\n! TAL procedure demonstrating complex pointer arithmetic with structures\nSTRUCT record (*);\nBEGIN\n  INT id;\n  STRING name[0:19];\n  FIXED(2) salary;\nEND;\n\nPROC structure_pointers;\nBEGIN\n  STRUCT .employee_array (record) [0:9];\n  STRUCT .current_employee (record);\n  INT i;\n  \n  ! Initialize pointer to first record\n  @current_employee := @employee_array;\n  \n  ! Initialize some employee records\n  FOR i := 0 TO 9 DO\n  BEGIN\n    ! Access record using pointer arithmetic\n    current_employee.id := 1000 + i;\n    current_employee.name ':=' "Employee" -> @current_employee.name[8];\n    CALL NUMOUT(current_employee.name[8], i, 10, 2);\n    current_employee.salary := 5000F + (i * 500F);\n    \n    ! Move pointer to next record\n    @current_employee := @current_employee + $LEN(current_employee);\n  END;\n  \n  ! Reset pointer to beginning\n  @current_employee := @employee_array;\n  \n  ! Access specific employee using index\n  @current_employee := @employee_array + 5 * $LEN(employee_array[0]);\n  \n  ! Print the salary of employee 5\n  CALL print_salary(current_employee.salary);\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StructurePointerExample {\n    // Employee class (equivalent to TAL record structure)\n    static class Employee {\n        private int id;\n        private String name;\n        private double salary;  // Equivalent to FIXED(2)\n        \n        public Employee(int id, String name, double salary) {\n            this.id = id;\n            this.name = name;\n            this.salary = salary;\n        }\n        \n        @Override\n        public String toString() {\n            return String.format("%d - %s - $%.2f", id, name, salary);\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Create a list of employees (more natural in Java than an array)\n        List<Employee> employees = new ArrayList<>();\n        \n        // Initialize employee records\n        for (int i = 0; i < 10; i++) {\n            employees.add(new Employee(\n                1000 + i,\n                String.format("Employee%02d", i),\n                5000.00 + (i * 500.00)\n            ));\n        }\n        \n        // Access specific employee using index (much cleaner than pointer arithmetic)\n        Employee employeeAtIndex5 = employees.get(5);\n        \n        // Print the salary of employee 5\n        System.out.printf("Employee 5 salary: $%.2f%n", employeeAtIndex5.salary);\n        \n        // Advanced: Use Java streams for processing the collection\n        System.out.println("\nEmployees with salary > $7000:");\n        employees.stream()\n            .filter(e -> e.salary > 7000.0)\n            .forEach(System.out::println);\n    }\n}\n</Java>"}
{"text": "<TAL>\n! TAL procedure demonstrating pointer arithmetic for memory buffer management\nPROC memory_buffer_manager;\nBEGIN\n  INT .buffer[0:1023];  ! 1K word buffer (2K bytes)\n  INT .next_free;\n  INT .current_ptr;\n  INT alloc_size;\n  INT iterations;\n  \n  ! Initialize buffer manager\n  next_free := @buffer;\n  \n  ! Allocate a section of 10 words\n  alloc_size := 10;\n  current_ptr := next_free;\n  next_free := next_free + alloc_size;\n  \n  ! Fill the allocated section\n  FOR iterations := 0 TO alloc_size - 1 DO\n    current_ptr[iterations] := iterations * 10;\n  \n  ! Allocate another section of 5 words\n  alloc_size := 5;\n  current_ptr := next_free;\n  next_free := next_free + alloc_size;\n  \n  ! Fill the second allocated section\n  FOR iterations := 0 TO alloc_size - 1 DO\n    current_ptr[iterations] := 100 + iterations;\n  \n  ! Reposition to the beginning of the buffer \n  current_ptr := @buffer;\n  \n  ! Use the data in the first allocation\n  CALL process_data(current_ptr, 10);\n  \n  ! Move pointer to the second allocation\n  current_ptr := current_ptr + 10;\n  \n  ! Use the data in the second allocation\n  CALL process_data(current_ptr, 5);\nEND;\n</TAL>\n<Java>\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\n\npublic class MemoryBufferExample {\n    public static void main(String[] args) {\n        // Using ByteBuffer for memory management (more elegant than pointer manipulation)\n        ByteBuffer buffer = ByteBuffer.allocate(2048);  // 2K bytes\n        \n        // Allocate a section of 10 integers (40 bytes)\n        int firstAllocationSize = 10;\n        int firstAllocationPosition = buffer.position();\n        \n        // Fill the allocated section\n        for (int i = 0; i < firstAllocationSize; i++) {\n            buffer.putInt(i * 10);\n        }\n        \n        // Allocate another section of 5 integers (20 bytes)\n        int secondAllocationSize = 5;\n        int secondAllocationPosition = buffer.position();\n        \n        // Fill the second allocated section\n        for (int i = 0; i < secondAllocationSize; i++) {\n            buffer.putInt(100 + i);\n        }\n        \n        // Alternative approach: Using slices for different sections\n        buffer.position(0);  // Reset position to beginning\n        \n        // Create a view of the first allocation\n        buffer.limit(firstAllocationSize * 4);  // 4 bytes per int\n        ByteBuffer firstAllocation = buffer.slice();\n        \n        // Create a view of the second allocation\n        buffer.position(secondAllocationPosition);\n        buffer.limit(secondAllocationPosition + (secondAllocationSize * 4));\n        ByteBuffer secondAllocation = buffer.slice();\n        \n        // Use the data in the first allocation\n        processData(firstAllocation);\n        \n        // Use the data in the second allocation\n        processData(secondAllocation);\n        \n        // Even more elegant: Using Java's memory management\n        System.out.println("\nAlternative approach with Java collections:");\n        usingCollections();\n    }\n    \n    private static void processData(ByteBuffer buffer) {\n        buffer.rewind();  // Reset position to beginning of this buffer slice\n        System.out.println("Processing data section:");\n        while (buffer.hasRemaining() && buffer.position() < buffer.limit()) {\n            System.out.print(buffer.getInt() + " ");\n        }\n        System.out.println();\n    }\n    \n    // A more natural Java approach using collections\n    private static void usingCollections() {\n        // Using ArrayList for dynamic memory management\n        List<Integer> section1 = new ArrayList<>();\n        List<Integer> section2 = new ArrayList<>();\n        \n        // Fill the first section\n        for (int i = 0; i < 10; i++) {\n            section1.add(i * 10);\n        }\n        \n        // Fill the second section\n        for (int i = 0; i < 5; i++) {\n            section2.add(100 + i);\n        }\n        \n        // Process the sections\n        System.out.println("Section 1: " + section1);\n        System.out.println("Section 2: " + section2);\n    }\n}\n</Java>"}
{"text": "<TAL>\n! TAL procedure demonstrating double indirection and linked list navigation\nSTRUCT node (*);\nBEGIN\n  INT value;\n  INT .next_ptr;  ! Pointer to next node\nEND;\n\nPROC linked_list;\nBEGIN\n  STRUCT .first_node (node);\n  STRUCT .current_node (node);\n  STRUCT .temp_node (node);\n  STRUCT .prev_node (node);\n  INT .node_ptr;\n  INT i;\n  \n  ! Allocate space for the first node\n  node_ptr := $ALLOCATE_MEMORY(26);  ! Custom allocator function\n  @first_node := node_ptr;\n  first_node.value := 100;\n  first_node.next_ptr := 0;  ! NULL pointer\n  \n  ! Create linked list with 5 nodes\n  @current_node := @first_node;\n  \n  FOR i := 1 TO 4 DO\n  BEGIN\n    ! Allocate a new node\n    node_ptr := $ALLOCATE_MEMORY(26);\n    @temp_node := node_ptr;\n    temp_node.value := 100 + (i * 10);\n    temp_node.next_ptr := 0;  ! NULL pointer\n    \n    ! Link new node to the list\n    current_node.next_ptr := node_ptr;\n    \n    ! Move current to the new node\n    @current_node := node_ptr;\n  END;\n  \n  ! Reset to the start of the list\n  @current_node := @first_node;\n  \n  ! Traverse the linked list\n  WHILE @current_node <> 0 DO\n  BEGIN\n    CALL print_value(current_node.value);\n    \n    ! Save current node as previous\n    @prev_node := @current_node;\n    \n    ! Move to next node using the pointer in the current node\n    @current_node := current_node.next_ptr;\n  END;\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class LinkedListExample {\n    // Node class for custom implementation\n    static class Node {\n        private int value;\n        private Node next;  // Reference to next node\n        \n        public Node(int value) {\n            this.value = value;\n            this.next = null;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Demonstrate both manual linked list implementation and Java's LinkedList\n        customLinkedList();\n        javaLinkedList();\n    }\n    \n    private static void customLinkedList() {\n        System.out.println("Custom linked list implementation:");\n        \n        // Create the first node\n        Node firstNode = new Node(100);\n        Node currentNode = firstNode;\n        \n        // Create linked list with 5 nodes\n        for (int i = 1; i <= 4; i++) {\n            // Create a new node\n            Node newNode = new Node(100 + (i * 10));\n            \n            // Link new node to the list\n            currentNode.next = newNode;\n            \n            // Move current to the new node\n            currentNode = newNode;\n        }\n        \n        // Reset to the start of the list\n        currentNode = firstNode;\n        \n        // Traverse the linked list\n        while (currentNode != null) {\n            System.out.println("Node value: " + currentNode.value);\n            \n            // Move to next node\n            currentNode = currentNode.next;\n        }\n    }\n    \n    private static void javaLinkedList() {\n        System.out.println("\nJava's LinkedList implementation:");\n        \n        // Create a linked list using Java's built-in LinkedList\n        LinkedList<Integer> list = new LinkedList<>();\n        \n        // Add nodes to the list\n        list.add(100);\n        for (int i = 1; i <= 4; i++) {\n            list.add(100 + (i * 10));\n        }\n        \n        // Traverse the list using an Iterator\n        System.out.println("Using Iterator:");\n        Iterator<Integer> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            System.out.println("Node value: " + iterator.next());\n        }\n        \n        // Or more elegantly with Java 8 streams\n        System.out.println("\nUsing Stream API:");\n        list.stream()\n            .forEach(value -> System.out.println("Node value: " + value));\n        \n        // Or even more concisely\n        System.out.println("\nUsing forEach:");\n        list.forEach(value -> System.out.println("Node value: " + value));\n    }\n}\n</Java>"}
{"text": "<TAL>\n! TAL procedure demonstrating buffer scanning with pointers\nPROC scan_buffer;\nBEGIN\n  STRING .text_buffer[0:255];\n  STRING .current_ptr;\n  STRING .word_start;\n  STRING .word_end;\n  INT word_length;\n  \n  ! Initialize buffer with text\n  text_buffer ':=' "  This is a   sample text  with extra  spaces  " -> @text_buffer[50];\n  \n  ! Scan through buffer and identify words\n  @current_ptr := @text_buffer;\n  \n  WHILE current_ptr[0] <> 0 DO\n  BEGIN\n    ! Skip leading spaces\n    SCAN current_ptr WHILE " " -> @current_ptr;\n    \n    ! If we hit the end, exit\n    IF current_ptr[0] = 0 THEN\n      BREAK;\n      \n    ! Mark start of word\n    @word_start := @current_ptr;\n    \n    ! Scan until space or end\n    SCAN current_ptr UNTIL " " -> @word_end;\n    \n    ! Calculate word length\n    word_length := @word_end '-' @word_start;\n    \n    ! Process the word (print it)\n    CALL print_word(word_start, word_length);\n    \n    ! Continue from end of word\n    @current_ptr := @word_end;\n  END;\nEND;\n</TAL>\n<Java>\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class BufferScanningExample {\n    public static void main(String[] args) {\n        // Initialize buffer with text\n        String textBuffer = "  This is a   sample text  with extra  spaces  ";\n        \n        System.out.println("Manual scanning implementation:");\n        manualScanning(textBuffer);\n        \n        System.out.println("\nJava-idiomatic solutions:");\n        \n        // Solution 1: Using String.split() with regex\n        System.out.println("\nUsing String.split():");\n        for (String word : textBuffer.trim().split("\\s+")) {\n            System.out.println("Word: " + word);\n        }\n        \n        // Solution 2: Using StringTokenizer\n        System.out.println("\nUsing StringTokenizer:");\n        StringTokenizer tokenizer = new StringTokenizer(textBuffer);\n        while (tokenizer.hasMoreTokens()) {\n            System.out.println("Word: " + tokenizer.nextToken());\n        }\n        \n        // Solution 3: Using Java 8 Streams\n        System.out.println("\nUsing Java 8 Streams:");\n        java.util.Arrays.stream(textBuffer.trim().split("\\s+"))\n            .forEach(word -> System.out.println("Word: " + word));\n    }\n    \n    // Simulating the TAL approach using character-by-character scanning\n    private static void manualScanning(String textBuffer) {\n        int currentPos = 0;\n        int bufferLength = textBuffer.length();\n        \n        while (currentPos < bufferLength) {\n            // Skip leading spaces\n            while (currentPos < bufferLength && textBuffer.charAt(currentPos) == ' ') {\n                currentPos++;\n            }\n            \n            // If we hit the end, exit\n            if (currentPos >= bufferLength) {\n                break;\n            }\n            \n            // Mark start of word\n            int wordStart = currentPos;\n            \n            // Scan until space or end\n            while (currentPos < bufferLength && textBuffer.charAt(currentPos) != ' ') {\n                currentPos++;\n            }\n            \n            // Calculate word length\n            int wordLength = currentPos - wordStart;\n            \n            // Process the word (print it)\n            String word = textBuffer.substring(wordStart, currentPos);\n            System.out.println("Word: " + word);\n        }\n    }\n}\n</Java>"}
