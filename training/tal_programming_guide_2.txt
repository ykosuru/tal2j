EQUIVALENCED VARIABLES 
Equivalencing lets you use more than one name to describe a location in a primary storage area. Variables made equivalent to previously allocated locations do not allocate additional memory space. 
The variables that represent a location can have different data types and byte or word addressing attributes. For example, you can reference an INT(32) variable as two separate words or four separate bytes, or you can use an INT array and a STRING array to access the same buffer. 
This section describes how to declare and access: 
• Equivalenced variables--Variables made equivalent to a previously declared variable. 
• Base-address equivalenced variables--Variables made equivalent to a global, local, or top-of-stack address base. 
The new variable can be a simple variable, pointer, structure, or structure pointer. The previous variable can be a simple variable, a direct array element, pointer, structure, structure pointer, or another equivalenced variable that you previously declared as described in Sections 8 through 12. 
For equivalenced items within structures, see "Redefinitions" in Sect ion 11. 
For equivalenced system global variables, see Section 18, "Privileged Procedures." 
-'182581 AOO 3/85 
12-1 
EQUIVALENCED VARIABLES Equivalenced Variable Declaration 
EQUIVALENCED VARIABLE DECLARATION 
The equivalenced variable declaration associates a new var:Lable with a previously declared variable. 
Equivalenced variables (simple variables, pointers, and structure pointers) are described first, followed by equivalenced structures. 
The syntax for the equivalenced variable declaration is: 
12-2 
4j82581 AOO 3/85 
<type> 
{ . } { <pointer> 
<simple-variable> 
} } } } 
<type> 
{ { { { 
{ 
{ .EXT } { <structure-pointer> ( <referral> ) } } 
= <previous-identifier> [ "[" <index> "]" [ {+I-} <offset> 
{ .EXT } { <structure-pointer> ( <referral> ) } 
{ . } { <pointer> } 
{
[,{ } 
{ <simple-variable> } 
= <previous-identifier> [ "[" <index> "]" [{+ I-} <offset> 
For <structure-pointer>, <type> must be STRING or IN'I'.
For <simple-variable> or <pointer>, <type> is any data type• 
. (period) 
is the indirection symbol for standard addressing. 
. EXT 
is the indirection symbol for extended addressing. 
<structure-pointer> 
is the identifier of a structure pointer to be made equivalent to <previous-identifier>. 
<pointer> 
is the identifier of a pointer to be made equivalent to <previous-identifier>. 
<simple-variable> 
is the identifier of a simple variable to be made equivalent to <previous-identifier>. 
<referral> 
is the identifier of a previously declared structure or structure pointer. 
<previous-identifier> 
is the identifier of a previously declared simple variable, direct array element, pointer, structure, structure pointer~ or equivalenced variable. 
<index> 
is an INT constant that specifies a number of elements of the type declared. <index> is permitted only with direct variables. <index> must end on a word boundary. 
<offset> 
is an INT constant that specifies a word offset. <offset> is permitted with direct or indirect variables. For indirect variables, the offset is from the location of the pointer,
not from the location of the data pointed to. 
~ 82581 AOO 3/85 
12-3 
EQUIVALENCED VARIABLES Equivalenced Variable Declaration 
EQUIVALENCED VARIABLES Equivalenced variable Declaration 
The syntax for the equivalenced structure declaration is: 
STRUCT [ . ] <structure> [ { <referral> ) ] 
= <previous-identifier> [ "[" <index> "]" ] [ {+I-} <offset> ] 
[ <structure-body> ] 
. (period) 
is the indirection symbol for standard addressing. 
<structure> 
is the identifier of a definition or referral structure to be made equivalent to <previous-identifier>. 
<referral> 
is the identifier of a previously declared structure or structure pointer. Its presence means <structure> is a referral structure and <structure-body> cannot be specified. 
<previous-identifier> 
is the name of a previously declared simple variable, direct array element, structure, structure pointer, or equivalenced variable. 
<index> 
is an INT constant that specifies a number of elements of the type declared. <index> is permitted only with direct variables. <index> must end on a word boundary. 
12-4 
"1f' 82581 
AOO 3/85 
<offset> 
is an INT constant that specifies a word offset. <offset> is permitted with direct or indirect variables. For indirect variables, the offset is from the location of the pointer, not from the location of the data pointed to. 
<structure-body> 
is a BEGIN-END construct that contains declarations as described in Section 11. Its presence means <structure> is a definition structure and <referral> cannot be specified. 
Examples of Equivalenced Declarations 
The leftmost box in each diagram represents the previously declared variable to which the new variable is made equivalent. 
1. This example makes an INT variable equivalent to a previous INT variable: 
variable: 
STRING sl := "A";
STRING s2 =sl; sl a I~ s2 
3. This example makes STRING and INT(32) variables equivalent to an INT array: 
-1"82581 AOO 3/85 
INT wordl;
INT word2 =wordl; 
.....__w_o_r_d_l_ __.I ~ I w o r d 2
2. This example makes a STRING variable equivalent to another STRING 
INT i[O:l]; STRING b =i[O]; 
INT(32) d = b; 
i[0J. b[O] b[l] i[l] b[2] b[3] 
EQUIVALENCED VARIABLES Equivalenced Variable Declaration 
12-5 
EQUIVALENCED VARIABLES Equivalenced Variable Declaration 
4. This example makes an pointer equivalent to a direct variable: 
INT dir := 200; INT .ptr = dir; 
G [ 2 0 0 ] [ _ _ _ ___, 
5. This example makes a word-addressed pointer equivalent to another word-addressed pointer of a different type: 
12-6 
INT .ptrl := 200; INT(32) .ptr2 = ptrl; 
.ptr1_ I_ _ 2_o_o_J ~pt~2[ 200
_ _ _ _ , , G [ 2 0 0 l E____, 
6. This example tries to make a byte-addressed pointer equivalent to a word-addressed pointer. Howev~r, the pointers point to different locations, since one pointer contains a word address and the other contains a byte address: 
INT .ptrl := 200; STRING .ptr2 = ptrl; 
7~ For INT variables, indexes and offsets are equivalent: 
INT x[0:5];
INT y x[l]; ! Index INT z = x + 1; !Offset 
Index Offset 
8. For non-INT variables, indexes and offsets are not equivalent: 
INT(32) x;
INT a = x + 1; !Offset INT b = x [1]; !Index 
.x+O 
x+l 
x+2 
x+3 
x(O] 
x(l] 
Offset Index 
Afd132581 AOO 3/85 
EQUIVALENCED VARIABLES Equivalenced Variable Declaration 
9. You can make a variable equivalent to an offset pointer but not to an indexed pointer: 
"182581 AOO 3/85 
INT .pt;
INTa=pt+2,• !Offset pt 
! allowed 
pt+l 
INTb=pt[2]; !Index
! not allowed pt+2 
? 
10. This example tries to make a STRING variable equivalent to an odd-byte array element. The system ignores the index and and 
issues a warning. 
which is not allowed: 
INT a[0:5];
INT b;
INT c[0:5] = a; !Not allowed INT d[0:5] = b; !Not allowed 
12. This example makes a referral structure equivalent to a structure pointer: 
STRING a[O:l]; STRING b = a[l]; 
]_a__o[_]___a_1[__.lj~_ I_b_____. 11. This example tries to make arrays equivalent to other variables, 
STRUCT record (*); BEGIN 
INT name[0:14]; INT address[0:49]; 
END; 
!Declares template structure 
INT .p (record) := %100000; !Declares structure pointer 
STRUCT .empl (record) = p; !Makes new structure equivalent ! to structure pointer "p" 
~I 
a 
12-7 
EQUIVALENCED VARIABLES
Accessing Equivalenced Variables 
Accessing Equivalenced Variables 
You access an equivalenced variable in the same way as any other variable, by specifying its identifier in a statement. 
Examples 
1. This example makes an INT variable equivalent to each word of an INT(32) variable, then accesses the location as an INT variable and as an INT(32) variable: 
INT(32) dbl; INT a = dbl, 
b = a + 1; 
2.. This example makes a STRING variable equivalent to the first of three INT variables, then accesses byte items by indexing the STRING variable: 
12-8 
_ i - - _ d b - 1 _ _- ~ dbl := -lD; !Accesses "dbl" as a doubleword 
t:B 
a := 2 * 2; !Access first
! word of "dbl" 
INT wordl; INT word2; INT word3; 
STRING s = wordl; 
s[3] := O;
IF s[4] > 2 THEN ..•; 
wordl 
word2 
word3 
s[O] s[l] 
s[2] s[3] 
s[4] s[5] 
-'f82581 AOO 3/85 
EQUIVALENCED VARIABLES Accessing Equivalenced Variables 
3. These examples make a pointer equivalent to a direct variable, then accesses them in different ways: 
-'182581 AOO 3/85 
INT dir := 200; INT .ptr = dir; 
d i r l . . . . . _ _ 2 _ 0 _ 0 _ _ _ _ . J I ~ . p t r . _ _ _ _ 2 _ 0 _ 0_ _ _ , G [ 2 0 0 ] I . . . . _ _ _ _ _ _, 
An assignment to the direct variable changes the contents of both the direct variable and the pointer: 
dir := 45; 
dirl.____4_5_____.I ~.ptr____4_5_____, G [ 4 5 ) I.____ _ _ __, 
An assignment to the pointer (using the @symbol) changes the contents of both the direct variable and the pointer: 
@ptr := 66; 
dir1.....__6_6__I. ~.ptr..____6_6____, G[ 66] I.___ _ _ _ __, 
An assignment to the pointer (without the @symbol) changes the contents of only the variable to which the pointer points: 
ptr := 15; 
dir1___6_6___1 ~.ptr.____6_6____. G [ 6 6 ] I . _ _ _ _ 1 5_ _ _ _ , 
..... 
12-9 
EQUIVALENCED VARIABLES
Base-Address Equivalenced Variable Declaration 
BASE-ADDRESS EQUIVALENCED VARIABLE DECLARATION 
Base-address equivalencing lets you declare variables relative to the global, local, and sublocal base addresses. 
Equivalenced variables (simple variables, pointers, and structure pointers) are described first, followed by equivalenced structures. 
The syntax for the base-address equivalenced 
variable declaration is: 
<referral> ) } } } } } } 
[ "[" <index> "]" [ {+I-} <offset> 
<referral> ) } } } } 
12-10 
~ 82581 AOO 3/85 
<type> 
<type> 
{ { { { 
{ 
{ [,{ 
{ .EXT } { <structure-pointer> ( { • } { <pointer> 
<simple-variable> 
<base-address> 
{ .EXT } { <structure-pointer> { • } { <pointer> 
{ <simple-variable> 
= <base-address> [ "[" <index> "]" [ {+I-} <offset> 
} 
} 
For <structure-pointer>, <type> must be STRING or INT.
For <simple-variable> or <pointer>, <type> is any data type. 
. (period) 
is the indirection symbol for standard addressing. 
. EXT 
is the indirection symbol for extended addressing~ 
<structure-pointer> 
<base-address> 
is one of: 
'G' 'L' 'S ' 
Global addressing relative to G[O]
Local addressing relative to L[O] Top-of-stack addressing relative to S[O] 
EQUIVALENCED VARIABLES Base-Address Equivalenced Variable Declaration 
is the identifier of a structure pointer to be made equivalent to <base-address>. 
<pointer> 
is the identifier of a pointer to be made equivalent to <base-address>. 
<simple-variable> 
is the identifier of a simple variable to be made equivalent to <base-address>. 
<referral> 
is the identifier of a previously declared structure or structure pointer. 
<index> and <offset> 
are equivalent INT values giving a location in the following ranges: 
'G' addressing: [0:255] 'L' addressing: [-31:127] 'S' addressing: [-31:0] 
/182581 AOO 3/85 
12-11 
EQUIVALENCED VARIABLES
Base-Address Equivalenced Variable Declaration 
The syntax for the base-address equivalenced structure declaration is: 
STRUCT [ • ] <structure> [ { <referral> ) ] 
12-12 
[ <structure-body> ] 
. (period) 
= <base-address> [ "[" <index> "]" ] [ {+I-} <offset> ] 
is the indirection symbol for standard addressing. 
<structure> 
is the identifier of a definition or referral structure to be made equivalent to <base-address>. 
<referral> 
is the identifier of a previously declared structure or structure pointer. Its presence means <structure> is a referral structure and <structure-body> cannot be specified. 
<base-address> 
is one of: 
'G' 'L ' 'S ' 
Global addressing relative to G[O]
Local addressing relative to L[O] Top-of-stack addressing relative to S[O] 
<index> and <offset> 
are equivalent INT values giving a location in the following ranges: 
'G' addressing: (0:255] 'L' addressing: (-31:127] 'S' addressing: (-31:0] 
"182581 AOO 3/85 
,,, 
<structure-body> 
EQUIVALENCED VARIABLES Base-Address Equivalenced Variable Declaration 
is a BEGIN-END construct that contains declarations as described in Section 11. Its presence means <structure> is a definition structure and <referral> cannot be specified. 
Example 
1. This example makes an INT simple variable equivalent to 'L' relative addressing: 
_ ____,, ~ l....___v_ar____, For another example of base-address equivalencing, see the ARMTRAP 
procedure in the System Procedure Calls Reference Manual. 
"1'82581 AOO 3/85 
12-13 
INT var= 'L'[5]; L[5] 
SECTION 13 
EXPRESSIONS 
This section gives information about expressions: 
• Operators--Arithmetic and conditional (relational and boolean) 
• Precedence of Operators--The order in which the system evaluates operators in an expression 
• Arithmetic Expressions--General form, assignment form, CASE form, IF-THEN-ELSE form 
• Conditional Expressions--General form and group comparison form 
An exeression is a combination of operands and operators that make up an arithmetic or conditional expression. The operands can be data or constants. The operators specify an arithmetic or conditional operation on the operands. Expressions can be type INT, INT(32), FIXED, REAL, or REAL(64), but not type STRING. The system treats STRING operands as 16-bit quantities. 
An arithmetic expression specifies a rule (formula) for computing a numeric value. It consists of one or more operands and arithmetic operators such as: 
3+5 
A conditional expression specifies a rule for establishing the relationship between values and results in a true or false state. It consists of one or more conditions and conditional operators such as: 
vary > 5 
..-, 82581 AOO 3/85 
13-1 
EXPRESSIONS Arithmetic Operators 
OPERATORS 
An operator is a reserved word or a symbol that directs TAL to perform an arithmetic or conditional {relational or boolean) operation on values in the program. 
Arithmetic Operators 
Arithmetic operators provide signed arithmetic, unsigned arithmetic, and logical operations. You can mix signed and unsigned arithmetic and logical operations in an expression. 
Signed Arithmetic Operators 
Signed arithmetic operators are +, -, *, and /. They can operate on operands of any data type. All operands in an expression must be of the same type, except that an INT expression can include INT and STRING operands. When the system evaluates an INT expression, it right justifies STRING operands in word units and treats them as 16-bit quantities. 
INT expressions produce INT results, even if they contain S1rRING operands. Expressions of other types produce results of the same data type as their operands. For example, expressions that contain FIXED operands produce FIXED results, and expressions that contain REAL(64) operands produce REAL(64) results. 
Signed arithmetic operations affect the condition code and carry indicators. The overflow indicator is set when you divide by 0 or 
when a result exceeds the bits allowed by the operand type {INT, 15 bits; INT{32) and REAL, 31 bits; REAL(64) and FIXED, 63 bits). If an overflow occurs, the results will have unpredictable values. 
Examples of signed arithmetic are: 
13-2 
~ 82581 AOO 3/85 
wordl * word2 + wordl word2 I wordl
doublel + double2 bytel + byte2 
wordl + bytel 
!INT operands produce INT result
!INT operands produce INT result
!INT(32) operands produce INT{32) result !STRING operands produce INT result
!INT and STRING operands produce INT result 
Unsigned Arithmetic Operators 
Unsigned arithmetic operators are '+', '-', '*', '/', and '\'. They can operate on operands of certain data types, as follows: 
• Unsigned add and subtract allow STRING or INT operands in an expression and produce INT results. 
These operations do not set the overflow indicator, but do affect the condition code and carry indicators. 
• Unsigned multiplication allows STRING or INT operands and produces INT(32) results. 
• An unsigned division operation or an unsigned modulo operation (which returns the remainder) requires an INT(32) dividend and an INT divisor that produces an INT quotient. 
If the quotient exceeds 16 bits, an overflow condition occurs and the results will have unpredictable values. 
For example, the modulo operation "1000000 '\' 2" (which should result in a remainder of 0) causes an overflow because the quotient (50000) exceeds 16 bits. 
Typically, you use unsigned arithmetic on operands with values in the range 0 through 65,535. An example is pointer variables that contain standard addresses. 
Examples of unsigned arithmetic are: 
wordl '+' word2 wordl ' ' bytel wordl '*' bytel dbword '/' wordl dbword '\' wordl 
!Unsigned addition produces INT result
!Unsigned subtraction produces INT result !Unsigned multiplication produces INT(32) result !Unsigned division produces INT result
!Unsigned mod division produces INT result 
-'182581 AOO 3/85 
EXPRESSIONS Arithmetic Operators 
13-- 3 
EXPRESSIONS Arithmetic Operators 
Logical Operators 
The LOR, LAND, and XOR operators perform bit-by-bit operations on INT and STRING operands only. They return 16-bit results as follows: 
02erator 
LOR
(Logical OR) 
LAND
(Logical AND) 
XOR
(Exclusive OR) 
Truth Table 
Exam2le 
10 LOR 12 = :.-4 
10 1010 12 1100 
14 1110 
10 LAND 12 = 8 
1 
0 
1 0 
~ 
1 0 
0 
0 
1 0 
0 
1r::10 1010 12 1100 
1r::10 1010 12 1100 
0 
0 
The logical operators set the condition code indicator. 
Summary of Arithmetic Operators 
Table 13-1 summarizes the arithmetic operators and the data. types of operands on which each can operate. 
TAL does not provide automatic type conversions on operands: instead, it provides built-in type-transfer functions for converting an operand from one type into another. (See Section 17.) 
13-4 
Afj82581 AOO 3/85 
8 1000 
10XOR12= 6 
6 0110 
Operator Function 
*Data Type of Operand 
**STRING INT INT(32) FIXED REAL REAL(64) 
+ Signed 
Signed 
* Signed 
I Signed 
Addition 
Subtraction 
Multiplication 
Division 
•••••• •••••• •••••• •••••• 
•• 
EXPRESSIONS Arithmetic Operators 
Table 13-1. Arithmetic Operators and Operand Types 
'+' Unsigned Addition 
'-' Unsigned Subtraction • 
• 
'*' Unsigned M ultiplication 
'/' Unsigned Divison 
'\' Unsigned Modulo Division (remainder) 
LOR Logical OR 
LAND Logical AND 
XOR Exclusive OR 
• • (See Note 1) • • • (SeeNote2) 
• • • (See Note 2) •• 
•• •• 
* Except as noted, operand types in an expression must match and the expression yields results of the same type as its operands. To convert an operand type, use a type-transfer standard function described in Section 17. 
**The system treats STRING operands as 16-bit quantities; there is no STRING expression. INT expressions can have STRING or INT operands, but always yield INT results. 
Note 1: Unsigned multiplication always yields an INT(32) result. 
Note 2: Unsigned division and modulo operations require an INT(32) dividend and an INT divisor that produce an INT quotient. See also "Unsigned Arithmetic Operators" in this section. 
Af'82581 AOO 3/85 
13-5 
gXPRESSIONS Arithmetic Operators 
Scaling of FIXED Operands 
FIXED operands in an arithmetic expression need not have the same <fpoint> value. The system makes adjustments as follows: 
• In addition or subtraction, the system scales the smaller <fpoint> up to match the larger <fpoint>. The <fpoint> of the result matches the larger <fpoint>. For example, the system scales the smaller <fpoint> in "3.005F + 6.0lF" up by a factor of one, and the result is 9.015F. 
• In multiplication, the <fpoint> of the result is the sum of the <fpoint> values of the two operands. For example, "3.091F * 2.56F" results in the FIXED(5) value 7.91296F. 
•, 
In division, the <fpoint> of the result is the <fpoint> of the dividend minus the <fpoint> of the divisor. (Some precision is 
lost.) For example, "4.0SF I 2.lOF" results in the FIXED(O) value of 1. 
To retain precision when dividing operands having nonzero <fpoint> values, use the $SCALE function to scale up the <fpoint> of the dividend by a factor equal to the <fpoint> of the divisor. $SCALE 
is described in Section 17, "Standard Functions." 
The following example shows scaling of FIXED operands having different <fpoint> values and scaling of the result to match the variable to which it is assigned: 
13-6 
FIXED a: FIXED(2) b; FIXED(-1) c: 
a := 2.015F * (b + c): 
!Data declarations 
...- "c" is scaled up by a factor of 3 to match "b" 
...._ Result of multiplication is an implied <fpoint> of 5 
.-- Result of expression is scaled down by 5 to match "a", with some 
loss of precision 
3 
a ..,.._ _ _ _.I 
5 
down 5 
I 
up 3 
..-, 82581 AOO 3/85 
Conditional Operators 
Conditional operators are either relational or boolean. You can combine them with conditions to form conditional expressions. The result of a conditional expression is a true or false state. 
You usually use conditional expressions to direct program execution. For example, in an IF-THEN-ELSE statement, if the IF condition is
true, the THEN clause executes, or if it is false, the ELSE clause executes. Conditions are described under "Conditional Expressions" in this section. 
Relational Operators 
Signed relational operators are <, =, >, <=, >=, <>, and unsigned relational operators are '<', '=' '>' , '<=' , '>=' , '<>' , as defined in Table 13-2. They perform: 
• Signed comparison of two INT, INT(32), FIXED, REAL, or REAL(64) operands 
• Unsigned comparison of two INT operands 
The operands in a relational expression must have the same data type, except that an INT expression can have STRING and INT operands. 
Relational operations 
The following example unsigned comparisons: 
'<'cTHEN 
<cTHEN 
<> c THEN IF < THEN 
'<>' c THEN IF > THEN 
set the condition code indicator. 
controls program execution based on signed and 
INT a c x 
IF a 
IF a 
IF a 
IF a 
-2, 3, := 271; 
!Value = %177776 !Value = %000003 
!False; "x" still contains 271 !True; "x" is assigned 313 
!True, but this is an arithmetic ! comparison; since -2 < 3'
! CCL is set 
!True; this is a logical
! comparison; since %177776 '>' %3 ! CCG is set 
"''f 82581 AOO 
13-7 
.- 
.- := 
3/85 
x := 314; 
x := 313; 
x := 314; 
x := 315; 
EXPRESSIONS Conditional Operators 
EXPRESSIONS Relational Operators 
Table 13-2. Relational Operators and Operand Type!s 
*Data Type of Operand 
Operator Function **STRING INT INT(32) FIXED REAL REAL(64) 
< SignedLessThan • • • • • • 
= SignedEqualTo • • • • • • 
> 
<= 
>= 
<> 
'<' 
'>' 
'<=' 
'>=' 
'<>' 
Signed Greater Than 
Signed Less
Than or Equal to 
Signed Greater Than or Equal to 
Signed Not Equal to 
Unsigned Less Than 
Unsigned Equal to 
Unsigned Greater Than 
Unsigned Less Than or Equal to 
Unsigned Greater Than or Equal to 
Unsigned Not Equal to 
•••• • 
•••• • 
•••• • • • • • •· • ••
•• 
•• 
•• 
•• 
•• 
* You cannot mix operand types in an expression except STRING and INT. To convert an operand type, use a type-transfer standard function described in Section 17. 
**The system treats STRING operands as 16-bit quantities. INT expressions can contain STRING and INT operands. 
13-8 
"'it 82581 AOO 3/85 
Boolean Operators 
Boolean operators have the following meanings: 
• NOT tests a condition for a false state. 
•	OR produces a true state if either adjacent condition is true. 
•	AND produces a true state if both adjacent conditions are true. 
Conditions connected by AND are evaluated from left to right until a false state occurs. The second condition is evaluated only if the first condition is true. 
A condition is one or more syntactic elements that represent a single state. It can consist of a relational operator, a relational expression, a conditional expression, or an arithmetic expression, as described under "Conditional Expressions" beginning on page 13-18. 
If a condition is an arithmetic expression, it must evaluate to an tNT value. Thus, the operands in the condition must be type STRING or 
INT. If the arithmetic expression evaluates to a value of any other type, use a relational expression instead. 
Boolean operations set the condition code indicator. 
Examples of boolean operators are: 
1. In this example, the conditions are arithmetic expressions, so "a" and "b" must be type STRING or INT. The expression is true if either condition is true; that is, if "a" or "b" contains a nonzero value: 
INT a, b:
IF a OR b THEN . . • 
2. In this example, the conditions are relational expressions, so "a" and "b" can be any data type. The expression is true if either condition is true; that is, if "a" or "b" contains a nonzero value: 
FIXED a, b:
IF a<>OF OR b<>OF THEN 
3. The conditions in this expression are arithmetic expressions that evaluate to INT values. The expression is true if either "a" is false or both "b" and "c" are true: 
STRING a, b, c; IFNOTaORbANDc . . • 
Table 13-3 summarizes boolean operators and the data types of operands on which they can operate. 
-'f82581 AOO 3/85 
EXPRESSIONS Boolean Operators 
13-9 
EXPRESSIONS
Precedence of Operators 
Table 13-3. Boolean Operators and Operand Types 
Operator Function 
AND Logical Conjunction 
OR Logical Disjunction 
NOT Logical Negation 
*STRING INT INT(32) 
•• 
•• 
•• 
FIXED REAL 
REAL(64) 
* The system treats STRING operands as 16-bit quantities. An expression can contain INT and STRING operands. 
**This table applies to operands in arithmetic expressions. For types of operands allowed in relational expressions, see Table 13-2. 
Precedence of Operators 
TAL evaluates operations in expressions from left to right according to standard rules of precedence. Table 13-4 shows the leve?l of 
precedence for each operator, from highest (0) to lowest (9). 
To override the standard order of operations, place parentheses around the operation to be performed first. Examples are: 
13-10 
c~* (a + b) Result 
(a OR b) AND c 
III 
I 
Result 
Data Type of Operand** 
A~ 32581 AOO 3/85 
Operator 
@ 
< ••• > 
< ••• > 
<< >> 
'<<' '>>' 
* 
I 
'*' 
'/' '\' 
+ 
'+' '-' LOR 
LAND XOR 
< 
= > <= >= <> 
'< ' '= ' '> ' '<=' '>=' '< > ' 
NOT AND OR 
.- .- 
Operation 
Indirection
Address of Identifier 
Bit Extraction Bit Deposit 
Bit Shift Bit Shift Bit Shift Bit Shift 
Signed Multiplication Signed Division 
Unsigned Multiplication Unsigned Division Unsigned Modulo Division 
Signed Addition Signed Subtraction Unsigned Addition Unsigned Subtraction Logical OR 
Logical AND Exclusive OR 
Signed Less Than
Signed Equal to
Signed Greater Than
Signed Less Than or Equal to Signed Greater Than or Equal to Signed Not Equal to 
Order of
Precedence Section 
0 10 
1.	0  10 
2.	1  14 
1.	1  14 
2.	2  14 
2 14 2 14 
2.	2  14 
3.	3  13 
3 13 
3 13 3 13 
3.	3  13 
4.	4  13 
4 13 4 13 4 13 4 13 4 13 
4.	4  13 
5.	5  13 
5 13 5 13 5 13 5 13 5 13 5 13 5 13 5 13 5 13 5 13 
5.	5  13 
6.	6  13 
7.	7  13 
8.	8  13 
9.	9  15 
"'182581 AOO 3/85 
EXPRESSIONS Precedence of Operators 
Table 13-4. Precedence of Operators 
Less Than Equal to Greater Than 
Unsigned
Unsigned
Unsigned
Unsigned Less Than or Equal to Unsigned Greater Than or Equal to 
Unsigned Not Equal 
Boolean Negation Boolean Conjunction Boolean Disjunction 
Assignment 
to 
13-11 
EXPRESSIONS
Arithmetic Expressions 
ARITHMETIC EXPRESSIONS 
An arithmetic expression is a rule for computing a single numeric value of a specific data type. It has a general, assignment, CASE, or 
IF-THEN-ELSE f o r m . 
General Form 
The general form of an arithmetic expression is: 
[ + ] <primary> [ [ <arith-operator> <primary> ] ••• ] [-] 
+- 
<primary> 
is one or more items that represent a single value. <primary> can consist of the following as described under "Primaries" in this section: 
Constant
Variable
Function reference Bit shift
Bit extraction 
( <arithmetic-expression> Code space item 
<arith-operator> 
is an arithmetic operator: signed (+, -, *, /); unsigned ('+', '-', '*', '/', '\'); logical (LOR, LAND, XOR). 
13-12 
are unary plus and minus, indicating the sign of the leftmost <primary>. Plus is the default sign. 
"'82581 AOO 3/85 
Examples of arithmetic expressions are: 
varyl
- varyl
+ varyl * 2 varyl + vary2 varyl * (-vary2) 
Primaries 
<primary> only
- <primary>
+ <primary> <arith-operator> <primary> <primary> <arith-operator> <primary> <primary> <arith-operator> <primary> 
A <primary> is one or more syntactic elements that represent a single value. It can be any of the following: 
•	Constant--A character string or numeric constant as described in Section 4 
•	Variable--A direct or indirect variable as described in Sections 8 through 12 for simple variables, arrays, pointers, structures, substructures, structure data items and equivalenced variables 
(with or without an indirection symbol (. or@) and index) 
•	Function reference--A reference to a procedure that returns a value, including standard functions listed in Section 17. 
• Bit shift or bit extraction--As described in Section 14. 
• Arithmetic expression--The general, assignment, CASE, or IF-THEN-ELSE form described in this section, enclosed in 
parentheses. 
• Code space item--A procedure, subprocedure, or label name prefixed with the @symbol or a read-only array optionally prefixed with the @ symbol, with or without an index. 
Examples of primaries are: 
10 !Constant vary[lO] !Variable 
( IF vary THEN 1 ELSE 2 ) !(<arithmetic-expression> 
4J82581 AOO 3/85 
13-13 
EXPRESSIONS Arithmetic Expressions 
EXPRESSIONS Assignment Form 
Assignment Form 
The assignment form of arithmetic expression assigns the value of an expression to a variable. 
The syntax for the assignment form is: 
<variable> := <expression> 
<variable> 
is a declared data variable. (It can have an optional bit deposit field). 
<expression> 
is an arithmetic or conditional expression that represents a value of the same type as <variable>. This value is the value of the assignment expression form. 
·---·--------' 
Examples 
1. This example increments "a"; as long as "a + l" is not 0, the condition is true and the THEN clause is executed: 
IF (a := a + 1) THEN . 
2. This example shows the assignment form used as an index; "a" is incremented and accesses the next array element: 
IF array[a := a + l] <> 0 THEN 
3. This example mixes the assignment form with a relational form; it assigns the value of "b" to "a", then checks for equality with 0: 
I F ( a : = b ) = 0 THEN . . . 
13-14 
Aj82581 AOO 3/85 
CASE Form 
The CASE form of arithmetic expression selects one of several expressions for assignment to a variable. 
The syntax for the CASE form is: 
CASE <index> OF BEGIN 
<expression> <expression> 
END 
<index> 
is an INT arithmetic expression that selects the <expression> to evaluate. 
<expression> 
is an arithmetic or conditional expression. 
OTHERWISE <expression> 
indicates the expression to evaluate if <index> does not select an expression within the index range 0 through <n>. 
If you omit the OTHERWISE clause and an out-of-range case occurs, results are unpredictable. 
The CASE expression form resembles the CASE statement except that: 
• It selects one of several expressions instead of statements 
• The selected expression must be assigned to a variable 
-'1' 82581 AOO 3/85 
!For <index> = 0 !For <index> = 1 
!For <index> = n [ OTHERWISE <expression> ; ] 
<expression> ; 
EXPRESSIONS CASE Form 
13-15 
gXPRESSIONS CASE Form 
gxample 
This example selects and assigns the value resulting from one of several expressions and assigns it to a variable: 
13-16 
""t· 82581 AOO 3/85 
i :=CASEaOF BEGIN 
b;
c;
d; OTHERWISE 
END; 
- 1 ; 
!If the value of "a" is 0, the value of "b" is assigned to "i". !If the value of "a" is 1, the value of "c" is assigned to "i". !If the value of "a" is 2, the value of "d" is assigned to "i". !If "a" has any other value, the value of -1 is assigned to "i". 
IF-THEN-ELSE Form 
The IF-THEN-ELSE form of arithmetic expression conditionally selects one of two expressions, usually for assignment to a variable. 
The syntax of the IF-THEN-ELSE form is: 
IF <conditional-expression> THEN <expression> ELSE <expression> 
<conditional-expression> 
is evaluated to determine the <expression> to compute. 
<expression> 
is an arithmetic or conditional expression. 
If <conditional-expression> is true, the THEN clause is computed; otherwise, the ELSE clause is computed. The IF-THEN-ELSE expression resembles the IF-THEN-ELSE statement except that: 
• Both the THEN and ELSE clauses are required 
• The THEN and ELSE clauses contain expressions, not statements 
• The IF-THEN-ELSE form is typically part of an assignment statement 
Examples 
1. This example assigns one of two arithmetic expressions: 
var := IF length > 0 THEN 10 ELSE 20; 
2. You can mix this form, enclosed in parentheses, with other forms: 
vary * index + (IF index> limit THEN vary * 2 ELSE vary * 3) 
4°t82581 AOO 3/85 
13-17 
EXPRESSIONS IF-THEN-ELSE Form 
EXPRESSIONS
Conditional Expressions 
CONDITIONAL EXPRESSIONS 
A conditional expression specifies a rule for establishing the relationship between values. It has a general form and a group comparison form. 
General Form 
The general form of conditional expression is: 
[ NOT ] <condition> [ [ { AND } [ NOT ] <condition> ] ~ .. ] {OR } 
<condition> 
is one or more syntactic elements that represent a single state. <condition> can consist of the following as described under "Conditions" in this section: 
Relational operator Arithmetic expression Relational expression 
( <conditional-expression> Group comparison form 
AND, OR, and NOT are boolean operators: 
AND produces a true state if both <conditions> are true. OR produces a true state if either <condition> is true. NOT tests <condition> for a false state. 
Examples of conditional expressions are: 
13-18 
4~82581 AOO 
3 / 8 5 
a
NOT a
a OR
a AND b
a AND NOT b OR c 
!<condition>
!NOT <condition>
~<condition> OR < c o n d i t i o n > !<condition> AND <condition> !<condition> AND [NOT] <condition> 
b 
Conditions 
A <condition> is one of the following: 
•	Relational operator--An operator (<, >, <=, >=, <>, '<' , '=' , '>', '<=', '>=', or '<>') that tests a condition code (see "Testing 
Hardware Indicators" in this section) 
•	Arithmetic expression--general, assignment, CASE, or IF-THEN-ELSE form discussed previously in this section 
Any arithmetic expression used as a condition must evaluate to an INT value. If it evaluates to a value of any other type, use a relational expression. (See examples of conditions below.) 
The condition is true if the value of the arithmetic expression contains a nonzero value. 
•	Relational expression--Two general arithmetic expressions connected by a relational operator 
•	Conditional expression--The general form enclosed in parentheses 
•	Group comparison form of conditional expression--See "Group Comparison Form" in this section 
Examples of conditions are: 
<condition> Example 
Description 
Expression is true if condition code setting is CCL 
Expression is true if condition "a" contains nonzero value: "a" must be type INT or STRING 
"a" is type FIXED: expression is true if "a" contains a nonzero value 
Expression is true if "a" equals "b" 
Expression is true if both "b" and "c" are false: the parenthesized condition evaluates first, then NOT is applied 
Relational operator 
Arithmetic expression 
Relational expression 
(<conditional- expression>) 
IF < THEN 
IF a THEN ... 
IF a <> OF THEN 
IF a=b THEN ... 
IF NOT (b OR c) THEN ... 
..,, 82581 AOO 3/85 
EXPRESSIONS Conditional Expressions 
13-19 
E:XPRESS IONS
Conditional Expressions 
Testing Hardware Indicators 
The state of hardware indicators (condition code, carry, and overflow) are affected by arithmetic and conditional operations and most file system calls. If you are checking a hardware indicator, do so before another arithmetic operation occurs in the program. 
The condition code setting indicates if the result of an operation is a negative value (CCL), a 0 (CCE), or a positive value (CCG). After an assignment statement, the indicator reflects the new value in the variable. To check this indicator, use a relational operator in a conditional expression, as in the example "IF < THEN . . • . " 
The carrf setting indicates if a carry out of bit 0 occurred. To check this indicator, use the standard function $CARRY in a conditional expression, as in the example "IF $CARRY THEN .. 
The overflow setting indicates if a division by 0 occurred or if the result of a signed arithmetic operation exceeds the number of bits allowed by the data type. An overflow causes an interrupt to the operating system overflow trap handler. To check the overflow indicator, turn off the overflow trap bit (bit 8) in the ENV register, then use the standard function $OVERFLOW in a conditional expression, as in the example "IF NOT $OVERFLOW THEN • • . . " 
Assigning Conditional Expressions 
Usually conditional expressions direct program execution without returning a value as shown in previous examples. However, if you assign a conditional expression to a variable, TAL returns a -1 for the true state and a 0 for the false state. 
1. This example assigns the result of a comparison to a variable: 
INT neg := -1; !Value = %177777 INT pos := 1; !Value = %000001 INT result; 
result := neg < pos; !Signed comparison produces -1 result := neg '<' pos; !Unsigned comparison produces 0 
2. This example produces a -1 if either "x" or "y" is a ncnzero value (true), or a 0 if both "x" and "y" are zeros (false): 
INT x, y, answer;
answer := x OR y; !Assigns -1 or 0 to "answer" 
13-20 
-''f 82581 AOO 3/85 
" 
Group Comparison Form 
The group comparison form of conditional expression performs an unsigned comparison of a group of contiguous bytes or words with another group of contiguous bytes or words or with a constant. 
The syntax for the group comparison form is: 
<varl> <rela-operator> { <var2> FOR <count> [ -> <next-addr> ] } { <constant> } 
<varl> 
is the name of a variable, with or without an index, to compare to <var2> or <constant>. <varl> can be a simple variable, array, pointer, structure, substructure, structure item, or structure pointer, but not a read-only array. 
<rela-operator> 
is a relational operator (<, =, >, <=, >=, <>, '<', '=' '>', '<=', '>=', '<>') as defined in Table 13-2. 
<var2> 
is the name of a variable, with or without an index, to which <varl> is compared. It can be a simple variable, array, read-only array, pointer, structure, substructure, structure 
item, or structure pointer. 
<count> 
is a positive INT arithmetic expression of the general form that specifies the number of bytes or words in <var2> to compare. <count> is in bytes if <var2> is a STRING variable or pointer or a substructure. It is in words if <var2> is a non-STRING pointer or variable or a structure. 
"'f82581 AOO 3/85 
EXPRESSIONS Group Comparison Form 
13-21 
EXPRESSIONS
Group Comparison Form 
<next-addr> 
is a variable to contain the address of the first byte or word in <varl> that does not match the corresponding byte or word in <var2>. The address returned is: 
•	a 32-bit byte address if either <varl> or <var2> has an extended address 
•	a 16-bit byte address if <varl> and <var2> have standard byte addresses 
•	a 16-bit word address if <varl> and <var2> have standard word addresses 
<constant> 
is a numeric or character string constant or a constant list to which <varl> is compared. 
The system treats the elements being compared as unsigned values. After a comparison, the condition code setting is: 
< (CCL) if <varl> '<' <var2> = (CCE) if <varl> = <var2> > (CCG) if <varl> '>' <var2> 
The following rules apply: 
• If neither <varl> or <var2> are extended, both must have 16-bit byte addresses or both must have 16-bit word addresses. 
• If <varl> and <var2> are word addressed, they can be different data types. The number of elements compared depends on the data type of <var2>. 
• You can compare byte-addressed data only with byte-addressed data or with constants. However, you can compare data pointed to by an extended STRING pointer with data of any type. 
For INT(32) or FIXED variables, the system performs a word :omparison, and <next-addr> might not point to an element boundary. 
13-22 
-'1 E12581 AOO 3/85 
Examples 
1. The following example compares two arrays: 
2. This example compares an array to a constant list: 
IF fileAname = [ "$RECEIVE" ' 8 * [" "]] THEN .
3. This example uses an arithmetic expression for <count>: 
IF inAarray <> compareAmask FOR (2 * someAvary I 3) THEN 
4. The following example is a group comparison using the optional <next-addr> variable: 
INT .sAarray (0:11] := "$SYSTEM SYSTEM MYFILE .dAarray (0:11] := "$SYSTEM USER MYFILE .pointer; 
" " 
The comparison stops with element [4]; "pointer" contains the address of "dAarray[4]", as follows: 
012345•• sAarray ---> $SYSTEM SYSTEM MYFILE dAarray ---> $SYSTEM USER MYFILE 
You can then use the address in "pointer" to determine the number of array elements that matched: 
n := @pointer '-' @dAarray; !"n" gets 4 (fifth element) 
5. These examples mix group comparisons with other conditions: 
IF length > 0 AND name = user FOR 8 AND NOT abort THEN, .
IF (file ="TERM" OR file ="term") AND mode = 5 THEN .•. 
6. This example compares two arrays then tests the condition code setting to see if the element in "dAarray" that stopped the comparison is less than the corresponding element in "sAarray": 
IF dAarray = sAarray FOR 10 -> @pointer THEN 
-'1f 82581 
AOO 3/85 
IF dAarray = sAarray FOR 12 -> @pointer THEN . . . 
BEGIN
!Do something 
END ELSE 
IJ:t' < THEN
!Do something else 
!They matched 
!"pointer" points to element of
! "dAarray" that is less than the
! corresponding element of "sAarray" 
EXPRESSIONS Group Comparison Form 
13-23 
SECTION 14 
BIT OPERATIONS 
TAL allows you to access bit fields of arbitrary size and location. You can access individual bits or groups of bits to perform the following operations: 
• Bit extraction--Accesses a bit field 
• Bit deposit--Assigns a value to a bit field 
• Bit shift--Shifts a bit field to the left or right 
For information on the precedence of bit operations, see Table 13-4 in Section 13, "Expressions." 
-'182581 AOO 3/85 
14-1 
BIT OPERATIONS Bit Extraction 
BIT EXTRACTION 
Bit extraction lets you access individual bits or groups of bits. 
The syntax for the bit extraction form is: 
<primary> . "/" <left-bit> [ <right-bit> ] ">" 
<primary> 
is as described in Section 13 under "Arithmetic Expressions," except that it must be a STRING or INT value. Bit extraction does not alter <primary>. 
<left-bit> 
is an INT constant specifying the left bit of the bit field. 
If <primary> is type STRING, bit <8> is the leftmost bit you can extract, because the system right justifies STRING values as if they were 16-bit quantities. 
<right-bit> 
is an INT constant specifying the right bit of the bit field. <right-bit> must be equal to or greater than <left-bit>. 
Examples of Bit Extractions 
1. The followi~g example shows an assignment where the bits are extracted from an array element: 
LITERAL len = 8;
INT vary;
INT array[O:len - 1] 
vary := array[8].<8:15>; 
14-2 
_.,.'f 82581 AOO 3/85 
BIT OPERATIONS Bit Extraction 
2. The following example shows an assignment where bits are extracted from an arithmetic expression. Two numbers are added together,
and bits <4> through <7> of the total are assigned to "result". 
INT result;
INT numl := 51; INT num2 := 28; 
result := (numl + num2).<4:7>; 
3. The following example shows bit extraction used in a conditional expression. It checks bits <O> through <7> for "A": 
INT word; 
IF word.<0:7> = "A" THEN 
4. The following example shows bit extraction used in a conditional expression. It checks bit <15> for a nonzero value: 
STRING var; 
IF var.<15> THEN ... 
"'f82581 AOO 3/85 
14-3 
BIT OPERATIONS Bit Deposit 
BIT DEPOSIT 
Bit deposit lets you assign a value to an individual bit or a group of bits using an assignment statement. 
The syntax for the bit deposit form is: 
<variable> . "<" <left-bit> [ <right-bit> ] ">" 
14-4 
<variable> 
is a STRING or INT variable. 
<left-bit> 
is an INT constant specifying the left bit of the bit field. For STRING variables, the leftmost bit you can specify is <8>. 
<right-bit> 
is an INT constant specifying the right bit of the bit field. <right-bit> must be equal to or greater than <left-bit>. 
<expression> 
is an INT arithmetic or conditional expression. 
The bit deposit field is on the left side of the assignment operator (:=). The bit deposit operation changes only the bit deposit field. If the value on the right side has more bits than the bit deposit field, the system ignores the excess high-order bits when making the 
assignment. 
:= <expression> 
Ap82581 AOO 3/85 
Examples of Bit Deposit 
1. The following example replaces bits <10> and <11> with zeros: 
INT old := -1: !"old" = 1111111111111111 old.<10:11> := O: !"old" = 1111111111001111 
2. This example sets bit <8>, the leftmost bit of "strng", to 0: 
STRING strng: 
strng.<8> := O: 
3. In this example, the value %577 is too large to fit in bits <7:12> of "vary". The system truncates %577 to %77 before performing the bit deposit: 
INT vary := %125252: !"vary" = 1010101010101010 
vary.<7:12> := %577: !%577 = 0000000101111111 
II 
!"vary" = 1010101111111010 
4. This example replaces bits <7:8> of "new" with bits <8:9> of "old": 
AJ182581 AOO 3/85 
INT new := -1: INT old := O: 
new.<7:8> := old.<8:9>: 
!"new" = 1111111111111111 !"old" = 0000000000000000 
II 
!"new" = 1111111001111111 
B I T OPERATIONS Bit Deposit 
14-5 
lBIT OPERATIONS JBit Shift 
BIT SHIFT 
The bit-shift operation shifts a bit field a specified number of positions to the left or right. 
The syntax for the bit-shift form is: 
<primary> <shift-operator> <positions> 
<primary> 
is as described in Section 13 under "Arithmetic Expressions," except that it must be type STRING, INT, or INT(32). The system treats STRING variables as 16-bit quantities. For types STRING and INT, the shift occurs on one word; for type INT(32), the shift occurs on two words. Shifts do not alter <primary>. 
<shift-operator> 
is an operator shown in Table 14-1. 
<positions> 
is an INT <primary> indicating the number of bit positions to shift the bit field. The system uses <positions> mod %400. 
The following usage considerations apply: 
• The bit shift operation sets the condition code indicator. 
•• To multiply by powers of two, shift the field one position to the left for each power of 2. 
• To divide by powers of two, shift the field one positio~ to the right for each power of 2. 
• To convert a word address to a byte address, use an unsigned shift operator. 
14-6 
1J82581 AOO 3/85 
vacated bits from 
Initial value 
'>>' 2 
3. This example of a vacated bits from 
Initial value 
<< 1 
4. This example of a
the vacated bits from the left: 
"f82581 AOO 3/85 
14-7 
Table 14-1. Bit-Shift Operators 
Operator 
'<<' 
'>>' 
<< 
>> 
Examples 
1. This
vacated bits from the right: 
Initial value = 0 010 111 010 101 000 
II 
'<<' 2 = 1 011 101 010 100 000 
2. This example of an unsigned right shift shows how zeros fill the 
Function 
Unsigned left shift through bit <O> 
Unsigned right shift 
Signed left shift through bit <1> 
Signed right shift 
of Bit Shifts 
Result 
Zeros right 
Zeros 
fill vacated bits from the 
fill vacated bits from the left 
Sign bit (bit <0>) unchanged; zeros fill vacated bits from the right 
Sign bit (bit <0>) unchanged; sign bit fills vacated bits from the left 
example of an unsigned left shift shows how zeros fill the 
the left: 
1 111 111 010 101 000 
\\ =0011111110101010 
signed left shift shows how zeros fill the
the right, while the sign bit remains the same: 
= 1 011 101 010 100 000 II 1 111 010 101 000 000 
Initial value = 1 111 010 101 000 000 
\\ \ >> 3 = 1 111 111 010 101 000 
signed right shift shows how the sign bit fills 
BIT OPERATIONS Bit Shift 
B I T OPERATIONS Bit Shift 
5. This example shows multiplication and division by powers of two: 
a := b << a:=b<<2. 
' a :=b>> 3: 
a:=b>>4. ' a:=b<<5: 
a:=b>>6: 
Multiply by 2 Multiply by 4 Divide by 8 Divide by 16 Multiply by 32 Divide by 64 
1• ' 
6. This example uses an unsigned bit shift to convert the word address of an INT array to a byte address and loads the byte address in a STRING pointer. This allows byte access to the INT array. 
INT a[0:5]:
STRING .p := @a[0] '<<' 1: 
p[3] := O: 
!Declares INT array
!Declares and initializes STRING ! pointer with array byte address ! resulting from the bit shift !Assigns 0 to fourth byte of "a" 
7. This example shifts the right byte of a word into the left byte position and sets the right byte to zero: 
INT b: !Declares variable 
b := b '<<' 8: !Shifts right byte intc left byte 
8. This example declares and initializes an extended pointer with the lowest address in an extended segment (see also Appendix A): 
STRING .EXT esp := 4D '<<' 17; 
9. This example declares an extended pointer and assigns to it an extended address in the current user code segment (see also the $DBLL function in Section 17): 
INT .EXT p; !Declares extended pointer 
@p : = ( $DBLL ( 2 '7) ) I<< I 1: !Assigns address in code segment 
14-8 
1'82581 AOO 3/85 
SECTION 15 
STATEMENTS 
This section describes executable statements, which control program execution by accessing and modifying the program's data. 
This section contains: 
• A summary of statements, organized by functional category 
• Rules for forming statements 
• Syntax for each statement, listed in alphabetic order 
SUMMARY OF STATEMENTS BY FUNCTION 
Statements are summarized within the following categories: 
• Program Control--Directs the flow of program execution 
• Data Transfer--Stores or transfers data within a program 
• Data Scan--Searches scan area for a test character 
• Machine Instruction--Relates to machine instructions 
-'f82581 AOO 3/85 
15-1 
1 
S TATEMENTS
Summary of Statements by Function 
Program Control 
ASSERT 
CALL 
CASE 
DO-UNTIL 
FOR-DO 
GOTO 
IF-THEN- ELSE 
RETURN 
WHILE-DO 
Data Transfer 
conditionally invokes error-handling procedure. 
invokes procedure or subprocedure. 
executes statement based on an index value. 
executes posttest loop until true condition occurs. 
executes pretest loop for <n> times. 
unconditionally branches to label within procedure or subprocedure. 
executes THEN or ELSE statement based on true or false state. 
returns from procedure or subprocedure to caller. For functions, also can specify returned value. 
executes pretest loop during true condition. 
15-2 
Assignment stores a value in a variable. 
Move 
STACK 
STORE 
Data Scan 
RSCAN 
SCAN 
moves group of items from one location to another. 
loads value on register stack. 
stores register stack element into variable. 
searches scan area, right to left, for test character. 
searches scan area, left to right, for test character. 
..,, 132581 AOO 3/85 
Machine Instruction 
CODE 
DROP 
USE 
specifies machine codes for inclusion in object code. 
frees index register or removes label from symbol table. 
reserves index register for user manipulation. 
RULES FOR FORMING STATEMENTS 
An executable statement can be a single statement or a compound statement. A compound statement is a BEGIN-END construct that groups statements to form a single logical statement. 
The syntax for a compound statement is: 
BEGIN
[ <statement> 
END [ ; ] 
BEGIN 
indicates the start of the compound statement. 
<statement> 
END 
is an executable statement. 
indicates the end of the compound statement. 
(semicolon) 
is a statement separator. 
4't82581 AOO 3/85 
15-3 
STATEMENTS Rules for Forming Statements 
STATEMENTS
Rules for Forming Statements 
You can use compound statements anywhere you can use a single statement. You can nest them to any level in statements such as IF, DO, FOR, WHILE, or CASE to control execution of multiple operations. 
The following example shows a null compound statement: 
BEGIN END; 
The following example shows a compound statement that contains multiple statements: 
BEGIN
a := b + c; d := %B101; f := d - e; 
END; 
Separating Statements 
Rules for using semicolons as separators are: 
• A semicolon must separate each pair of statements. 
• A semicolon is optional before the reserved word END, if END terminates a compound statement. 
• A semicolon must not precede an ELSE or UNTIL keyword. 
15-4 
-'f82581 AOO 3/85 
ASSERT STATEMENT 
The ASSERT statement conditionally invokes the procedure named in an ASSERTION compiler control directive. 
The syntax for the ASSERT statement is: 
ASSERT <assert-level> <expression> 
<assert-level> 
is an integer in the range 0 through 32767 that is higher than the <assertion-level> specified in an ASSERTION 
directive. If the <assert-level> is lower than the <assertion-level>, the ASSERT statement has no effect. 
<expression> 
is a conditional expression that tests a program condition and evaluates to a true or false result. 
The ASSERT statement is a debugging or error-handling tool. You use it with the ASSERTION directive as follows: 
• Place an ASSERTION directive in the source code, naming an error-handling procedure and specifying an <assertion-level>. 
• Place an ASSERT statement wherever you want to invoke the error- handling procedure if an error occurs, specifying an <assert-level> higher than the <assertion-level> of the ASSERTION directive. 
• When the error occurs, the ASSERTION directive invokes the procedure. 
• After you debug the program, you can nullify the ASSERT statement by raising the <assertion-level> of the ASSERTION directive higher than the <assert-level> of the ASSERT statements. 
If ASSERT statements that specify the same condition have the same <assert-level>, you can nullify certain levels of ASSERT statements. 
For more information on the ASSERTION directive, see Section 20, "Compiler Operation." 
~ 82581 AOO 3/85 
15-5 
STATEMENTS ASSERT Statement 
STATEMENTS ASSERT Statement 
Example 
This example invokes the operating system DEBUG procedure whenever a $CARRY or $OVERFLOW condition occurs: 
?ASSERTION = 5, DEBUG !Effective for all ASSERT ! statements 
. 
?SOURCE $SYSTEM.SYSTEM.EXTDECS (DEBUG) SCAN array WHILE " " -> @pointer; ASSERT 10 $CARRY; 
ASSERT 10 $CARRY; 
ASSERT 20 : $OVERFLOW; 
T.AL generates instructions that check the condition code indicators and invoke DEBUG. 
In this example, changing <assertion-level> to 15 nullifies the $CARRY condition. Changing it to 30 nullifies all of the ASSERT statements. 
15-6 
"'1 fl2581 AOO 3/85 
ASSIGNMENT STATEMENT 
The assignment statement assigns a value to a previously declared variable. 
The syntax for the assignment statement is: 
<variable> := <expression> 
<variable> 
is the identifier of a variable (simple variable, array element, pointer, or structure data item), with or without a bit deposit field and/or index. If <variable> is a pointer, you can use the @symbol to update its contents as described 
in Section 10. 
<expression> 
is an arithmetic or conditional expression of the same type as <variable>, except as noted under "Mixing Types." It can be a bit extraction value, but not a constant list. 
For information on assignments to pointers, see Section 10; for assignments to structures and structure pointers, see Section 11. 
Mixing Types 
STATEMENTS Assignment Statement 
~· 
ASSIGNMENT STATEMENT 
The assignment statement assigns a value to a previously declared variable. 
The syntax for the assignment statement is: 
<variable> := <expression> 
<variable> 
is the identifier of a variable (simple variable, array element, pointer, or structure data item), with or without a bit deposit field and/or index. If <variable> is a pointer, you can use the @symbol to update its contents as described in Section 10. 
<expression> 
is an arithmetic or conditional expression of the same type as <variable>, except as noted under "Mixing Types." It can be a bit extraction value, but not a constant list. 
For information on assignments to pointers, see Section 10; for assignments to structures and structure pointers, see Section 11. 
Mixing Types 
The data type of the value and the variable must match except in the case of INT and STRING types. 
If you assign an INT value to a STRING variable, the system left justifies the right byte of the INT value. It discards the left byte 
of the value. 
If you assign a byte character string to an INT variable, the system stores the value in the right byte of the word, with a 0 in the left byte. (To store a character in the left side, assign the character and a space, as in "A"). 
-'1' 82581 AOO 3/85 
STATEMENTS Assignment Statement 
15-7 
STATEMENTS Assignment Statement 
To mix types other than INT and STRING, use a type-transfer standard function, described in Section 17. 
FIXED Variables 
When you assign a value to a FIXED variable, the system scales the value up or down to match the <fpoint> value. If the system scales the value down, you lose some precision depending on the amount of scaling. The following example attempts to assign a value with three decimal places to a FIXED(2) variable: 
FIXED(2) a ;
a := 2.348F !System scales value to 2.34F 
If the ROUND directive is on, the system scales the value as needed, then rounds it up or down. For example, if you assign the value 2.3456 to a FIXED(2) variable, the system scales the value by one digit, then rounds it to 2.35. 
EK,mples of Assignment Statements 
1. This example shows various assignment statements: 
STRING a; INT b; REAL c ; FIXED d; 
a := 255;
b := a + 10;
c := 36.6E-3: d := $FIX (c) : 
!Declarations 
!Assignment statements 
!Type-transfer function returns ! FIXED value from REAL value 
2. In this example, the declaration is equivalent to the three assignment statements below it: 
15-8 
~ 82581 AOO 3/85 
INT .b[0:2] := ["ABCDEF"}: 
b[0] := "AB"; b[1] := "CD": b[2] := "EF": 
!Declaration with constant list 
!Assignment statements
! cannot use constant lists 
STATEMENTS Assignment Statement 
~ 3. This example shows what happens when you assign an INT value to a STRING variable: 
STRING bytel; 
bytel := "AB"; 
is right justified unless you also assign a space: 
I"B" I
4. This example shows that a character assigned to an INT variable 
INT int!; 
int! := "A";
intl := "A "; "A" 
!"A" 
? 
!"A" is lost; right half ! retains old value 
0 "A" !"A" 
5. In this example, the multiple assignment statement is equivalent to the three separate assignments below it: 
'1J82581 AOO 3/85 
15-9 
INT intl;
INT int2;
INT int3;
INT vary := 16; 
intl := int2 := int3 := vary; 
intl := vary; int2 := vary; int3 := vary; 
!Declarations 
!Multiple assignment 
!Separate assignments 
STATEMENTS CALL Statement 
CALL STATEMENT 
The CALL statement invokes a procedure, subprocedure, or entry point, and optionally passes parameters to it. 
The syntax for the CALL statement is: 
_____,,__________________ 
CALL <identifier> [ ( <param> [ , <param> ] •.• ) ] 
<identifier> 
is the name of a previously declared procedure, subprocedure, or entry point. 
<param> 
is a variable or an expression that defines an actual parameter to pass to <identifier>. 
You invoke procedures and suprocedures using the CALL statement, whereas you invoke functions by using their names in expressions. A CALL statement can also invoke a function. In this case, the caller 
ignores the returned value of the function. 
Actual parameters are value or reference parameters and are optional or required depending on the procedure or subprocedure declaration, as described in Section 16. 
If you omit any optional parameters, use a place-holding comma for each omitted parameter except the rightmost ones. TAL does not check for optional parameters~ 
When you invoke a procedure, the operating system saves the environment of the calling procedure or subprocedure and executes the called procedure. When you invoke a subprocedure, the operating system saves only the location to which control is to return after the subprocedure completes execution. 
After the called procedure or suprocedure completes execution, the program returns to the statement following the CALL statement, as shown in Figure 15-1. 
15-10 
'f 
82581 AOO 3/85 
~·· 
Examples 
STATEMENTS CALL Statement 
CALL tax"proc (item, rate., result); --------------------.1 next<statement>;....-. -----. f 
.....________ Return - - - - - - - 
Figure 15-1. CALL Statement Execution 
S5013-008 
1. This example invokes a procedure that has no parameters: 
CALL errorAhandler; 
2. This example shows all parameters included: 
CALL computeAtax (item, rate, result); 
3. This example shows place-holding commas for omitted optional parameters: 
CALL FILEINFO (filenum, error, , devAnum, , , eof ) 
4. This example uses place-holding commas and comments in place of omitted parameters: 
CALL FILEINFO (filenum, error, !filename! , devAnum, !devAtype! , !ext"'size! , eof ) ; 
~ 82581 AOO 3/85 
15-11 
Execute "tax"proc" 
STATEMENTS CASE Statement 
CASE STATEMENT 
The CASE statement executes one of a choice of statements, based on an index value. 
The syntax for the CASE statement is: 
CASE <index> OF BEGIN 
END 
[ <statement> [ <statement> 
[ <statement> ] ;
[ OTHERWISE [ <statement> ] ; ] 
!For <index> 0 !For <index> = 1 
!For <index> = <n> 
<index> 
is an INT arithmetic expression that selects the statement to .~ execute. 
<statement> 
is any executable statement, including a compound or CASE statement. 
OTHERWISE 
indicates the statement to execute for any case outside the <index> range. If you omit the OTHERWISE clause and an out-of-range case occurs, execution is unpredictable. 
The CASE statement lets you make multiple branch decisions in applications where selection is based on a range of index values. 
15-12 
..-, 82581 AOO 3/85 
~ 
The following rules apply: 
• If a case in the <index> range has no action, you must specify either a null statement (a semicolon with no <statement>) or a null compound statement. 
• If a <statement> consists of more than one statement, you must use a compound statement. 
• If the same <statement> applies to multiple <index> values, you only need to code the <statement>, preceded by a label, for one <~ndex> value. Then you can use GOTO statements to the label for the other <index> values to which the <statement> applies. 
Figure 15-2 shows how the CASE statement works. 
CASE <index> OF 
BEGIN 
1-----------1~- ! <index> = !
1-----------1~- !O! <statement>; - - - - - - - - - 1 - - - - - - - - - - 1.-.... !1! <statement>; ----------1 i---------~-!2! <statement>; - - - - - - - - - 1--------~-!3! <statem ent>;--------- 
-------~-OTHERWISE <statement>; - - - - - - END; 
next <statement>; 
85013-009 
Figure 15-2. CASE Statement Execution 
~ 82581 AOO 3/85 
15-13 
STATEMENTS CASE Statement 
STATEMENTS CASE Statement 
Examples 
1. In this example, if "vary" is 0, the first statement executes; if "vary" is 1, the second statement executes. For any other 
case, the third statement executes. 
INT vary; INT varyO; INT varyl; 
CASE vary OF BEGIN 
varyO := O; varyl := 1; OTHERWISE 
CALL errorAhandler; 
END; 
2. This example selectively moves one of several messages into an array: 
15-14 
-'f82581 AOO 3/85 
PROC msgAhandler (index); INT index; 
BEGIN
LITERAL len = 80;
STRING .aAarray[O:len - 1]; 
!Index value 
!Length of array !Destination array 
CASE index OF BEGIN 
!O! aAarray 
1.	!1!  aAarray 
2.	!2!  aAarray 
3.	!3!  aAarray 
OTHERWISE aAarray 
END; 
END; 
t•-I .- 
' :=' t::I 
t•-I .- 
!Move Statements "Training Program"; 
"End of Program";
"Input Error";
"Home Terminal Now Open"; 
"Bad Message Number";
!End of CASE statement 
!End of procedure 
.- 
I•-I 
!First statement !Second statement 
!Third statement 
,....,, CODE STATEMENT 
The CODE statement lets you specify machine-level instructions to compile into the object program. 
The syntax for the CODE statement is: 
CODE ( <instruction> [ <instruction> ] .•. ) 
<instruction> 
is a machine instruction in one of six forms: 
No. Form 
1.	1  <mnemonic> 
2.	2  <mnemonic> 
3.	3  <mnemonic> 
4.	4  <mnemonic> 
5.	5  <mnemonic> 
6.	6  <mnemonic> 
<mnemonic> 
[ • I @ ] <identifier> <constant> <index-register> 
[ • I @ ] <identifier> [ , <index-register> <constant> [ , <index-register> ] 
is an instruction code (described in the System Description Manual for your system). 
<identifier> 
is the name of a previously declared object. For a PCAL, XCAL, or SCAL instruction, it is a procedure name. For a branch instruction, it is a label. (The procedure name must be resolvable by the time the executable object file 
is created.) 
An indirect <identifier> specified without @ generates instructions for an indirect reference through <identifier>. 
<constant> 
is an INT constant of the same size as the instruction field. 
"182581 AOO 3/85 
STATEMENTS CODE Statement 
15-15 
STATEMENTS CODE Statement 
<index-register> 
is an INT constant specifying either: 
• the number of an index register in the range 5 through 7 
• an identifier associated with an index register in an USE statement 
If you omit <index-register>, no indexing occurs. 
The form of the CODE statement correlates to the requirements of each instruction code as described in the System Description Manual for 
your system. You must include all required operands for each machine instruction. 
TAL inserts indirect branches around instructions emitted in a CODE statement, if needed. Normally, TAL emits these values after the
first unconditional branch instruction occurs. ~ 
Pseudocodes 
In addition to the instruction codes described in the System Description Manual, TAL recognizes the following pseudocodes as part of the <mnemonic> set: 
• CON--This code is a form 3 instruction that emits inline simple or character string constants and indirect branch locations. 
• FULL--This code is a form 1 instruction that signals TAL when the register stack is full and sets the TAL RP counter to 7. TAL emits no code for this mnemonic. 
Examples 
1. The following example turns off traps: 
CODE ( RDE; ANRI %577; SETE ); !Turn off traps 
15--16 
~ 82581 AOO 3/85 
~ 
STATEMENTS CODE Statement 
2. The following example scans from a code-relative address to the test character 0, then saves the next address: 
STRING •ptr;
STACK @ptr, O; CODE ( SBU %640 ) ; STORE @ptr; 
3. The following are examples of the six instruction forms: 
~· 
CODE ( CON "the con pseudo operator code" ); 
6. This example emits a code-relative pointer to "labelid" in the next instruction location: 
CODE ( CON @labelid ); 
CODE ZERO; !ADD ) :
CODE LADRa;STOR.b):
CODE LDI21;ADDI-4):
CODE STAR 7; STRP 2 ):
CODE LDXa,7;LDB.stg,x): CODE LDXI -15,5 ): 
!Form 1 !Form 2 !Form 3 !Form 4 !Form 5 !Form 6 
4. This example emits 
CODE ( CON %125 
%125 in the next instruction location: 
); 
14 words of constant information starting in 
5. This example emits
the next instruction location: 
.,.82581 AOO 3/85 
15-17 
STATEMENTS DO Statement 
DO STATEMENT 
The DO statement is a posttest loop that executes a statement until a specified condition becomes true. 
The syntax for the DO statement is: 
DO [ <statement> ] UNTIL <expression> 
<statement> 
is any executable statement (including compound, null, and nested DO statements). 
<expression> 
is an arithmetic or conditional expression. 
If <expression> is always false, infinite looping occurs unless some event in the DO loop causes an exit (such as a RETURN statement). 
Figure 15-3 shows the action of the DO statement. 
!!
DO <statement> UNTIL - - - t . c 
next <statement>; 
15-18 
Figure 15-3. DO Statement Execution 
$5013-010 
'""182581 AOO 3/85 
~ 
Examples 
1. This example loops until it clears each array element with a 0: 
STRING .array[0:49];
DO array [index := index + 1] := 0 UNTIL index = limit; 
2. This example tests each array element until it finds a character: 
DO index := index+ 1 UNTIL $ALPHA (array[index]); 
3. This example shows a multiline DO statement: 
DO BEGIN 
i := i + 1;
CALL checkAerror (error); 
END !No semicolon here UNTIL i > 15 OR error = true; 
._,82581 AOO 3/85 
STATEMENTS DO Statement 
15-19 
STATEMENTS DROP Statement 
DROP STATEMENT 
The DROP statement disassociates an identifier from either (1) a label or (2) an index register that you reserved in a previous USE statement. 
The syntax for the DROP statement is: 
DROP <name> 
<name> 
is the identifier of a label or of an index register that you reserved in a previous USE statement. 
Dropping Labels 
• You can drop a label only if you have either declared it in a label declaration or used it in a statement. 
• Before you drop a label, be sure there are no further references to the label. If a GOTO appears after the drop, an error occurs. 
Dropping Registers 
• The name must be associated in a USE statement. 
• If you reserve an index register for a FOR loop, do not drop the register within the scope of the FOR loop. 
• Once you drop a name, you need a new USE statement to reference it. 
.~ ,.-······;~ 
15-20 
~ 82581 AOO 3/85 
,._,,, Examp1es 
1. This example uses and drops a label within a DEFINE declaration: 
-'182581 AOO 3/85 
DEFINE loop = lab: 
IF a = b THEN 
GOTO lab; DROP lab; #; 
!Uses label name 
!Branches to label
!Frees label name for reuse 
2. This example reserves, uses, and drops an index register: 
LITERAL limit = 100;
INT array[O:limit-1]; !Declarations 
USE x; !Reserves index register; names it "x" FOR x := 0 TO limit - 1 DO
array[x] := O; !Uses index register to clear array DROP x; !Drops index register 
STATEMENTS DROP Statement 
15-21 
STATEMENTS FOR Statement 
FOR STATEMENT 
The FOR statement is a pretest loop that repeatedly executes a statement while incrementing or decrementing a variable until the variable is greater than or less than a given limit. 
The syntax for the FOR statement is: 
FOR <variable> := <initial> { TO } <limit> [ BY <step> ] DO { DOWNTO } 
[ <statement> 
<variable> 
is the identifier of an INT variable (simple variable, array element, pointer, or structure data item). 
<initial> 
~ 
I 
15-22 
"if82581 AOO 3/85 
TO 
is an INT arithmetic expression that defines the beginning value of <variable>. 
specifies that <step> is added to <variable> each time through the loop until <variable> exceeds <limit>. 
DOWNTO 
specifies that <step> is subtracted from <variable> each time through the loop until <variable> is less than <limit>. 
<limit> 
is an INT arithmetic expression. Looping stops when <variable> passes <limit>. 
<step> 
is an INT arithmetic expression to add to or subtract from <variable> each time <statement> executes. The default is 1. 
<statement> 
is any executable statement, including a compound or null statement or a nested FOR statement. 
Because the FOR statement tests <variable> before looping, if <variable> passes <limit> on the first test, the loop never executes. 
You must enter a FOR statement only at the beginning, not at the <statement>. You can nest FOR loops to any level. 
Figure 15-4 shows the action of the FOR statement. 
'~ Optimizing FOR Loops 
TAL emits more efficient machine code (using the BOX instruction) if you use~ reserved index register for <variable> in the FOR statement, as follows: 
1.	Specify a USE statement to reserve and assign a name to an index register. 
2.	In the FOR statement: 
--Speci'fy the name of the index register for <variable>. 
--Specify a 1 (the default) for <step>. 
--Specify the TO clause, not the DOWNTO clause. 
3.	Do not modify the register stack unless you save and restore it before the end of the loop. 
4.	Do not drop the reserved index register (using the DROP statement) until after the FOR statement completes executing. 
-'182581 AOO 3/85 
STATEMENTS FOR Statement 
15-23 
STATEMENTS FOR Statement 
5. If you include procedure calls in the FOR loop, TAL does not emit more efficient code with the USE statement. Instead, TAL must emit code to save and restore the registers associated with the BOX instruction before and after the CALL statement. 
i
FOR <variable>:= <initial> 
i
Calculate <limit> and <step> - - - .....·< 
(if not constants) 
TRUE 
i
next <statement>; 
Figure 15-4. FOR Statement Execution 
Examples 
1. This FOR loop clears each array element: 
LITERAL !en = 100:
STRING .array[O:len - 1]; 
INT index: 
FOR index := 0 TO !en - 1 DO array[ index] := " ": 
!Declarations 
!Uses default <step> of 1 
15-24 
FALSE 
DO <statement> 
+ 
Increment or decrement <variable> BY <step> 
..- 
S5013-011 
..,.. 82581 AOO 3/85 
.. 
STATEMENTS FOR Statement 
~ 2. This example optimizes the FOR loop shown in Example 1: LITERAL len = 100; 
'~ 
4. This nested FOR statement treats "multiples" as a two-dimensional array. It fills the first row with multiples of 1, the next row with multiples of 2, and so on: 
INT .mu1tip1es[0:10*10-1]; INT row;
INT column; 
FOR row := 0 TO 9 DO
FOR column := 0 TO 9 DO 
multiples [row* 10 +column] :=column* (row+ 1); 
STRING .array[O:len - l]; 
USE x;
For x := 0 TO len - 1 DO 
array[x] := " "; DROP x; 
!Declarations 
!Reserve index register 
!Release index register 
3. This example uses the DOWNTO clause and a compound statement: 
-1'82581 AOO 3/85 
15-25 
LITERAL len = 200;
INT .array[O:len - l]; INT index;
INT answer; 
FORindex:=len- 1DOWNTO0BY5DO BEGIN 
answer := answer + index; 
array[index] := answer + index; END; 
!Declarations 
!Begin compound statement 
!End compound statement 
STATEMENTS GOTO Statement 
GOTO STATEMENT 
The GOTO statement unconditionally transfers program control to a labeled statement. 
The syntax of the GOTO statement is: 
GOTO <label-name> 
<label-name> 
is a label you previously associated with a statement. It cannot be an entry point. 
A GOTO statement in a procedure can branch only to a label in the same procedure; it cannot branch to a label in a subprocedure. A GOTO
statement in a subprocedure can branch within the same subprocedure or ~ from the subprocedure to the calling procedure but not to another subprocedure. 
Figure 15-5 shows the action of the GOTO statement. 
L-GOT~ <label-name>; <label-name> : 
..,.. <statement>; 
85013-012 
Figure 15-5. GOTO Statement Execution 
15-26 
~ 82581 AOO 3/85 
,.._,,. Example 
1. In this example, the GOTO statement transfers program execution to the statement labeled "calcAa": 
4'82581 AOO 3/85 
15-27 
calc"'a 
INT a;
INT b := 5; 
a := b * 2; 
GOTO calcAa; 
STATEMENTS GOTO Statement 
STATEMENTS IF-THEN-ELSE Statement 
IF-THEN-ELSE STATEMENT 
The IF-THEN-ELSE statement executes one of a pair of statements based on whether a condition is true or false. 
The syntax for the IF statement is: 
IF <conditional-expression> THEN 
[ <statement> [ ELSE 
[ <statement> 
<conditional-expression> 
is a conditional expression. 
THEN <statement> 
specifies the statement to execute if <conditional-expression> ,~ is true. <statement> can be any executable statement,
including a compound or IF statement. If you omit 
<statement>, no action occurs for the THEN clause. 
ELSE <statement> 
specifies the statement to execute if <conditional-expression> is false. <statement> can be any executable statement, including a compound or IF statement. If you specify ELSE 
with no <statement>, no action occurs for the ELSE clause. 
TAL sets no limit on nested IF conditions. 
15-28 
"'82581 AOO 3/85 
~ 
STATEMENTS IF-THEN-ELSE Statement 
The IF-THEN form executes as shown in Figure 15-6. The IF-THEN-ELSE form executes as shown in Figure 15-7. 
....-----------------------------------·-·-·-·---,-· 
AiJ82581 AOO 3/85 
! 
IF 
next <statement>; 
Figure 15-6. IF-THEN Form Execution 
! 
next <statement>; 
">---..,..THEN <statement> TRUE 
...___ _ _ _ _ • ELSE <statement> 
S5013-014 
Figure 15-7. IF-THEN-ELSE Form Execution 
S5013-013 
15-29 
STATEMENTS IF-THEN-ELSE Statement 
THEN-ELSE Pairing 
The innermost THEN clause pairs with the closest ELSE clause, and pairing proceeds outward. In the following examples, the ELSE clause belongs to the second THEN clause (IF "condition2"). The
statements shown are equivalent, but the THEN-ELSE pairing is clearer 
in the example on the left: 
Recommended Format 
IF condition! THEN 
IF condition2 THEN 
Ambiguous Format 
IF condition! THEN IF condition2 THEN 
stmtl 
15-30 
ELSE stmtl stmt2; 
ELSE stmt2; 
To override the THEN-ELSE pairing, you can use the BEGIN or END keyword in a compound statement. Using the same example, if you
insert a BEGIN-END pair as shown below, the ELSE clause belongs to the first THEN clause (IF "condition!"): 
IF condition! THEN 
BEGIN !Begin compound statement IF condition2 
THEN stmtl 
END !End compound statement (no semicolon here) ELSE 
stmt2; 
Examples 
1. This example checks a variable for a nonzero value: 
INT var"item; 
IF var"item <> 0 THEN 
CALL error"handler; 
-'182581 AOO 3/85 
STATEMENTS IF-THEN-ELSE Statement 
·~ 2. This example checks the hardware condition code setting and calls a message-printing procedure when an error occurs: 
,.......,/ 
CALL READ (filenum, ••. ); IF < 
THEN BEGIN 
CALL printAerror; 
CALL STOP; END; 
3. This example of the IF-THEN-ELSE form compares two arrays: 
IF newAarray oldAarray FOR 10 THEN 
itemAok := 1 ELSE 
itemAok := O; 
4. This nested IF statement illustrates THEN-ELSE pairings: 
IF a = b THEN 
IF c = d THEN 
I F e = f THEN 
IF g <= h THEN 
-'182581 AOO 3/85 
15-31 
[ 
BEGIN
IF (NOT g > 1) OR (m n) 
THEN
result := 0 
ELSE
result := 1 
END
ELSE !No statement 
ELSE
result := 2 
ELSE
result := 3; 
!Sets condition code on error !Checks the condition code 
!Call message-printing procedure 
!No corresponding ELSE clause 
STATEMENTS Move Statement 
MOVE STATEMENT 
The left or right move statement transfers contiguous bytes, words, or elements from one location to another. 
The syntax of the move statement is: 
<destination> { ' .- ' } { <source> FOR <count> } [ -> <next-addr> ] .- 
{ '=:' } { <constant> } 
<destination> 
is the name of the variable, with or without an index, to which the move begins. It can be a simple variable, array, pointer, structure, substructure, structure data item, or structure pointer, but not a read-only array. 
' .- ' .- 
indicates a left-to-right sequential move. 
' - .' -. 
indicates a right-to-left sequential move. 
<source> 
is the name of the variable, with or without an index, from which the move begins. It can be a simple variable, array, read-only array, pointer, structure, substructure, structure 
item, or structure pointer. 
15-32 
~ 82581 AOO 3/85 
<count> 
is a positive INT arithmetic expression that defines the number of bytes, words, or elements in <source> to move, as follows. If omitted, TAL assumes a <count> of 1 and issues a warning. 
Simple variable = elements
Array = elements
Structure = words
Substructure = bytes
Structure pointer = bytes if STRING, words if INT Pointer = elements 
<constant> 
is a LITERAL, numeric or character string constant, or constant list to move. 
<next-addr> 
is a variable to contain the location in <destination> that follows the last item moved. <next-addr> is: 
• a 32-bit byte address if either <source> or <destination> has an extended address 
• a 16-bit byte address if both <source> and <destination> have standard byte addresses 
• a 16-bit word address if both <source> and <destination> have standard word addresses 
/'f82581 AOO 3/85 
15-33 
STATEMENTS Move Statement 
STATEMENTS Move Statement 
Element Moves 
If either <source> or <destination> is extended, the data in either location can be any type (STRING, INT, INT(32), FIXED, REAL, or 
REAL(64)). 
If <source> and <destination> have standard addresses, the data in both locations must be byte addressed, or they must both be word addressed. If both are word addressed, their data types need not match and can be INT, INT(32), FIXED, REAL, or REAL(64). 
After an element move, <next-addr> might not point to an element boundary in <destination>. 
A concatenated move lets you move more than one <source> or constant list, each separated by an ampersand(&). 
Examples 
Examples of structure moves follow examples of element moves. 
Examples of Element Moves 
1. This example shows a left-to-right move from one array to another: 
LITERAL length = 12;
INT .outAarray[O:length - l]; INT .inAarray[O:length - l]; 
outAarray[O] ':=' inAarray[O] FOR length; 
2. This is a right-to-left quadword element shift by one within an array. It frees element [0] for new data: 
LITERAL upper = 11; !Upper bound (same as length - 1) FIXED .inAarray[O:upper]; !Source and destination array 
inAarray[upper] '=:' inAarray[upper - l] FOR upper; 
3. This example moves a constant list: 
LITERAL len = 10;
STRING .pAarray[O:len - l]; 
p"'array[O] ':=' len * ["-"]; 
!Moves hyphen into each element 
15-34 
~ 82581 AOO 3/85 
STATEMENTS Move Statement 
'-"'. 4. This example moves spaces into the first five elements, then uses <next-addr> as <destination> to move dashes into the next five elements: 
·~ 
STRING .lineAarray[O:lineAlen - 1] ;
STRING .dateAarray[O:dateAlen - 1] := "Feb 1, 1985"; STRING .idAnumber[O:idAlen - 1] := "854-70-1950"; STRING .dpAnum[O:dpAlen - 1] := "107"; 
lineAarray ':=' " DATE: " & dateAarray FOR dateAlen 
IDENTIFICATION: " & idAnumber FOR idAlen & " DEPARTMENT: " & dpAnum FOR dpAlen; 
After execution, "lineAarray" contains the following: 
DATE: Feb 1, 1985 IDENTIFICATION: 854-70-1950 DEPARTMENT: 107 
-''f' 82581 AOO 3/85 
LITERAL len = 20;
LITERAL num = 5;
STRING .array[O:len - 1]; STRING .nextAaddr; 
!Length of array
!Number of elements !Destination array !Pointer for next address 
array[O] ':=' num * [" "] -> @nextAaddr; nextAaddr ':=' num * ["-"]; 
5. This concatenated move is a fast way to clear an array: 
LITERAL length = 100; !Length of array INT .array[O:length - 1]; !Destination array 
array[O] ':=' " " & array[O] FOR length - 1; !Clears array 
6. This concatenates and moves three arrays and some constants: 
LITERAL lineAlen = 68; LITERAL dateAlen = 11; LITERAL idAlen = 11; LITERAL dpAlen = 3; 
!Length of destination array !Length of source array 1 !Length of source array 2 !Length of source array 3 
&" 
15-35 
STATEMENTS Move Statement 
Examples of Structure Moves 
1. This example moves three occurrences of the source structure to the destination structure: 
LITERAL copies = 3; 
STRUCT .s[O:copies - 1]: BEGIN 
INT a; INT b; INT c; 
END; 
STRUCT .d (s) [O:copies - l]; 
PROC p ; BEGIN 
!Number of occurrences 
!Source structure 
!Destination structure 
d '..- ' s FOR copies* (($LEN(s) + 1) '>>' 1);
END; !Word move for structures; 
moves three occurrences 
2. This right-to-left move makes room for a new occurrence at the beginning of a structure: 
15-36 
~ 82581 AOO 3/85 
LITERAL last = 9; 
STRUCT t(*); BEGIN 
INT i; INT j; INT k; INT l; 
END; 
STRUCT .s (t ) [0:1ast ]; 
PROC p ; BEGIN 
!Last occurrence 
!Template structure 
!Source and destination structure 
s[last] '=:' s[last-1] FOR last* (($LEN(s) + 1) '>>' 1); END; 
~· 
STATEMENTS Move Statement 
3. This example moves three occurrences of a substructure: 
-'f82581 AOO 3/85 
LITERAL copies = 3; 
STRUCT . s ; BEGIN 
STRUCT sAsub[O:copies - 1]; BEGIN
INT a;
INT b; 
END; END; 
STRUCT .d (s); 
PROC p ; BEGIN 
!Number of occurrences 
!Source substructure 
!Destination substructure ! is within structure "d" 
d.sAsub ':=' s.sAsub FOR copies* $LEN(s.sAsub);
END; !Byte move for substructures; 
! moves three occurrences 
4. This code moves structure occurrences using structure pointers: 
STRUCT t (*); BEGIN 
INT a; 
STRING b; END; 
INT .EXT ptrO(t) := %200000D; 
STRING .EXT ptrl(t) := %2000000D; 
PROC p ; BEGIN 
!Template structure 
!Structure pointer to
! upper 32K
!Structure pointer to start ! of extended segment 
ptrl ':=' ptrO FOR (($LEN(t) + 1) '>>' 1); !Word move
! from upper 32K to start 
ptrO ':=' ptrl FOR $LEN(t); END; 
! of extended segment !Byte move from extended ! segment to upper 32K 
15-37 
STATEMENTS RETURN Statement 
RETURN STATEMENT 
The RETURN statement provides exit points from an invoked procedure or subprocedure body back to the caller. If the invoked procedure or subprocedure is a function, it can return a value. 
The syntax for the RETURN statement is: 
RETURN !Untyped procedure 
RETURN <expression> !Function (typed procedure) 
<expression> 
is an arithmetic or conditional expression of the same type as the encompassing procedure or subprocedure. <expression> 
is the value to return to the caller. Specify <expression> only when returning from functions. 
A procedure or subprocedure returns to the caller when: 
• A RETURN statement occurs. 
• The invoked procedure or subprocedure finishes execution by reaching the last END. 
In a procedure designated MAIN, a RETURN statement stops execution of the procedure and passes control to the operating system. 
If a function does not contain a RETURN or if the TAL RP counter setting is 7 (empty register stack), TAL emits a warning. If a function contains a RETURN, you must specify <expression>. The value of <expression> goes on the register stack. 
For untyped procedures and subprocedures, a RETURN statement is optional. If you do use a RETURN statement, you cannot include an <expression> with it. 
15-38 
-1'82581 AOO 3/85 
~ 
Examples 
1. This example shows RETURN statements in a function: 
INT PROC other (nuff, more); INT nuff; 
INT more; BEGIN 
IF nuf f < more THEN 
RETURN nuf f * more ELSE 
RETURN O; 
END; 
2. This example show an untyped procedure with a RETURN statement: 
~ 82581 AOO 3/85 
15-39 
PROC another; BEGIN 
INT a, b; 
IF a < b THEN RETURN; 
END; 
!Returns no value 
!Function returns a value 
STATEMENTS RETURN Statement 
STATEMENTS
Scan Statements 
SCAN STATEMENTS 
The SCAN or RSCAN statement searches a scan area for a test character from left to right or from right to left~ respectively. 
The syntax for the SCAN and RSCAN statements is: 
{ SCAN } <variable> { WHILE } <test-char> [ -> <next-addr> ] { RSCAN } { UNTIL } 
SCAN 
indicates a left-to-right search. 
RS CAN 
indicates a right-to-left search. 
<variable> 
is the name of a variable, with or without an index, at
which to start the scan. It can be a simple variable, array, standard pointer, structure, substructure, structure data 
item, or standard structure pointer. The data must be in the lower 32K area. 
WHILE 
specifies that the scan continues until a character other than <test-char> occurs. A scan stopped by a 0 sets the hardware CARRY bit. 
UNTIL 
specifies that the scan continues until <test-char> or a 0 occurs. A scan stopped by a 0 sets the hardware CARRY bit. 
.:~ 
15-40 
"'f' 82581 AOO 3/85 
<test-char> 
is an INT arithmetic expression that evaluates to a maximum of eight significant bits. If the value is larger than eight significant bits, execution errors might result. 
<next-addr> 
is a 16-bit variable to contain the 16-bit byte address of the character that stopped the scan, regardless of what type <variable> is. 
If the test character or a 0 does not occur during a SCAN UNTIL operation, the scan might continue to the 32K boundary. Before doing any scans, you can delimit the scan area as follows: 
INT .buffer[-1:20] := [O," John James Jones ",O]; 
t___ scan delimiters ___J 
A scan that stops on a 0 sets the hardware CARRY bit, which means the test character did not occur. To check the CARRY bit, use the $CARRY function before doing any arithmetic operations, as follows: 
IF $CARRY !If test character THEN ...; 
IF NOT $CARRY !If test character THEN ..•; 
Examples 
The following declarations apply to the examples: 
not found .•• 
found ... 
INT .buffer[-1:18] := [O," Smith, Maurice ",O]; !INT buffer 
STRING .sptr := @buffer '<<' 1; 
STRING .firstl, .first2, .lastl, .last2, .comma; INT offset, length; 
!STRING pointer ! to INT buffer !Pointers !Variables 
Aft82581 AOO 3/85 
15-41 
STATEMENTS Scan Statements 
STATEMENTS
Scan Statements 
In the diagrams, a circumflex (A) denotes the character that stopped the scan. Declarations are on the previous page. 
1.	This example scans from element [OJ for spaces, checks the CARRY bit, and calls a string-handling procedure if a character occurs: 
S C A N s p t r [ 0 ] W H I L E 1 1 1 1 - - > @f i r s t 1 ; J IF NOT $CARRY THEN Smith, Maurice 
CALL stringAhandler; 
2.	This example scans from the first character of the last name for a comma (,), checks the CARRY bit, and calls an error-printing procedure if a comma does not occur: 
SCAN firstl UNTIL","-> @comma;
IF $CARRY THEN Smith, Maurice 
CALL invalidAinput; 
3.	This example scans for spaces right to left from the location preceding the comma. In this case, the scan starts and stops at the same location: 
RSCAN comma(-1] WHILE " " -> @lastl; Smith, Maurice J 
4.	This example uses <next-addr> to compute the offset of the last 
name from the beginning of the array: 
SCAN comma[+l] WHILE " " -> @first2; Smith, Maurice J offset := @first2 '-' @sptr; 
II 
sptr[ 0] f irst2 
5. This example uses <next-addr> to compute the length of the character string stored in the array: 
1.5-42 
4°'82581 AOO 3/85 
SCAN first2 UNTIL " " -> @last2; length := @first! ' ' @last2; 
Smith, Maurice J 
II 
f irstl last2 
J 
0 
' 
- . , l 
STACK STATEMENT 
The STACK statement loads a value onto the register stack. 
The syntax for the STACK statement is: 
STACK <expression> [ , <expression> ] ... 
<expression> 
is a value to load onto the register stack. If you list multiple values, STACK loads them from left to right. The number of registers needed by an <expression> depends on its data type. 
You can use the register stack for temporary storage and for optimizing critical code sections. 
TAL loads values on the register stack starting at the current setting of the RP + 1. As TAL loads each value, it increments RP by the number of words required by the type of the value. For example, for an INT(32) value, it increments RP by 2; for a quadword value, it 
increments RP by 4. 
TAL keeps track of the size and type of values being stacked and emits appropriate machine instructions. TAL right justifies byte values; that is, it loads them on the register stack in bits <8:15>. 
If the number of registers needed exceeds the number of free
registers, TAL transfers the contents of registers R[O] through RP to the data stack, then loads the registers starting at RP[O] with values specified in the STACK statement. 
.-,. 82581 AOO 3/85 
STATEMENTS STACK Statement 
15-43 
STATEMENTS STACK Statement 
Examples 
1. This example loads values of various types onto the register stack: 
STRING .b[0:2] := (1,2,3] 13 INT wrd :== 3;
INT(32) dwrd := OD; 12 
STACK b[2], wrd * 4, 300, dwrd; 300 
1-- 0 
- 
R[O] 
R[l] 
R[2] 
R[3] 
R[4] ..,_ RP 
Register Stack 
2. This example shows two versions of a switch operation commonly used in sorting. The first version needs six memory references; the second needs only four memory references, uses the register stack, and is faster: 
15-44 
INT temp; INT x·, INT y ; 
temp := x·, x := y;
y := temp; 
STACK x,y; STORE x,y; 
!Switch operation version 1 
!Switch operation version 2 
..,., 82581 AOO 3/85 
1~ 
STORE STATEMENT 
l.......,. 
The STORE statement removes values from the register stack and stores them into variables. 
The syntax for the STORE statement is: 
STORE <variable> [ , <variable> ] .•• 
<variable> 
is the name of a variable (simple variable, array element, pointer, or structure data item), with or without a bit deposit field and/or index. If <variable> is a pointer, you can use the @symbol to update its contents as described in Section 10. 
If the STORE statement specifies multiple variables, storage begins with the leftmost variable. 
The data type of each variable specified dictates the number of registers to unload, starting at the current RP. If the RP setting is too small to satisfy the variable type, TAL removes the required number of items from the data stack, places them on the register
stack, and stores them in the variable. 
Examples 
1. The following example stores register contents into variables of various types: 
LITERAL len = 100; 
-''f 82581 
15-45 
STRING INT INT(32) 
.byte[O:len - 1]; word;
twowords; 
STORE byte[3], word, twowords; 
AOO 3/85 
STATEMENTS STORE Statement 
STATEMENTS STORE Statement 
2. The following example stacks two variables, then stores them back into the same variables: 
STACK x, y; 
STORE y, x; 
3. The following example switches the values of two variables: 
STACK x, y; STORE x, y; 
15-46 
""182581 AOO 3/85 
STATEMENTS USE Statement 
~, USE STATEMENT
The USE statement associates an identifier with an index register and 
reserves it for your use. 
The syntax for the USE statement is: 
USE <name> 
<name> 
is an identifier to associate with an index register. 
TAL associates each identifier with an index register, starting with R[7] down to R[5]. You can then reference the identifier in statements. For example, you can use a reserved index register to optimize a FOR loop, as described under the FOR statement. 
The following rules apply: 
• 
• 
• 
You cannot reserve more than three registers at a time. 
Evaluation of certain expressions might overwrite the value in a reserved register, such as multiplication of two FIXED values. 
If the compiler needs an index register and none is available, a compilation error results. 
• You can issue a DROP statement to release a register. (When TAL reaches the END reserved word of a procedure or subprocedure body, all registers are automatically dropped.) 
• After you drop an index register, you cannot use its name without a new USE statement. 
"182581 AOO 3/85 
15-47 
STATEMENTS USE Statement 
Examples 
1. This example reserves two index registers: 
USE a"index; USE b'''index; 
t 1R[O] 
2. This example reserves an index register, then drops it: 
USE x; !Reserve register 
DROP x; !Free register 
3. This example shows two versions of a FOR loop, the second of which r"' uses a reserved register and runs faster (if no procedure or
function calls occur within the loop): 
15-48 
"''f 82581 AOO 3/85 
LITERAL len = 100;
INT .array [O:len - l]; INT i; 
FOR i := 0 TO len - 1 DO array[i] : = array[i] + 5; 
USE x ;
FOR x := 0 to len - 1 DO 
array[x] := array[x] + 5; 
DROP x · 
I 
!Version 1 
!Version 2 is faster 
"i 
. 
/' 
b"index R[6] 
a" index R[7] 
Register Stack 
" - ' 1 
WHILE STATEMENT 
The WHILE statement is a pretest loop that repeatedly executes a statement while a specified condition is true. 
The syntax for the WHILE statement is: 
WHILE <conditional-expression> DO [ <statement> ] 
<conditional-expression> 
is a conditional expression. 
<statement> 
is any executable statement (including compound, null, and WHILE statements). 
The WHILE statement is useful when the number of loops needed is unknown. It evaluates and tests <conditional-expression> before looping; if <conditional-expression> is false after the first test, <statement> never executes. 
If <conditional-expression> is always true, <statement> executes indefinitely unless some event in the WHILE loop causes an exit, such as a RETURN statement. 
Figure 15-8 shows the action of the WHILE statement. 
"182581 AOO 3/85 
STATEMENTS WHILE Statement 
15-49 
STATEMENTS WHILE Statement 
Examples 
next <statement>; 
DO <statement>; J 
85013-015 
Figure 15-8. WHILE Statement Execution 
1. This loop continues while "item" is not equal to zero: 
LITERAL len = 100;
INT .array[O:len - 1]; INT item := 1;
INT i := 0; 
WHILE item <> 0 DO BEGIN 
item := array[i]; 
i := i + 1; END; 
2. This WHILE statement increments "index" until a nonalphabetic character occurs: 
LITERAL len = 255;
STRING .array[O:len - l]; 
INT index := -1; 
WHILE (index< len - 1) AND ($ALPHA(array[index := index+ 1])) DO • • • 
15-50 
-'182581 AOO 3/85 
SECTION 16 
PROCEDURES AND SUBPROCEDURES 
Procedures and subprocedures are the executable portions of a TAL program. They compose the block structure of the program. They allow you to segment the program into discrete blocks or subroutines that perform a task. 
An executable program contains at least one procedure. Furthermore, one procedure has the attribute MAIN, which identifies it as the first procedure to execute when you run the program. A procedure can contain subprocedures, which execute at various points within that 
"'-""'. procedure. 
The maximum possible size of a single procedure is 32K words minus either the Procedure Entry Point (PEP) Table in the lower 32K area or the External Entry Point (XEP) Table in the upper 32K area. For 
information on the PEP or XEP table, see the System Description Manual for your system. 
This section describes: 
• Characteristics of procedures and subprocedures 
• Procedure and subprocedure declarations 
• Parameters and parameter passing 
• Entry-point declarations 
"'82581 AOO 3/85 
16-1 
PROCEDURES AND SUBPROCEDURES
Characteristics of Procedures and Subprocedures 
CHARACTERISTICS OF PROCEDURES AND SUBPROCEDURES 
Procedures and subprocedures share the following characteristics: 
.... ·I 
• 
• 
• 
• 
• 
• 
• 
Procedures and subprocedures are parameterized. The same procedure or subprocedure can process different sets of variables. 
Procedures and subprocedures allow all items that have global scope (except procedures) to have local scope (in a procedure) or sublocal scope (in a subprocedure). 
Procedures and subprocedures can be functions and return a value to the caller. You can use the name of a function in an expression as if it were a variable name. 
The system allocates and initializes a private data area for each activation of a procedure or subprocedure. After each activation completes execution, the system deallocates its data area. 
Procedures and subprocedures can receive variables, constant expressions, and procedure names passed as parameters. (The MAIN procedure does not receive parameters.) 
FORWARD declarations let you reference procedures and subprocedures before their bodies occur in the source code. Thus, you can declare their bodies in any order. 
Procedures and subprocedures can call themselves; that is, they can be recursive. 
~ 
Procedures and subprocedures differ as follows: 
•	Procedures have global scope; you use procedures for operations needed throughout the program. Subprocedures have local scope; you use subprocedures for operations needed within a procedure. 
•	Procedures can contain subprocedures; subprocedures cannot contain subprocedures. 
•	Unlike subproc~dures, procedures can be referenced as external procedures by procedures declared in other compilations. 
• A procedure has a 127-word primary storage area and a larger secondary area. A subprocedure has a 31-word primary area and no secondary area. 
• The system invokes subprocedures more rapidly than procedures. For subprocedures, it uses the BSUB instruction; for procedures, it uses the PCAL instruction. These instructions are described in the System Description Manual for your system. 
16-2 
~ 82581 AOO 3/85 
~ 
PROCEDURES AND SUBPROCEDURES Characteristics of Procedures and Subprocedures 
• When you invoke a procedure, the operating system saves the environment of the calling procedure or subprocedure. It restores the environment when the invoked procedure completes execution. 
When you invoke a subprocedure, the operating system saves only the location to which control is to return when the invoked subprocedure completes execution. 
• Within procedures, initializations and statements can refer to global variables or to local variables declared in that procedure. 
Within subprocedures, initializations and statements global variables, to local variables declared in the procedure, or to sublocal variables declared in that 
• Subprocedures can have the following attribute~only: VARIABLE Subprocedure parameters are optional. 
Procedures can have the following attributes: 
can refer to encompassing subprocedure. 
-'f82581 AOO 3/85 
MAIN 
RESIDENT 
CALLABLE 
PRIV 
INTERRUPT 
VARIABLE 
This procedure executes first when you run the program. 
Procedure's instruction codes are not swapped in and out of main memory when you run the program. 
Procedure executes in privileged mode, but nonprivileged procedures can call it. 
Procedure executes in privileged mode, and only privileged procedures can call it. 
Only operating system interrupt handlers can use this attribute. When returning to its caller, the procedure executes an IXIT (rather than an EXIT) instruction. 
Procedure parameters are optional. 
EXTENSIBLE You can add new parameters to the procedure without recompiling the caller. 
16-3 
PROCEDURES AND SUBPROCEDURES
Procedure and Subprocedure Declarations 
PROCEDURE AND SUBPROCEDURE DECLARATIONS 
The syntax of a procedure or subprocedure declaration is: 
<type> ] { PROC } <identifier> { SUBPROC } 
[ <formal-param-name> [ , <formal-param-name> ] .•• ) ] 
[ <attribute> [ , <attribute ] ... ] ; 
[ <formal-param-specif ication> 
[ , <formal-param-specification> ] ••• 
{ <body> }
{ FORWARD }
{ EXTERNAL } !For procedures only 
<type> 
specifies that the procedure or subprocedure is a function that returns a value and indicates the data type of the returned value. <type> is one of: 
16-4 
~ 82581 AOO 3/85 
STRING INT INT(32) FIXED [ 
REAL REAL(64) 
<identifier> 
<fpoint> ) ] 
is the name of the procedure or subprocedure. 
<formal-param-name> 
is the name of a formal parameter. The number of formal parameters you can declare is limited by space available in the parameter area. See "Parameter Area" in this section. 
<attribute> 
PROCEDURES AND SUBPROCEDURES Procedure and Subprocedure Declarations 
For a subprocedure, <attribute> can be VARIABLE only. 
For a procedure, <attribute> can be one or more of the following, as defined under "Attributes" in this section: 
MAIN I INTERRUPT RESIDENT CALLABLE
PRIV 
VARIABLE I EXTENSIBLE 
<formal-param-specif ication> 
specifies the data type of a formal parameter and whether
it is a value or reference parameter. See "Formal Parameter 
Specifications" in this section. 
<body> 
is a BEGIN-END construct that contains declarations and statements. See "Procedure and Subprocedure Bodies" in this section. 
FORWARD 
means the declaration for the body occurs later in the source file (procedures) or later in this procedure (subprocedures). 
EXTERNAL 
applies to procedures only and means the procedure body is declared in another compilation such as a part of the operating system or a user library. 
Operating system external declarations are contained in a system file that you can specify in a SOURCE directive. The system file is $SYSTEM.SYSTEM.EXTDECS[<n>], where: 
EXTDECSO = current release version
EXTDECSl = current release version minus one EXTDECS = current release version minus two 
Af'82581 AOO 3/85 
16-5 
PROCEDURES AND SUBPROCEDURES Formal Parameter Specifications 
Formal Parameter Specifications 
A formal parameter specification defines the parameter type of a formal parameter and whether it is a value or a reference parameter. 
The syntax for the formal parameter specification is: 
<param-type> [ . <formal-param-name> [ ( <referral> ) ] [ .EXT 
[ , [ ] <formal-param-name> [ ( <referral> ) ] ] [ .EXT ] 
<pa ram-type> 
is the parameter type of the formal parameter: 
STRING
INT
INT(32)
FIXED [ ( <fpoint> ) ] 
FIXED(*) REAL REAL(64) STRUCT 
[ <type> ] PROC 
. (period) 
denotes a standard pointer and a reference parameter. The absence of "." or ".EXT" denotes a value parameter. 
. EXT 
denotes an extended pointer and a reference parameter. The absence of "." or ".EXT" denotes a value parameter. 
<formal-param-name> 
is the identifier of a formal parameter, as defined in "Parameters" in this section. 
---···-- ·---------------------' 
16-6 
..., 82581 AOO 3/85 
<referral> 
is the name of a previously declared structure or structure pointer. <referral> is required only if <formal-param-name> 
is a structure pointer. 
Procedure and Subprocedure Bodies 
Procedure and subprocedure bodies contain declarations and statements. 
Procedure bodies and subprocedure bodies are described separately on the following pages. 
Af'82581 AOO 3/85 
16-7 
PROCEDURES AND SUBPROCEDURES Procedure and Subprocedure Bodies 
PROCEDURES AND SUBPROCEDURES Procedure Body 
Procedure Body 
The syntax for the procedure body is: 
BEGIN 
<local-declaration> 
[ <subprocedure-declaration> 
[ <statement> 
END 
<local-declaration> 
is a declaration for one of: 
Simple variable
Array (direct or indirect) Structure (direct or indirect) Equivalenced variable
Pointer
Structure pointer
LITERAL
DEFINE
Label
Entry point
FORWARD subprocedure 
<subprocedure-declaration> 
is as previously described under "Procedure and Subprocedure Declarations" in this section. 
<statement> 
is any executable statement described in Section 15. 
16-8 
Af'82581 AOO 3/85 
....,,- 
Subprocedure Body 
The syntax for the subprocedure body is: 
BEGIN 
<sublocal-declaration> 
[ <statement> 
END 
<sublocal-declaration> 
is a declaration for one of: 
Simple variable
Array (direct only) Structure (direct only) Equivalenced variable Pointer
Structure pointer LITERAL
DEFINE
Label
Entry point 
<statement> 
is any executable statement described in Section 15. 
Sublocal Variables 
Data variables declared in subprocedures must be directly addressed, because the sublocal area has no secondary storage. (See "Primary and Secondary Storage" in Section 5.) If you declare a sublocal indirect array, TAL converts it to a direct array and emits a warning. 
""82581 AOO 3/85 
PROCEDURES AND SUBPROCEDURES Subprocedure Body 
16-9 
PROCEDURES AND SUBPROCEDURES
Invoking Procedures, Subprocedures, and Functions 
Invoking Procedures, Subprocedur~s, and Functions 
You invoke procedures or subprocedures by using their names in CALL statements. You can call a procedure from anywhere in the program. You can call a subprocedure from within the encompassing procedure. 
You invoke functions (typed procedures or subprocedures) by using their names in expressions. 
Statements in the invoked procedure or subprocedure body execute until the last statement or a RETURN statement executes. Program execution then returns to the point following the invocation of the procedure or subprocedure. 
The scope of items declared within a procedure or subprocedure is limited to the same procedure or subprocedure. Thus, a local or sublocal item can have the same name as a global item without conflict. In this case, however, you cannot reference the global i tern. 
Examples 
1. The following example shows two procedures, the second of which ·~ calls the first: 
16--10 
/-j82581 AOO 3/85 
INT c; 
PROC first; BEGIN 
INT a, b; 
!Some code
IF a < b THEN 
RETURN;
c := a - b; 
END; 
PROC second; BEGIN 
!Lots of code CALL first; 
!More code END; 
!Procedure body 
!Calls first procedure 
PROCEDURES AND SUBPROCEDURES Invoking Procedures, Subprocedures, and Functions 
·~ 2. The following example shows (1) a function that has two formal value parameters and (2) a procedure that invokes the function and passes actual parameters to it: 
INT PROC mult (varl, var2): INT varl, 
var2: 
BEGIN
RETURN varl * var2: 
END; 
PROC myproc; BEGIN 
INT numl := 5, num2 := 3, 
answer;
answer := mult (numl, num2); 
END; 
!Formal specifications ! for value parameters 
3. The following example shows a FORWARD declaration for "procb", a procedure that calls "procb" before its body is declared, and the declaration for the body of "procb": 
~ 82581 AOO 3/85 
16-11 
INT g2; 
PROC procb (paraml); INT paraml; 
FORWARD; 
PROC proca; BEGIN 
INT i1 :=2; CALL procb (il); 
END; 
PROC procb (paraml); INT paraml; 
BEGIN
g2 := g2 + paraml: 
END; 
PROC mymain MAIN: BEGIN 
g2 := 314: 
CALL proca; END: 
!FORWARD declaration ! for "procb" 
!Declares "proca" 
!Calls "procb" 
!Declares body for "procb" 
!Calls "proca" 
!Invokes function 
PROCEDURES AND SUBPROCEDURES
Invoking Procedures, Subprocedures, and Functions 
4. The following example shows how to include and invoke external operating system procedures: 
?SOURCE $SYSTEM.SYSTEM.EXTDECS (DEBUG, STOP, 
PROC a MAIN; BEGIN 
INT x, y, z; 
!Code for manipulating x, y, and z 
. . . ) 
If x = 5 THEN CALL STOP; !Calls external procedure CALL DEBUG; 
END; 
5. The following example declares a procedure and a subprocedure that contain local and sublocal items with the same names: 
16-12 
~ 82581 AOO 3/85 
PROC main2 MAIN; BEGIN 
INT a := 4; INT b := 1; INT c; 
SUBPROC sub2 (param2); INT param2; 
BEGIN
INT a : = 5; INT b := 2; 
c := a + b + param2; END; 
a := a + b; 
CALL sub2 (a); END; 
!Declares procedure 
!Declares local items 
!Declares subprocedure 
!Declares sublocal items 
!Sublocal "a" and "b" !End of subprocedure 
!Local "a" and "b" 
!End of procedure 
~ 
ATTRIBUTES 
.....,... 
Subprocedures can have only the VARIABLE attribute. 
Procedures can have the following attributes: 
MAIN I INTERRUPT RESIDENT CALLABLE
PRIV 
VARIABLE I EXTENSIBLE 
MAIN Attribute 
This attribute causes the procedure to execute first when you run the program. When the MAIN procedure completes execution, control passes to the operating system STOP procedure. 
If more than one procedure in a compilation has the MAIN attribute, TAL emits a warning and puts the MAIN attribute with the first MAIN procedure it sees. In the following example, "x" and "y" have the MAIN attribute in the source code, but only "x" has the MAIN attribute 
in 
the object file: 
PROC x MAIN; BEGIN 
CALL this"proc; 
CALL that"proc; END; 
PROC y MAIN; BEGIN 
CALL some"'proc; END; 
INTERRUPT Attribute 
PROCEDURES AND SUBPROCEDURES Attributes 
!This procedure is MAIN in object file 
!Second MAIN procedure is not MAIN in ! object file 
This attribute is used only by operating system interrupt handlers.
It causes TAL to generate an IXIT (interrupt exit) instruction instead 
of an EXIT instruction at the end of execution. An example is: 
PROC int"handler INTERRUPT; BEGIN 
!Do some work END: 
..,82581 AOO 3/85 
16-13 
PROCEDURES AND SUBPROCEDURES Attributes 
RESIDENT Attribute 
This attribute causes procedure code to remain in main memory for the duration of program execution. The operating system does not swap pages of this code. BINDER allocates storage for resident procedures as the first procedures in the code space. An example is: 
PROC proca RESIDENT; BEGIN 
!Do some work END; 
CALLABLE Attribute 
CALLABLE means the procedure can execute privileged instructions, and a nonprivileged procedure can call it. It is the only way a nonprivileged program can become privileged. For information on privileged mode, see the System Description Manual. The fallowing callable procedure calls a privileged procedure (described next): 
PROC proc2 CALLABLE; BEGIN 
CALL priv"proc; END; 
PRIV Attribute 
PRIV means the procedure can execute privileged instructions, and only other privileged procedures can call it. PRIV protects the operating system from unauthorized calls to its internal procedures, as follows: 
Nonprivileged Procedures 
{Application) 
~~-~· 
CALLABLE PRIV Procedures ~----1•• Procedures 
{Operating System) 
The following privileged procedure is called by the callable procedure declared above: 
PROC priv"proc PRIV; BEGIN 
!Privileged instructions END; 
16-14 
4J82581 AOO 3/85 
.._..,., 
VARIABLE Attribute 
This attribute means some or all of the procedure or subprocedure parameters are optional. TAL considers all the parameters to be optional, even if some are required by your code. The following example declares a VARIABLE procedure: 
PROC v (a, b) VARIABLE; INT a, b; 
BEGIN
!Lots of code 
END; 
When a call to a VARIABLE procedure or subprocedure occurs, TAL allocates space in the parameter area for all the parameters and generates a parameter mask, which indicates those actually passed. The called procedure or subprocedure can use the $PARAM function to check for receipt of each parameter. 
VARIABLE Parameter Mask 
The parameter mask for a VARIABLE procedure or subprocedure has the following characteristics: 
• Each formal parameter corresponds to one bit. For 16 or fewer parameters, TAL generates a single-word mask. For more than 16 parameters, TAL generates a doubleword mask. 
• The mask is right justified. For a single-word mask, bit <15> corresponds to the last parameter. For a doubleword mask, bit <15> of the low-order word corresponds to the last parameter. 
• For each passed parameter, TAL sets the corresponding bit to 1. For each omitted parameter, TAL sets the corresponding bit to O. 
For procedures, a single-word mask resides in location L[-3]; a doubleword mask resides in location L[-4:-3]. For subprocedures, either single-word or doubleword mask resides between the last parameter and the caller's return address. 
Figure 16-1 shows an example of a single-word parameter mask for a VARIABLE procedure "zz", whose formal parameters correspond to mask bits <10:15>. The mask indicates which parameters are passed by procedure "aa". 
-'i' 82581 AOO 3/85 
PROCEDURES AND SUBPROCEDURES Attributes 
16-15 
PROCEDURES AND SUBPROCEDURES Attributes 
PROC zz (pl,p2,p3,p4,p5,p6) VARIABLE; INT pl,p2,p3,p4,p5,p6; 
Local Data for "aa" 
Omitted 
a 
BEGIN 
END; 
.... pl 
__.. 
-- p2 ... 
L[-11] 
PROC aa MAIN; BEGIN 
INT a, b, c; 
CALL zz (,a,b,,c); END; 
~ L[1] 
Local data
for "zz" ~ 
lrp5 p6 
011010 
<10> <15> 
L[-3] 
Figure 16-1. VARIABLE Single-Word Parameter Mask 
Figure 16-2 shows a doubleword mask for the following example, in which a VARIABLE procedure declares 18 formal parameters, and another procedure passes five actual parameters to it. 
INT aa, dd, ee, ff, jj; 
PROC mask (a,b,c,d,e,f,g,h,i,j,k,l,m ,n,o,p,q,r) VARIABLE; INT a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r; 
BEGIN
!Do more processing 
END; 
PROC caller; BEGIN 
!Do processing
CALL mask (aa,,,dd,ee,ff,,,,jj); 
END; 
16-16 
~ 82581 AOO 3/85 
··~ 
__.. p 
p3 b 
p4 
Omitted 
c 
Omitted 
%000032 
)' y 
/ 
/ 
I......,,' 
PROCEDURES AND SUBPROCEDURES Attributes 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 aa 
0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 dd ee ff jj 
Figure 16-2. VARIABLE Doubleword Parameter Mask 
Bit Numbers: 
L (-4]: 
L [-3]: 
Parameter Checking 
The following example shows a VARIABLE procedure that contains parameter-checking statements: 
PROC errmsg (msg, count, errnum) VARIABLE; 
INT .msg; INT count; INT errnum; 
!Required parameter !Required parameter !Optional parameter 
!If required parameters missing 
!Default for optional parameter 
BEGIN
I F NOT $PARAM 
( m s g ) OR
NOT $PARAM (count) THEN 
RETURN;
IF NOT $PARAM (errnum) THEN errnum := O;
!Process the error . • . 
END; 
EXTENSIBLE Attribute 
EXTENSIBLE means you can later add new parameters to the procedure without recompiling the caller. An example declaration is: 
PROC x (a, b) EXTENSIBLE; !Declares EXTENSIBLE procedure INT a, b; 
BEGIN
!Do some work 
END; 
TAL considers all parameters of an EXTENSIBLE procedure to be optional, even if some are required by your code. When a call to an EXTENSIBLE procedure occurs, TAL allocates space in the parameter area 
for all the parameters and generates a parameter mask, which indicates 
-'182581 AOO 3/85 
16-17 
PROCEDURES AND SUBPROCEDURES Attributes 
those actually passed. The called procedure can use the $PARAM function to check for a passed parameter, as was described for 
VARIABLE procedures. 
A new procedure with or without parameters can be extensible. An existing procedure that has no parameters cannot become extensible. An existing VARIABLE procedure can become extensible as follows. 
Converting Procedures From VARIABLE to EXTENSIBLE 
A VARIABLE procedure can become extensible only if: 
• It has 15 or fewer parameters. 
• It has 16 or fewer words of parameters. 
• All parameters, except the last parameter, are one word long. 
When converting a VARIABLE procedure, the required form for the EXTENSIBLE attribute is: 
EXTENSIBLE { <param-count> 
<param-count> 
an INT arithmetic expression in the range 1 through 15 that defines the number of parameters declared when the procedure was VARIABLE. 
The following example converts an existing VARIABLE procedure to an ENTENSIBLE procedure: 
PROC errmsg {msg, count, errnum, new"param) EXTENSIBLE {3); 
16-18 
INT .msg;
INT count;
INT errnum; INT new"param; 
BEGIN
!Do something 
END; 
!Required parameter !Required parameter !Optional parameter !New optional parameter 
"'182581 AOO 3/85 
PROCEDURES AND SUBPROCEDURES Attributes 
'~ EXTENSIBLE Parameter Mask
The format for EXTENSIBLE parameter masks differs from that of 
VARIABLE procedure masks, as follows: 
• Each formal parameter corresponds to one or more bits, depending on the size of the parameter. Each bit represents one word of a parameter. 
• The mask is left justified. For a single-word mask, bit <O> corresponds to the first parameter if it is a single word. For a doubleword mask, bit <O> of the low-order word corresponds to the first parameter. 
• For each passed parameter, TAL sets all the bits for that parameter to 1. For each omitted parameter, TAL sets the corresponding bits to O. The $PARAM function checks only the high-order bit that corresponds to a parameter. (Word parameters have only one corresponding bit.) 
Figure 16-3 shows a single-word mask for the following example in which an EXTENSIBLE procedure declares INT, INT(32), and FIXED formal parameters. The seven formal parameters occupy 12 parameter words. Another procedure passes four actual parameters to it. 
INT aa, ff, gg; ...._.,, FIXED cc; 
PROC baz (a,b,c,d,e,f ,g) EXTENSIBLE; INT a,d,f ,g;
INT(32) b,e;
FIXED c ; 
BEGIN
!Code for processing 
END; 
PROC maz; BEGIN 
!Code for processing
CALL baz (aa,,cc,,,ff,gg); 
END; 
-'182581 AOO 3/85 
16-19 
PROCEDURES AND SUBPROCEDURES Attributes 
Bit Numbers: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
L[-3]: 1001111000110000 aa(cc) ffgg 
Figure 16-3. EXTENSIBLE Single-Word Parameter Mask 
Figure 16-4 shows a doubleword mask for the following example in which an EXTENSIBLE procedure declares INT, INT(32), and FIXED formal parameters. The 12 formal parameters occupy 20 parameter words. Another procedure passes five actual parameters to it. 
~ 
16-20 
~ 82581 AOO 3/85 
INT aa, ff, gg; FIXED cc; 
INT(32) 
PROC baz INT 
j j ; 
(a,b,c,d,e,f ,g,h,i,j,k,l) a,d,f ,g,k,l; 
EXTENSIBLE; 
INT(32) b,e,h,i,j; 
FIXED c ; BEGIN 
!Do more work END; 
PROC maz; BEGIN 
!Do some work
CALL baz (aa,,cc,,,ff,gg,,,jj); 
END; 
Bit Numbers: 0 1 2 3 4 5 6 
7 8 
9 10 11 12 13 14 15 
L[-4]: 1001111000110000 aa(cc) ffgg 
L[-3]: 1100000000000000 (jj) 
Figure 16-4. EXTENSIBLE Doubleword Parameter Mask 
~.._.,,i 
Number of Parameter Words Passed 
~· 
In addition to the parameter mask, TAL generates a one-word value that represents the number of parameter words passed to the EXTENSIBLE 
procedure. TAL stores the negative form of that value in the parameter area immediately preceding the three-word stack marker. For example, if four parameter words are passed, TAL stores -4. 
Procedure Entry Sequence 
On entry to an EXTENSIBLE procedure, the system loads the following values on the register stack: 
• For a converted VARIABLE procedure: 
--R[O] = Number of parameters when the procedure was VARIABLE 
--R[l] = Number of parameter words when it was VARIABLE --R[2] = Number of parameter words now expected
RP must be 2. 
• For a procedure that was EXTENSIBLE to begin with: 
--R[O] = Number of parameter words expected 
RP must be O. 
The system then executes the ESE instruction, which uses the RP setting to tell the cases apart. ESE sets RP to 7 but does not save the values in RO through R7. 
For a converted VARIABLE procedure, ESE converts the mask format to the EXTENSIBLE format. It adds the needed bits and words and initializes them to O. It does not initialize any extra words on the register stack caused by the stack movement. 
Af'82581 AOO 3/85 
PROCEDURES AND SUBPROCEDURES Attributes 
16-21 
PROCEDURES AND SUBPROCEDURES Parameters 
PARAMETERS 
Each parameter requires a formal parameter name and a formal parameter specification. 
Formal parameter names provide identifiers that have local scope if declared in a procedure body or sublocal scope if declared in a subprocedure body. When a...call occurs, each formal parameter assumes 
the. value of the corresponding passed parameter. 
A formal parameter specification defines the parameter type of a formal parameter and whether it is a value or reference parameter. 
Parameter Area 
The calling procedure enters the actual parameter values in the parameter area before transferring control to the called procedure or subprocedure. 
For procedures, the parameter area limit is 29 words, less storage
required for a single-word or doubleword parameter mask, if present.
For EXTENSIBLE procedures, a word value representing the number of
parameter words passed also resides in the parameter area. Thus, f.._ the space available for the parameters of a procedure is: 
Parameter Words 
VARIABLE procedure with single-word mask 28 VARIABLE procedure with doubleword mask 27 EXTENSIBLE procedure with single-word mask 27 EXTENSIBLE procedure with doubleword mask 26 Any other procedure 29 
For subprocedures, the parameter area limit is 30 words, less storage required for sublocal variables and for a single-word or doubleword VARIABLE parameter mask, if any. 
16-22 
4J82581 AOO 3/85 
-~ 
Figure 16-5 shows an example of parameter storage. 
INT .buffer[0:20]; 
PROC b (parml, parm2); INT parml, parm2; 
BEGIN
INT bAlocalAarray[0:12]; 
buffer[O] := parml + parm2; buffer[l] := parml - parm2; buffer[2] := parml * parm2; 
END; !End of "b" 
PROC a MAIN; BEGIN 
INT first, second, 
aAlocalAarray[0:2]; 
CALL b (first, second); END; !End of "a" 
parml 
parm2 
Global data 
Local data for MAIN procedure 
first 
second 
p 
E 
L 
Local data for "b" 
L[-4] 
L[-3] 
L[O] 
S[O] 
Value Parameters 
Figure 16-5. Parameter Storage 
If a procedure or subprocedure specifies a formal parameter without an indirection symbol ("."or ".EXT"), you pass a value parameter. (Structures and arrays must be reference parameters.) 
Statements in the called procedure body access the passed value parameter directly in the parameter area. They can use a value parameter as working space within the procedure without affecting the actual variables used to generate the value for that parameter. 
A passed value parameter can be any arithmetic expression. The formal parameter specification of the called procedure defines the data type and storage allocation for the passed parameter (one word for INT and STRING, two words for INT(32) and REAL, and four words for REAL(64) and FIXED). 
1'82581 AOO 3/85 
16-23 
PROCEDURES AND SUBPROCEDURES Parameters 
PROCEDURES AND SUBPROCEDURES Parameters 
The system right justifies STRING value parameters in the parameter area as if they were I.NT expressions. If you want to left justify a STRING parameter in bits <0:7> of the word, shift the value 8 bits to the left when you call the procedure; for example: 
CALL procl (byte '<<' 8) 
FIXED Value Parameters 
The system scales FIXED value parameters up or down to match the <fpoint> in the parameter specification. If the <fpoint> of the passed parameter is greater than the <fpoint> in the parameter specification, precision is lost according to the amount of scaling required. 
To prevent scaling of the <fpoint> of the passed parameter, you
can use a parameter type of FIXED (*). The called procedure treats the parameter as having an <fpoint> of 0. 
Procedures as Value Parameters 
A procedure can declare a procedure as a formal parameter. TAL treats the identifier associated with a parameter type PROC as a procedure name within the procedure body. TAL allocates one word in the parameter area for the PEP number of the procedure to be passed. 
If the passed procedure itself has parameters, you must make certain that all parameters are supplied. TAL cannot perform this check.
If the passed procedure is VARIABLE or EXTENSIBLE, you must supply the correct parameter mask. TAL treats any missing parameters in the CALL statement as type INT value parameters. 
If the passed procedure has reference parameters, each must be preceded by an @ symbol in the call. 
16-24 
~ 82581 AOO 3/85 
,......,, 
PROCEDURES AND SUBPROCEDURES Parameters 
The following example shows a procedure passed as a value parameter: 
PROC a(t); !Declares procedure to be passed STRING . t ; 
BEGIN
t ':=' "NO MAN IS AN ISLAND."; 
END; 
PROC p(q); PROC q; 
BEGIN
STRING .s[0:20]; CALL q(@s); 
END; 
PROC m MAIN; BEGIN 
CALL p(a); END; 
Reference Parameters 
!Declares procedure to be called !Formal PROC parameter specification 
!Calls "q" and passes address of array "s"; ! "s" gets "NO MAN IS AN ISLAND." 
!Calls "p" and passes procedure "a" as a ! parameter 
If a procedure specifies a formal parameter with an indirection symbol (. or .EXT), you pass a reference parameter. TAL allocates storage in the parameter area for the address of the variable (one word for a 
standard pointer and two words for an extended pointer). If required by the procedure, TAL converts standard addresses to extended addresses. Converting extended addresses to standard addresses, however, is an error since the segment information in the extended pointer is lost. 
To pass a parameter by reference, place the name of the variable in the CALL statement. TAL generates the address of the variable and places it in the parameter area. Statements within the called procedure access the actual variable indirectly through the parameter location. The called procedure can store values in reference parameters and modify the actual variables. 
Aj82581 AOO 3/85 
16-25 
PROCEDURES AND SUBPROCEDURES Parameters 
The caller can change the contents of a pointer by prefixing the pointer name with an @symbol and passing it by reference. The following example shows how this is done: 
PROC p ( ptr ); INT .ptr; 
BEGIN
p t r := %100000; 
END; 
PROC q; BEGIN 
INT .upper32k;
CALL p ( @upper32K ); 
END; 
Arrays and structures must be reference parameters. The previous example in "Procedures as Value Parameters" specifies array "s" as a formal reference parameter. 
FIXED Reference Parameters 
For FIXED reference parameters, the <fpoint> of the passed parameter must match the <fpoint> in the parameter specification. If they do not match, TAL does not perform scaling and issues a warning. The statements in the called procedure then apply the <fpoint> in the 
formal parameter specification to the passed parameter. 
Mixing Data Types of Formal and Actual Parameters 
You can pass a non-STRING parameter to a formal reference parameter that has a standard byte address. TAL converts the word address of the actual parameter to a byte address. 
You can pass a STRING variable to formal reference parameter that has a word address. However, when TAL converts the byte address of the actual parameter to a word address by right shifting, the byte number is lost. If the actual variable is aligned on an even-byte boundary, this is no problem, but if it is aligned on an odd-byte boundary, you access a byte outside the variable. TAL issues a warning message that right shifting occurred. 
,...... 
16-26 
/182581 AOO 3/85 
PROCEDURES AND SUBPROCEDURES Entry-Point Declaration 
1~ ENTRY-POINT DECLARATION
The entry-point declaration associates a name with a secondary 
location in a procedure or subprocedure where execution can start. 
The syntax for the entry-point declaration is: 
ENTRY <entry-point-name> [ , <entry-point-name> ] ..• 
<entry-point-name> 
is the name of an entry point in the procedure or subprocedure body. It is an alternate name to use when invoking the procedure or subprocedure. 
Procedure and subprocedure entry points are discussed separately below. 
Procedure Entry Points 
The following rules apply: 
1.	Declare all entry-point names for a procedure within the procedure. 
2.	Place each entry-point name and a colon (:) at a point in the procedure at which execution is to start. 
3.	To invoke an entry point, reference its name in a CALL statement located in any procedure or subprocedure. Include any actual parameters as if you were calling the procedure~name. (~ee Example 1.) 
4.	A GOTO statement to an entry point is not allowed. 
5.	You can declare FORWARD or EXTERNAL procedure entry points. The syntax is the same as for a FORWARD or EXTERNAL procedure declaration, except that you specify the name of the entry point. The declaration must include all formal parameters and parameter specifications declared for the procedure. (See Example 2.) 
~ 82581 AOO 3/85 
16-27 
PROCEDURES AND SUBPROCEDURES Entry-Point Declaration 
Each time you invoke a procedure entry point, all local variables receive their initial values. 
For a procedure entry point, the reference @<entry-point-name> yields the PEP number of the entry point. 
Subprocedure Entry Points 
The following rules apply: 
1.	Declare all entry-point names for a subprocedure within the subprocedure. 
2.	Place each entry-point name and a colon (:) at a point in the subprocedure at which execution is to start. 
3. To invoke an entry point, reference its name in a CALL statement located anywhere in the encompassing procedure, such as in another subprocedure in the same scope. Include any actual parameters as if you were calling the subprocedure name. 
4. A GOTO statement to an entry point is not allowed. 
5. You can declare FORWARD subprocedure entry points. The syntax is the same as for a FORWARD subprocedure declaration except that you specify the name of the entry point. The declaration 
must include all formal parameters and parameter specifications declared for the subprocedure. 
Each time a you invoke a subprocedure entry point, all sublocal variables receive their initial values. 
For a subprocedure entry point, the reference @<entry-point-name> yields the code address of the entry point. 
.~ 
t 
16-28 
-'1' 82581 AOO 3/85 
"-".. Examples 
1. This example illustrates use of entry points: 
~ 82581 AOO 3/85 
16-29 
INT toAthis := 314; 
PROC addA3 (g2); INT .g2; 
!Global data declaration 
!Declares entry points 
!Entry-point location !Entry-point location 
!Main procedure 
!Calls entry point 
BEGIN 
addA2 addAl END; 
ENTRY addA2, addAl; INT m2 := 1; 
g2 := g2 + m2; g2 := g2 + m2; g2 := g2 + m2; 
PROC mymain MAIN; BEGIN 
CALL addAl (toAthis); END; 
2. This example shows FORWARD declarations for entry points: 
INT toAthis := 314; 
PROC addAl (g2); INT .g2; 
FORWARD; 
PROC addA2 (g2); INT .g2; 
FORWARD; 
PROC addA3 (g2); INT .g2; 
FORWARD; 
PROC mymain MAIN; BEGIN 
CALL addAl (toAthis); END; 
PROC addA3 (g2); INT .g2; 
!Declares a FORWARD entry point 
!Declares a FORWARD entry point 
!Declares a FORWARD procedure 
!Main procedure 
!Calls entry point 
!Body for FORWARD procedure 
!Declares entry points 
!Entry-point location !Entry-point location 
BEGIN 
ENTRY addA2, addAl; INT m2 := 1; 
g2 := g2 + m2; g2 := g2 + m2; g2 := g2 + m2; 
PROCEDURES AND SUBPROCEDURES Entry-Point Declaration 
SECTION 17 
STANDARD FUNCTIONS 
TAL provides a variety of standard functions that perform frequently used operations. 
This section contains: 
• A summary of standard functions, organized by operational group 
• The syntax of each function, listed in alphabetic order, and the need for optional microcode, if any 
STANDARD FUNCTIONS BY OPERATIONAL GROUP 
Functions are summarized within the following groups: 
•	Type Transfer 
•	Address Conversion 
•	Character Test 
•	Minimum-Maximum 
•	Carry and Overflow Test 
•	Fixed-Point Value and Scale 
•	Structure 
•	Parameter-Checking and Register Pointer 
•	Miscellaneous 
.., 82581 AOO 3/85 
17-1 
STANDARD FUNCTIONS
Standard Functions by Operational Group 
Type Transfer 
The type-transfer functions convert a variable of one data type into a variable of another data type. As indicated, some functions apply rounding to the result. This means if the least significant digit is less than 5, it is truncated; otherwise, the result is rounded up. 
17-2 
$DBL 
$DBLL 
$DBLR 
$DFIX 
$EFLT 
returns a signed INT(32) value from an INT, FIXED(O), REAL, or REAL(64) expression. 
returns an INT(32) value from two INT values. 
returns a signed INT(32) value from an INT, FIXED(O), REAL, or REAL(64) expression and applies rounding to the result. 
returns a 64-bit integer from a signed doubleword integer (the equivalent of a signed right shift of 32 positions). 
returns a REAL(64) value from an INT, INT(32), FIXED, or REAL expression. 
$EFLTR returns a REAL(64) value from an INT, INT(32), FIXED, or REAL expression and applies rounding to the result. 
$FIX 
$FIXD 
$FIXI 
$FIXL 
$FIXR 
$FLT 
$FLTR 
$HIGH 
$!FIX 
$INT 
returns a FIXED(O) value from an INT, INT(32), REAL, or REAL(64) expression and applies rounding to the value. 
returns the INT(32) equivalent of a FIXED expression treated as a 64-bit integer. 
returns the signed INT equivalent of a FIXED expression treated as a 64-bit integer. 
returns the unsigned INT equivalent of a FIXED expression treated as a 64-bit integer. 
returns a FIXED(O) value from an INT, INT(32), REAL, or REAL(64) expression and applies rounding to the result. 
returns a REAL value from an INT, INT(32), FIXED, or REAL(64) expression. 
returns a REAL value from an INT, INT(32), FIXED, or REAL(64) expression and applies rounding to the result. 
returns an INT value from the left half of an INT(32) expression. 
returns a 64-bit integer from a signed INT expression (the equivalent of a signed right shift of 48 positions). 
returns an INT value from INT(32), FIXED(O), REAL, or REAL(64) expression. 
.,, 82581 AOO 3/85 
$INTR 
$LFIX 
$UDBL 
STANDARD FUNCTIONS Standard Functions by Operational Group 
returns an INT value from an INT(32), FIXED(O), REAL, or REAL(64) expression and applies rounding to the result. 
returns a 64-bit integer from an unsigned INT expression. 
returns an INT(32) value from an unsigned INT expression. 
Table 17-1 cross-references the type-transfer functions according to data type: 
Table 17-1. Type-Transfer Functions by Data Type 
FROM INT 
TO 
INT(32) FIXED REAL REAL(64) 
INT $DBL $IFIX $FLT $UDBL $LFIX $FLTR 
$EFLT $EFLTR 
$EFLT $EFLTR 
$EFLT $EFLTR 
$EFLT $EFLTR 
INT(32) $INT ~ $HIGH 
FIXED $FIX!
$FIXL $FLTR 
REAL $INT 
Address Conversion 
$DBL $FIX $INTR $DBLR $FIXR 
REAL(64) $INT
$INTR $DBLR 
$DFIX $FLT $FLTR 
$FIXD $FLT 
$DBL $FIX $FLT $FIXR $FLTR 
These functions convert standard addresses to extended addresses or extended addresses to standard addresses. 
$XADR converts a standard address to an extended address. 
$LADR converts an extended address to a standard address. 
-'182581 AOO 3/85 
17-3 
STANDARD FUNCTIONS
Standard Functions by Operational Group 
Character Test 
These functions test for an alphabetic, a numeric, or a special (nonalphanumeric) ASCII character. They return a true value if the 
character passes the test or a false value if the character fails.
You typically use these functions in conditional expressions to direct the flow of program execution. 
$ALPHA tests an expression for an alphabetic character. 
$NUMERIC tests an expression for a numeric character. 
$SPECIAL tests an expression for a special character. 
Minimum-Maximum 
These functions return the maximum or the minimum of two expressions. 
$LMAX 
$LMIN 
$MAX 
$MIN 
returns the maximum of two unsigned INT expressions. 
returns the minimum of two unsigned INT expressions. 
returns the maximum of two signed INT, INT(32), FIXED, REAL, or REAL(64) expressions of the same type. 
returns the minimum of two signed INT, INT(32), FIXED, REAL, or REAL(64) expressions of the same type. 
Carry and Overflow Test 
These functions check the state of the carry or overflow indicator in the ENV register. They return a true value if the indicator is on or a false value if it is off. Typically, you use these functions in conditional expressions to direct the flow of program execution. 
$CARRY tests the state of the carry indicator. 
$OVERFLOW tests the state of the overflow indicator. 
17-4 
~ 82581 AOO 3/85 
~, 
Fixed-Point Value and Scale 
STANDARD FUNCTIONS Standard Functions by Operational Group 
These functions assist you in manipulating FIXED expressions. 
$POINT returns the <fpoint> value, in integer form, associated with a FIXED expression. 
$SCALE moves the position of the implied decimal point by adjusting the internal representation of the expression. 
Structure 
These functions return information about previously defined data structures. 
$LEN returns the unit length in bytes of a variable. 
$OCCURS returns the number of occurrences of a STRUCT item. 
$OFFSET returns the offset in bytes of a structure item from the structure base. 
$TYPE returns a value indicating the type of a variable. 
Parameter-Checking and Register Pointer 
These functions check for the presence or absence of a parameter in a procedure or subprocedure call or return the current setting of the TAL register pointer. 
$PARAM checks for the presence or absence of a parameter in a procedure or subprocedure call. 
$RP returns the current setting of the TAL register pointer. 
Miscellaneous 
These functions return the absolute value or the one's complement of an expression. 
$ABS returns the absolute value of an expression. 
$COMP returns the one's complement of an INT expression. 
AJ182581 AOO 3/85 
17-5 
STANDARD FUNCTIONS $ABS Function 
$ABS FUNCTION 
The $ABS function returns the absolute value of an expression. The returned value has the same data type as the expression. 
The syntax for the $ABS function is: 
$ABS ( <expression> 
<expression> 
is an expression of any type as defined in Section 13 of this manual. 
$ABS sets the overflow indicator if the absolute value of a negative number cannot be represented in two's complement or real format 
(depending on the type of the expression). For example, $ABS (-32768) causes an arithmetic overflow. 
Example 
This example assigns the absolute value of "i2" to "j2". Since "i2" is equal to -5, "j2" receives the absolute value of (-5), which is 5. 
INT i2 := -5,
INT j2;
j2 := $ABS(i2); !Sets "j2" equal to absolute value of (-5) 
17-6 
.-,82581 AOO 3/85 
,._...., 
$ALPHA FUNCTION 
The $ALPHA function tests the right half of an INT value for the presence of an alphabetic character. 
The syntax for the $ALPHA function is: 
$ALPHA ( <int-expression> 
<int-expression> 
is an INT expression. $ALPHA inspects bits <8:15> of <expression> and ignores bits <0:7>. 
It tests for an alphabetic character according to the following criteria: 
<int-expression> >= "A" AND <int-expression> <= "Z" OR <int-expression> >= "a" AND <int-expression> <= "z" 
$ALPHA sets the condition code indicator to "=" if an alphabetic character occurs. If you plan to check the condition code, you must do so before an arithmetic operation or assignment occurs. 
If the character passes the test, $ALPHA returns a -1 (true); otherwise, it returns a 0 (false). 
Example 
This example tests for an alphabetic character in expression "some"'char": 
STRING some"'char:
IF $ALPHA (some"'char) THEN . . . 
~ 82581 AOO 3/85 
17-7 
STANDARD FUNCTIONS $ALPHA Function 
STANDARD FUNCTIONS $CARRY Function 
$CARRY FUNCTION 
The $CARRY function checks the state of the carry bit in the ENV register. 
The syntax for the $CARRY function is: 
$CARRY 
If the carry bit is on, $CARRY returns a -1 (true); otherwise, it returns a 0 (false). 
Example 
This example tests the state of the carry bit: 
IF $CARRY THEN . . . ; 
For additional examples, see the SCAN statement in Section 15. 
17-8 
"'82581 AOO 3/85 
,.__,.. 
STANDARD FUNCTIONS $COMP Function 
The $COMP function obtains the one's complement of an INT expression. 
The syntax for the $COMP function is: 
$COMP ( <int-expression> 
<int-expression> 
is an INT expression. 
Example 
This example assigns "someAint" a value equal to the one's complement of 10: 
INT someAint; 
someAint := $COMP (10); 
~ 82581 AOO 3/85 
17-9 
STANDARD FUNCTIONS $DBL Function 
$DBL FUNCTION 
The $DBL function returns a signed INT(32) value from an INT, FIXED(O), REAL, or REAL(64) expression. 
The syntax for the $DBL function is: 
$DBL ( <expression> 
<expression> 
is an INT, FIXED(O), REAL, or REAL(64) expression. 
$DBL sets the overflow indicator if the expression is too large in magnitude to be represented by a 32-bit two's complement integer. 
This function needs the following optional microcode: 
System FIXED 
Nonstop l+ QLD
CQD CED 
N o n s t o p CQD 
Example 
CFD CED 
REAL REAL(64) 
CFD QLD 
This example converts the INT variable "i2" into a signed INT(32) value and assigns the result to the INT(32) variable "b32": 
INT i2 := %177775; INT(32) b32; 
b32 := $DBL(i2); 
17-10 
-1182581 AOO 3/85 
~: 
$DBLL FUNCTION 
1~ 
The $DBLL function returns an INT(32) value from two INT values. 
The syntax for the $DBLL function is: 
$DBLL ( <int-expression> , <int-expression> ) 
<int-expression> 
is an INT expression. 
To form the INT(32) value, $DBLL places the first INT value in the upper 16 bits and the second INT value in the lower 16 bits. 
Examples 
1. This example returns the INT(32) value formed from "firstAint" and "secondAint": 
INT firstAint, secondAint; !Declares variables INT(32) someAdouble; 
someAdouble := $DBLL (firstAint, secondAint); 
2. This example returns an extended (32-bit) address in the current user code segment: 
INT .EXT p; !Declares extended pointer 
@p := ($DBLL (2, 7)) '<<' 1; !Assigns address in code segment 
"'f82581 AOO 3/85 
17-11 
STANDARD FUNCTIONS $DBLL Function 
STANDARD FUNCTIONS $DBLR Function 
$DBLR FUNCTION 
The $DBLR function returns a signed INT(32) value from an INT, FIXED(O), REAL, or REAL(64) expression and applies rounding to the result. 
The syntax for the $DBLR function is: 
$DBLR ( <expression> 
<expression> 
is an INT, FIXED(O), REAL, or REAL(64) expression. 
$DBLR sets the overflow indicator if the expression is too large in magnitude to be represented by a 32-bit two's complement integer. 
This function needs the following optional microcode: 
~ 
I 
17-12 
..,., 82581 AOO 3/85 
System 
N o n s t o p 
N o n s t o p 
1 + 
FIXED REAL REAL(64) 
QLD CFDR QLD CQD CEDR 
CQD CFDR CEDR 
~· 
$DFIX FUNCTION 
The $DFIX function returns a 64-bit integer from a signed INT(32) expression. 
The syntax for the $DFIX function is: 
$DFIX ( <dbl-expression> , <fpoint> ) 
<dbl-expression> 
is a signed INT(32) arithmetic expression. 
<fpoint> 
is a value in the range -19 through +19 that specifies the position of the implied decimal point, as described in Section 8 under "Simple Variable Declaration." 
$DFIX converts a signed INT(32) expression to a 64-bit integer by performing the equivalent of a signed right shift of 32 positions. 
This function needs the following optional microcode: 
System 
Nonstop l+ 
INT(32) FIXED 
CDQ QUP QDWN 
Nonstop CDQ 
-'182581 AOO 3/85 
STANDARD FUNCTIONS $DFIX Function 
17-13 
STANDARD FUNCTIONS $EFLT Function 
$EFLT FUNCTION 
The $EFLT function returns a R~AL(64) value from an INT, INT(32), FIXED, or REAL expression. 
The syntax for the $EFLT function is: 
$EFLT ( <expression> 
<expression> 
is an INT, INT(32), FIXED, or REAL expression. 
This function needs the following optional microcode: 
17-·14 
4J82581 AOO 3/85 
System 
Nonstop 1+ 
Nonstop 
INT INT(32) 
CIE CDE 
CIE CDE 
FIXED REAL 
REAL(64) 
QLD CFE QLD CQE 
CQE CFE 
~ 
l 
'-"'' 
$EFLTR FUNCTION 
The $EFLTR function returns a REAL(64) value from an INT, INT(32), FIXED, or REAL expression and applies rounding to the result. 
The syntax for the $EFLTR function is: 
$EFLTR <expression> 
<expression> 
is an INT, INT(32), FIXED, or REAL expression. 
This function needs the following optional microcode: 
System 
Nonstop 1+ 
Nonstop 
INT INT(32) 
CIE COE 
CIE COE 
FIXED REAL 
REAL(64) 
~ 82581 AOO 3/85 
17-15 
QLD CFE QLD CQER 
CQER CFE 
STANDARD FUNCTIONS $EFLTR Function 
STANDARD FUNCTIONS $FIX Function 
$FIX FUNCTION 
The $FIX function returns a FIXED(O) value from an INT, INT(32), REAL, or REAL(64) expression. 
The syntax for the $FIX function is: 
$FIX ( <expression> 
<expression> 
is an INT, INT(32), FIXED, REAL or REAL(64) expression. 
$FIX sets the overflow indicator if the expression is too large in magnitude to be represented by a 64-bit two's complement integer. 
This function needs the following optional microcode: ~ 
System 
N o n s t o p 
N o n s t o p 
Example 
1 + 
INT INT( 32 ~ CIQ CDQ 
CIQ CDQ 
FIXED 
QLD 
REAL REAL(64) 
CFQ QLD CEQ 
CFQ CEQ 
This example initializes a FIXED variable with the value that the $FIX function returns from an INT value: 
INT locall;
FIXED local := $FIX(locall); 
17-16 
-'182581 AOO 3/85 
" - " ' 
$ F I XD FUNCTION 
The $FIXD function returns an INT(32) value from a FIXED expression. 
The syntax for the FIXD function is: 
$FIXD ( <fixed-expression> 
<fixed-expression> 
is a FIXED expression, which $FIXD treats as a 64-bit integer ignoring any implied decimal point. 
$FIXD sets the overflow indicator if the result cannot be represented in a signed doubleword. 
This function needs the following optional microcode: 
System 
FIXED 
Nonstop 1+ QLD CQD 
Nonstop CQD 
~ 82581 AOO 3/85 
17-17 
STANDARD FUNCTIONS $FIXD Function 
STANDARD FUNCTIONS $FIXI Function 
$ F I X I FUNCTION 
The $FIXI function returns the signed INT equivalent of a FIXED expression. 
The syntax for the $FIX! function is: 
$FIXI ( <fixed-expression> 
<fixed-expression> 
is a FIXED expression, whi~h $FIXI treats as a 64-bit integer, ignoring any implied decimal point. 
$FIXI sets the overflow indicator if the result cannot be represented in a signed 16-bit integer. 
This function needs the following optional microcode: 
System FIXED 
Nonstop 1+ QLD CQI 
Nonstop CQI 
17-18 
~ 82581 AOO 3/85 
$FIXL FUNCTION 
The $FIXL function returns the unsigned INT equivalent of a FIXED expression. 
The syntax for the $FIXL function is: 
$FIXL ( <fixed-expression> 
<fixed-expression> 
is a FIXED expression, which $FIXL treats as a 64-bit integer, ignoring any implied decimal point. 
$FIXL sets the overflow indicator if the result cannot be represented in an unsigned 16-bit integer. 
This function needs the following optional microcode: 
System FIXED 
Nonstop 1+ QLD CQL 
Nonstop CQL 
~ 82581 AOO 3/85 
17-19 
STANDARD FUNCTIONS $FIXL Function 
STANDARD FUNCTIONS $FIXR Function 
$FIXR FUNCTION 
The $FIXR function returns a FIXED(O) value from an INT, INT(32), REAL, or REAL(64) expression and applies rounding to the result. 
The syntax for the $FIXR function is: 
$FIXR ( <expression> 
<expression> 
is an INT, INT(32), REAL, or REAL(64) expression. 
$FIXR sets the overflow indicator if <expression> is too large in magnitude to be represented by a 64-bit two's complement integer. 
This function needs the following optional microcode: 
~ 
17-20 
System 
N o n s t o p 
N o n s t o p 
1 + 
INT INT(32) 
CIQ CDQ 
CIQ CDQ 
FIXED 
QLD 
REAL 
CFQR 
CFQR 
REAL(64) 
QLD CEQR 
CEQR 
""82581 AOO 3/85 
~· 
$FLT FUNCTION 
~· 
System 
Nonstop 1+ 
Nonstop 
INT INT(32) 
CIF CDF 
CIF CDF 
FIXED REAL(64) 
QLD QLD CQF CEF 
CQF CEF 
The $FLT function returns a REAL value from an INT, INT(32), FIXED, or REAL(64) expression. 
The syntax for the $FLT function is: 
$FLT ( <expression> 
<expression> 
is an INT, INT(32), FIXED, or REAL(64) expression. 
This function needs the following optional microcode: 
Aft82581 AOO 3/85 
STANDARD FUNCTIONS $FLT Function 
17-21 
STANDARD FUNCTIONS $FLTR Function 
$FLTR FUNCTION 
The $FLTR function returns a REAL value from an INT, INT(32), FIXED, or REAL(64) expression and applies rounding to the result. 
The syntax for the $FLTR function is: 
$FLTR ( <expression> 
<expression> 
is an INT, INT(32), REAL, or REAL(64) expression. 
This function needs the following optional microcode: 
17-22 
Slstem 
Nonstop 1+ 
N o n s t o p 
INT INT(32) FIXED 
REAL(64) 
~ 
CIF CDFR QLD QLD CQFR CEFR 
CIF' CDFR CQFR CEFR 
Af'82581 AOO 3/85 
~· 
$HIGH FUNCTION 
The $HIGH function returns an INT value from the left half of an INT(32) expression. 
The syntax for the $HIGH function is: 
$HIGH ( <dbl-expression> 
<dbl-expression> 
is an INT(32) expression. 
Example 
This example assigns the high-order word of "a32" to "num": 
INT num:
INT(32) a32 := 65538D: 
num :=$HIGH (a32): 
~ 
"1J82581 AOO 3/85 
STANDARD FUNCTIONS $HIGH Function 
17-23 
STANDARD FUNCTIONS $IFIX Function 
$ I F I X FUNCTION 
The $!FIX function returns a FIXED value from a signed INT expression. 
The syntax for the $IFIX function is: 
$IFIX ( <int-expression> , <fpoint> ) 
<int-expression> 
is a signed INT expression. 
<fpoint> 
is a value in the range -19 through +19 that specifies the position of the implied decimal point, as described in Section 8 under "Simple Variable Declaration." 
When $!FIX converts the signed INT expression to a FIXED value, it performs the equivalent of a right shift of 48 positions. 
This function needs the following optional microcode: 
System INT 
Nonstop l+ CIQ 
Nonstop CIQ 
17-24 
"'82581 AOO 3/85 
._..,., 
$ I NT FUNCTION 
The $INT function returns an INT value from an INT(32), FIXED(O), REAL, or REAL(64) expression. 
The syntax for the $INT function is: 
$INT ( <expression> 
<expression> 
is an INT(32), FIXED(O), REAL, or REAL(64) expression. 
If <expression> is type INT(32), $INT returns the low-order (least significant) 16 bits, and no overflow occurs. 
If <expression> is not type INT(32), $INT sets the overflow indicator if <expression> is too large in magnitude to be represented by a 16-bit two's complement integer. 
This function needs the following optional microcode: 
System 
Nonstop 1+ 
Nonstop 
Example 
FIXED REAL 
REAL(64) 
QLD CFI QLD CQI CEI 
CQI CFI CEI 
The following example assigns the low-order word of "a32" to "lnum": 
INT lnum;
INT(32) a32 := 655380; 
lnum := $INT (a32); 
~ 82581 AOO 3/85 
17-25 
STANDARD FUNCTIONS $INT Function 
STANDARD FUNCTIONS $INTR Function 
$INTR FUNCTION 
The $INTR function returns an INT value from an INT(32), FIXED(O), REAL, or REAL(64) expression and applies rounding to the result. 
The syntax for the $INTR function is: 
$INTR ( <expression> 
<expression> 
is an INT(32), FIXED(O), REAL, or REAL(64) expression. 
If <expression> is type INT(32), $INT returns the low-order (least significant) 16 bits, and no overflow occurs. 
If <expression> is not type INT(32), $INT sets the overflow indicator ~ if <expression> is too large in magnitude to be represented by a 
16-bit two's complement integer. 
The following optional mircrocode is required: 
17-26 
-'1J82581 AOO 3/85 
System 
Nonstop 1+ 
Nonstop 
FIXED -- 
QLD CQI 
CQI 
REAL 
REAL(64) 
CFIR QLD CEIR 
CFIR CEIR 
" - " ' . 
$LADR FUNCTION 
·~ 
The $LADR function obtains the standard address of a variable that is accessed through an extended pointer. 
The syntax for the $LADR function is: 
$LADR ( <variable> ) 
<variable> 
is a variable accessed through an extended pointer. If <variable> is type STRING or a substructure, the standard address is a byte address; otherwise, it is a word address. 
When $LADR converts the extended address to a standard address, it loses the segment number in the extended address. For a description of the extended address format, see Appendix A. 
Example 
This example initializes a standard pointer with the standard address $LADR returns from the extended address: 
STRING .EXT eptr := %100000D; STRING .sptr := $LADR (eptr); 
!Declares extended pointer !Declares standard pointer and
! initializes it with converted ! standard address 
~ 82581 AOO 3/85 
17-27 
STANDARD FUNCTIONS $LADR Function 
STANDARD FUNCTIONS $LEN Function 
$LEN FUNCTION 
The $LEN function returns the unit length (in bytes) of a variable. 
The syntax for the $LEN function is: 
$LEN ( <variable> ) 
<variable> 
is the name of a STRUCT item (a structure, substructure, or STRUCT data item), as defined in Section 11. 
For a structure or substructure, $LEN returns a unit length that is the sum of the lengths of its subordinate items. Because $LEN always returns a constant value, you can use it in LITERAL expressions. 
For a non-STRUCT item, $LEN returns the number of bytes in the item~ 
Example 
This example returns the length of one occurrence of a structure: 
I~ 
INT s""len; 
STRUCT .s[0:3]; BEGIN 
STRING arrayl[0:49]; INT(32) array2[0:199]; 
END; 
s""len := $LEN (s[O]); 
!Declares four occurrences of a ! structure 
!Returns length of first occurrence 
For other examples, see "Structure Functions" in Section 11 and "Move Statement" in Section 15. 
17-28 
~ 82581 AOO 3/85 
$LFIX FUNCTION 
The $LFIX function returns a 64-bit integer from an unsigned INT expression. 
The syntax for the $LFIX function is: 
$LFIX ( <int-expression> , <fpoint> ) 
<int-expression> 
is an unsigned INT expression. 
<fpoint> 
is a value in the range -19 through +19 that specifies the position of the implied decimal point, as described in Section 8 under "Simple Pointer Declaration." 
$LFIX places the INT value in the least significant word of the quadword and sets the three most significant words to 0. 
This function needs the following optional microcode: 
System INT 
Nonstop l+ CLQ 
Nonstop CLQ 
"it82581 AOO 3/85 
17-29 
STANDARD FUNCTIONS $LFIX Function 
STANDARD FUNCTIONS $LMAX Function 
$LMAX FUNCTION 
The $LMAX function returns the maximum of two unsigned INT expressions. 
The syntax for the $LMAX function is: 
$LMAX ( <int-expression> , <int-expression> ) 
<int-expression> 
is an unsigned INT arithmetic expression. 
Example 
This example returns the maximum of "integerl" and "integer2" and assigns that value to "max": 
INT max:
INT integerl := 68 '+' 125 '-' 43;
INT integer2 := 279 '-' 131; !Data declarations 
max := $LMAX(integerl, integer2); !Returns maximum value 
.... f 
17-30 
-1'82581 AOO 3/85 
$LMIN FUNCTION 
The $LMIN function returns the minimum of two unsigned INT expressions. 
The syntax for the $LMIN function is: 
$LMIN ( <int-expression> , <int-expression> ) 
<int-expression> 
is an unsigned INT arithmetic expression. 
Example 
This example returns the minimum of "integerl" and "integer2" and assigns that value to "min": 
INT min:
INT integerl := 99 23: INT integer2 := 41 I+ I 19: 
min := $LMIN(integerl, integer2): 
"f82581 AOO 3/85 
_, 
I 
STANDARD FUNCTIONS $LMIN Function 
!Data declarations 
!Returns minimum value 
17-31 
STANDARD FUNCTIONS $MAX Function 
$MAX FUNCTION 
The $MAX function returns the maximum of two signed INT, INT(32), FIXED, REAL, or REAL(64) expressions. 
The syntax for the $MAX function is: 
$MAX ( <expression> , <expression> 
<expression> 
is a signed INT, INT(32), FIXED, REAL, or REAL(64) expression. Both expressions must be the same type. 
Example 
This example returns the maximum of "expl" and "exp2" and assigns that value to "max": 
17-32 
~ 82581 AOO 3/85 
REAL max;
REAL expl := 8.3E-1; REAL exp2 := 8.2E5; 
max := $MAX(expl, exp2); 
!Data declarations 
!Returns maximum value 
"~ 
$MIN FUNCTION 
The $MIN function returns the minimum of two INT, INT(32), FIXED, REAL, or REAL(64) expressibns. 
The syntax for the $MIN function is: 
$MIN ( <expression> , <expression> 
<expression> 
is an INT, INT(32), FIXED, REAL, or REAL(64) expression. Both expressions must be of the same type. 
Example 
This example returns the minimum of "expl" and "exp2" and assigns that value to "min": 
FIXED(3) min;
FIXED(3) expl := 129.653F; FIXED(3) exp2 := 873.381F; 
min := $MIN(expl, exp2); 
!Data declarations 
!Returns minimum value 
..,82581 AOO 3/85 
STANDARD FUNCTIONS $MIN Function 
17-33 
STANDARD FUNCTIONS $NUMERIC Function 
$NUMERIC FUNCTION 
The $NUMERIC function tests the right half of an INT value for an ASCII numeric character. 
The syntax for the $NUMERIC function is: 
$NUMERIC ( <int-expression> 
<int-expression> 
is an INT expression. $NUMERIC inspects bits <8:15> of the expression and ignores bits <0:7>. 
It tests for a numeric character according to the criterion: 
<int-expression> >= "O" AND <int-expression> <= "9" 
$NUMERIC sets the condition code to "<" if a numeric character occurs. If you plan to test the condition code, you must do so before an arithmetic operation or assignment occurs. 
If the character passes the test, $NUMERIC returns a -1 (true); otherwise, it returns a 0 (false). 
This example tests for a numeric character in the expression "char": 
STRING char; 
IF $NUMERIC (char) THEN . . . 
17-34 
~ 82581 AOO 3/85 
$OCCURS FUNCTION 
The $OCCURS function returns the number of occurrences of a variable. 
The syntax for the $OCCURS function is: 
$OCCURS ( <variable> 
<variable> 
is the name of a STRUCT item (a structure, substructure, or STRUCT data item), as defined in Section 11. 
For structures and substructures, $OCCURS returns the number of occurrences. For example, for a bounds specification of [0:3], $OCCURS returns the value 4. 
$OCCURS always returns a constant value. You can use $OCCURS in LITERAL expressions. 
<variable> can also be a non-STRUCT item, but this has little meaning. For any non-STRUCT item, $OCCURS returns a 1. 
Example 
This example returns the number of occurrences of "jobAdata": 
INT index; 
STRUCT .jobAdata[0:5]; BEGIN 
INT il; STRING sl; END; 
!Declare structure 
For index := 0 to $OCCURS (jobAdata) - 1 DO . . . 
~ 82581 AOO 3/85 
17-35 
STANDARD FUNCTIONS $OCCURS Function 
STANDARD FUNCTIONS $OFFSET Function 
$OFFSET FUNCTION 
The $OFFSET function returns the number of bytes from the base of the structure to a variable within the structure. 
The syntax for the $OFFSET function is: 
$OFFSET ( <variable> 
<variable> 
is the name of a STRUCT item (a substructure or STRUCT data item), as defined in Section 11. 
The base of a structure has an offset of O. 
When you qualify the name of a STRUCT item, you can use constant indexes but not variable indexes; for example: 
$OFFSET (structl.subst[l].item) 
$OFFSET always returns a constant value. You can use $OFFSET in LITERAL expressions. 
For non-STRUCT items, $OFFSET returns a 0. 
...... r··.""""'!! 
I 
17-36 
'1J82581 AOO 3/85 
STANDARD FUNCTIONS $OFFSET Function 
~, Example
This example assigns to "c" the offset of the third occurrence of 
a substructure: 
STRUCT a; BEGIN 
INT array[0:40]; STRUCT ab[0:9]; 
BEGIN 
END; END; 
INT c; 
c := $OFFSET (a.ab[2]); 
!Declares structure 
!Declares substructure "ab" ! with ten occurrences 
!Returns offset of third ! occurrence of "ab" 
~ 82581 AOO 3/85 
17-37 
STANDARD FUNCTIONS $OVERFLOW Function 
$OVERFLOW FUNCTION 
The $OVERFLOW function tests for an arithmetic overflow condition. 
The syntax for the $OVERFLOW function is: 
$OVERFLOW 
To enable arithmetic overflow testing, you must clear the arithmetic overflow trap bit (bit 8) in the ENV register. If an arithmetic overflow occurs while this bit is set, a trap results. 
If the overflow bit is on, $OVERFLOW returns a -1 (true); otherwise, it returns a 0 (false). 
Example 
This example tests the condition of the overflow indicator: 
IF NOT $OVERFLOW THEN . . • ; 
17-38 
"f82581 AOO 3/85 
~ 
$PARAM FUNCTION 
~._..,... 
The $PARAM function checks for the presence or absence of a parameter in the call that invoked the current procedure or subprocedure. 
The syntax for the $PARAM function is: 
$PARAM ( <formal-param> 
<formal-param> 
is the name of a formal parameter as specified in the procedure or subprocedure declaration (described in Section 16). 
If the parameter is present, $PARAM returns a 1. If the parameter is absent, $PARAM returns a 0. 
Y o u c a n o n l y u s e $ P A R A M i n a V A R I A B L E p r o c e d u r e o r s u b p r o c e d u r e o r i n an EXTENSIBLE procedure. The called procedure must check for the presence or absence of each required parameter in CALL statements.
It can check for optional parameters in the same way. 
Example 
This example checks for the absence of each required parameter and for the presence of the optional parameter: 
PROC varAproc (buffer,length,key) VARIABLE; !Procedure declaration INT .buffer, length, !Required parameters 
key; !Optional parameter 
BEGIN
!Some code here
IF NOT $PARAM (buffer) AND NOT $PARAM (length) THEN RETURN; 
!Returns 1 or 0 for each required parameter; 
! AND results in true or false value IF $PARAM (key) THEN . . . !Returns 1 if optional END; ! parameter is present 
Af'82581 AOO 3/85 
17-39 
STANDARD FUNCTIONS $PARAM Function 
STANDARD FUNCTIONS $POINT Function 
$POINT FUNCTION 
The $POINT function returns the <fpoint> value, in integer form, associated with a FIXED expression. 
The syntax for the $POINT function is: 
$POINT ( <fixed-expression> 
<fixed-expression> 
is a FIXED expression. 
TAL emits no instructions when evaluating <fixed-expression>. Therefore, you cannot use <fixed-expression> to invoke a function or assign ·a value to a variable. 
Example 
This example retains precision automatically when performing fixed- point division. $POINT returns the <fpoint> value of "b" to $SCALE, which then scales "a" by that factor: 
FIXED(3) result;
FIXED(3) a~
FIXED(3) b; !Data declarations 
result := $SCALE ( a, $POINT ( b )) I b; 
17-40 
/1J82581 AOO 3/85 
~._.,, 
$RP FUNCT I ON 
The $RP function returns the current setting of the TAL RP counter. 
The syntax for the $RP function is: 
$RP 
Example 
This example assigns the current RP setting to "index": 
INT index; !Data declaration 
index := $RP !Returns RP setting 
~ 82581 AOO 3/85 
17-41 
STANDARD FUNCTIONS $RP Function 
STANDARD FUNCTIONS $SCALE Function 
$SCALE FUNCTION 
The $SCALE function moves the position of the implied decimal point by adjusting the internal representation of a FIXED expression. 
The syntax for the $SCALE function is: 
$SCALE ( <fixed-expression> , <scale> ) 
<fixed-expression> 
is a FIXED expression. 
<scale> 
is an INT constant in the range -19 to +19 that defines the number of positions to move the implied decimal point to the left (<scale> > 0) or to the right (<scale> <= 0) of the least significant digit. 
$SCALE sets the overflow indicator if the result of the scale exceeds the range of a 64-bit integer. $SCALE adjusts the implied decimal point by multiplying or dividing by 10 to the <scale> power. If it scales the operand down, some precision is lost. 
This function needs the following optional microcode: 
System FIXED 
Nonstop 1+ QLD QUP 
Example 
This example scales the value of "a" by +3, making "a" a FIXED(6) value. The result of the divide operation is a FIXED(3) value: 
FIXED(3) result, a, b; !Data declarations result := $SCALE(a, 3) I b; 
17-42 
4l82581 AOO 3/85 
"-"'' 
$SPECIAL FUNCTION 
The $SPECIAL function tests the right half of an INT value for an ASCII special (nonalphanumeric) character. 
The syntax for the $SPECIAL function is: 
$SPECIAL <int-expression> 
<int-expression> 
is an INT expression. $SPECIAL inspects bits <8:15> of <expression> and ignores bits <0:7>. 
It checks for a special character according to the following criterion: 
<int-expression> <> alphabetic AND <int-expression> <> numeric 
$SPECIAL sets the condition code to ">" if it finds a special character. If you plan to check the condition code, you must do so before an arithmetic operation or a variable assignment occurs. 
If the character passes the test, $SPECIAL returns a -1 (true); otherwise, it returns a 0 (false). 
Example 
This example tests the expression "char" for the presence of a special character: 
STRING char; 
IF $SPECIAL (char) THEN . . . 
"'182581 AOO 3/85 
17-43 
STANDARD FUNCTIONS $SPECIAL Function 
STANDARD FUNCTIONS $TYPE Function 
$TYPE FUNCTION 
The $TYPE function returns a value that indicates the type of a variable. 
The syntax for the $TYPE function is: 
$TYPE ( <variable> 
<variable> 
is any identifier that has an associated data type or is a structure or substructure. 
$TYPE returns a value that has a meaning as follows: 
Value 
0 1 2 3 4 
Meaning Value 
Undefined 5 STRING 6 INT 7 INT(32) 8 
FIXED 
Meaning 
REAL REAL(64) Substructure Structure 
$TYPE always returns a constant value. You can use $TYPE in LITERAL expressions. 
Example 
This example assigns the value returned by $TYPE to "typel": 
REAL(64) varl;
INT typel: !Data declarations 
typel := $TYPE (varl); !Returns a 6 
17-44 
Af'82581 AOO 3/85 
~ 
$UDBL FUNCTION 
The $UDBL function returns an INT(32) value from an unsigned INT expression. 
The syntax for the $UDBL function is: 
$UDBL ( <int-expression> 
<int-expression> 
is an unsigned INT expression. 
$UDBL places the INT value in the right half of an INT(32) variable and sets the left half to O. 
Example 
This example returns the INT(32) value of "a16" and assigns it to "b32": 
INT a16 := %177775; INT(32) b32; 
b32 := $UDBL (a16); 
/182581 AOO 3/85 
STANDARD FUNCTIONS $UDBL Function 
17-45 
STANDARD FUNCTIONS $XADR Function 
$XADR FUNCTION 
The $XADR function returns an extended address for a variable that has a standard address. 
The syntax for the $XADR function is: 
$XADR ( <variable> ) 
<variable> 
is a variable that has a standard address. 
For a pointer variable, $XADR returns the extended address of the data to which the pointer points, not the address of the pointer itself. 
~xamples 
1. This example initializes an extended pointer with the extended address of an array: 
PROC p ; BEGIN 
INT .array[0:49];
STRING .EXT ptr := $XADR (array); 
END; 
!Declares array
!Declares and initializes ! extended pointer 
2. This example returns an extended address for an INT variable to which a standard pointer points, then assigns the extended address to an extended pointer: 
17-46 
~ 82581 AOO 3/85 
INT .stdAptr := %1000; INT .EXT extAptr; 
!Declares standard pointer !Declares extended pointer 
!Assigns extended address 
SECTION 18 
PRIVILEGED PROCEDURES 
This section tells how to access the system global data area using system global pointers, 'SG' equivalencing, and standard functions for privileged operations. 
You can access system globals only within procedures that operate in privileged mode. Such procedures can access system data space, call other privileged procedures, and execute certain privileged 
instructions. Privileged procedures must be specially licensed to operate, since they might (if improperly written) adversely affect 
·~· the status of the processor in which they are running. 
You can use system global pointers and 'SG' equivalencing: 
•	To access system tables and the system data area 
•	To initiate certain input/output transfers 
•	To move and compare data between the user data area and the system data area 
•	To scan data in the system data area 
•	To perform privileged operations through calls to operating system procedures 
•	To execute privileged instructions that affect other programs or the operating system 
An extended pointer can also point to system data as described in Appendix A. 
~ 82581 AOO 3/85 
18-1 
PRIVILEGED PROCEDURES
System Global Pointer Declaration 
SYSTEM GLOBAL POINTER DECLARATION 
The system global pointer declaration associates an identifier with a variable that contains the address of a variable located in the system global data area. 
The syntax of the system global pointer declaration is: 
<type> .SG <identifier> [ := <preset-address> ] 
[ , .SG <identifier> [ :=<preset-address> ] ] ... 
<type> 
is one of the following data types and specifies the type of value to which the pointer points: 
STRING INT INT(32) FIXED 
REAL REAL(64) 
.SG 
<identifier> 
is the name of the pointer. 
<preset-address> 
is the address of a variable in the system global data area determined by you or the system during system generation. 
TAL allocates one word of local primary storage for the pointer in the current user data segment. ~ 
18-2 
.,, 82581 AOO 3/85 
is the indirection symbol for system global addressing. At least one space must precede the .SG symbol; the period in the symbol must not appear in column 1. 
·~ 
PRIVILEGED PROCEDURES System Global Pointer Declaration 
For information about system tables, see the System Descriptioh Manual for your system. 
Example 
The following example declares an INT system global pointer named "newname": 
INT .SG .newname; 
"'82581 AOO 3/85 
18-3 
PRIVILEGED PROCEDURES 'SG'-Equivalenced Variable Declaration 
'SG'-EQUIVALENCED VARIABLE DECLARATION 
'SG' equivalencing associates a global, local, or sublocal identifier with a location relative to the base address of the system global area. 
Equivalenced variables (simple variables, pointers, and structure pointers) are described first, followed by equivalenced structures. 
The syntax for the 'SG'-equivalenced variable declaration is: 
18-4 
~ 82581 AOO 3/85 
<type> 
{ • } { <pointer> 
<simple-variable> 
} } } } 
'SG' [ "[" <index> "]" [ {+I-} <offset> 
<type> 
{ [,{ 
{ • } { <pointer> 
} } } } 
] ... 
{ { { { 
{ 
{ .EXT } { <structure-pointer> ( <referral> ) } } 
{ .EXT } { <structure-pointer> ( <referral> ) } } 
.. 
·--·~~ 
{ <simple-variable> 
" [" 
<index> 
"]" 
= 'SG' [
[ {+I-} <offset> 
For <structure-pointer>, <type> must be STRING or INT.
For <simple-variable> or <pointer>, <type> is any data type. 
. (period) 
is the indirection symbol for standard addressing. 
. EXT 
is the indirection symbol for extended addressing. 
,. 
'.......... 
, 
'"'-"'' 
is the identifier of a structure pointer to be made equivalent to 'SG'. 
<pointer> 
is the identifier of a pointer to be made equivalent to 'SG'. 
<simple-variable> 
is the identifier of a simple variable to be made equivalent to 'SG'. 
<referral> 
is the identifier of a previously declared structure or structure pointer. 
'SG' 
is the address base of the system global data area and stands for system global addressing; the identifier is addressed relative to SG[O]. 
<index> and <offset> 
are equivalent INT values in the range 0 through 63. 
Example 
This example makes "iteml" equivalent to the location 'SG' + 15: 
INT iteml = 'SG' + 15; 
<structure-pointer> 
PRIVILEGED PROCEDURES 'SG'-Equivalenced Variable Declaration 
'1J82581 AOO 3/85 18-5 
PRIVILEGED PROCEDURES 'SG'-Equivalenced Variable Declaration 
The syntax for the 'SG'-equivalenced structure declaration is: 
STRUCT [ . ] <structure> [ ( <referral> ) ] 
18-6 
1'82581 AOO 3/85 
[ <structure~body> ] 
• (period) 
is the indirection symbol for standard addressing. 
<structure> 
is the identifier of a definition or referral structure to be made equivalent to 'SG'. 
<referral> 
is the identifier of a previously declared structure or structure pointer$ Its presence means <structure> is a referral structure and <structure-body> cannot be specified. 
'SG' 
is the address base of the system global data area: <structure> is addressed relative to SG[O]. 
<index> and <offset> 
are equivalent INT values in the range 0 through 63. 
<structure-body> 
is a BEGIN-END construct that contains declarations as described in Section 11. Its presence means <structure> is a definition structure and <referral> cannot be specified. 
= 'SG' [ "[" <index> "]" [ {+I-} <offset> 
·~ 
FUNCTIONS FOR PRIVILEGED OPERATIONS 
TAL provides four functions for performing certain operations that are restricted to programs running in privileged mode: 
• $AXADR--Converts a standard address or a relative extended address to an absolute extended address 
• $BOUNDS--Checks the locations of parameters passed to system procedures 
• $PSEM--Accesses a counting semaphone for awaiting completion of an operation external to the calling procedure or subprocedure 
• $SWITCHES--Returns the current setting of the SWITCH register 
These functions are described on the following pages. 
'1'82581 AOO 3/85 
18-7 
PRIVILEGED PROCEDURES Functions for Privileged Operations 
PRIVILEGED PROCEDURES $AXADR Function 
$AXADR Function 
The $AXADR function returns an absolute extended address. 
The syntax for the $AXADR function is: 
$AXADR ( <variable> ) 
<variable> 
is a variable with a standard or relative extended address to convert to an absolute extended address. If <variable> is a pointer, the absolute extended address of the item it points to is returned, not the pointer's address. 
Example 
This example converts the standard address of "intr" to an absolute extended address: 
STRING .EXT s t r ; INT intr; 
@str := $AXADR (intr); 
END; 
18-8 
Af'82581 AOO 3/85 
"~; 
$BOUNDS Function 
The $BOUNDS function checks the location of a parameter passed to a system procedure to prevent an incorrect address pointer from overlaying a system procedure stack register with data. 
The syntax for the $BOUNDS function is: 
$BOUNDS ( <param> , <count> ) 
<pa ram> 
is a parameter of the procedure from which the $BOUNDS function is callable. It must not be a subprocedure 
parameter. 
<count> 
is a value of the same data type as <param>. 
$BOUNDS returns an INT result as follows: 0 for false (no bounds error occurred) or 1 for true (bounds error occurred). 
Example 
This example checks the location of the parameter "buf": 
PROC example (buf, z); 
. 
IF $BOUNDS (buf, count) THEN 
CALL error; 
END; 
!Checks for any part of "buf" ! in the procedure's stack
lif true, generates an error 
~ 82581 AOO 3/85 
18-9 
PRIVILEGED PROCEDURES $BOUNDS Function 
PRIVILEGED PROCEDURES $PSEM Function 
$PSEM Function 
The $PSEM function requests a semaphore on behalf of the caller, allowing the caller to await completion of an external process that uses the system resource represented by the semaphore. When the semaphore becomes available, the caller can continue. 
The syntax for the $PSEM function is: 
$PSEM ( <semaphore-addr> , <interval> ) 
<semaphore-addr> 
is the address of the semaphore desired. 
<interval> 
is an INT(32) value that defines the maximum duration the procedure waits for the semaphore before continuing, specified in 10-millisecond intervals. 
For further information about semaphores, see the System Description Manual for your system. 
18--10 
-'iJ 82581 AOO 3/85 
.._,,. 
$SWITCHES Function 
The $SWITCHES function returns the current setting of the SWITCH register to the caller. 
The syntax for the $SWITCHES function is: 
....------------------------------·---~~·---·~-- $SWITCHES 
Example 
The following example stores the current contents of the SWITCH register into "n": 
n := $SWITCHES; 
"182581 AOO 3/85 
18-11 
PRIVILEGED PROCEDURES $SWITCHES Function 
SECTION 1 9 
SAMPLE PROCEDURE 
To illustrate some of the coding techniques used in TAL, the source text for a simple procedure appears in Figure 19-1. This procedure performs a conversion function typical of many algorithms in TAL. 
The procedure converts a binary INT value to an ASCII (base 10) value with a maximum length of six characters including the sign, then returns the converted character string and its length to the calling procedure. 
Significant items in this procedure are keyed to the following discussion: 
Item Discussion 
1.	!1!  Comments preceding the procedure declaration describe the purpose of the procedure. For complex procedures, you can also summarize the input/output characteristics and the main features of the algorithm. 
2.	!2!  The formal parameter specifications define the parameters of the procedure. Input parameters "v" and "rjust" are value parameters, and output parameter "stg" is a reference parameter. 
3.	!3!  This local declaration reserves six bytes of memory for the buffer in which the number is converted. The declaration also initializes the first five bytes in the buffer to blanks (using a repetition factor of 5) and sets the last byte to an ASCII O. Thus, an input of 0 results in an output of five blanks and a 0, rather than six blank characters. 
Aft82581 AOO 3/85 
19-1 
SAMPLE PROCEDURE 
4.	!4!  This IF-THEN statement deals with any negative number passed as a parameter. When it encounters a negative number, it sets the negative value flag to 1 and takes the absolute value of the number passed. 
5.	!5!  This WHILE loop performs the conversion, character by character, writing each byte to the buffer from right to left. 
6.	!6!  This assignment statement does the actual conversion. It illustrates an arithmetic expression that uses the standard function $UDBL. The statement performs a residue modulo 10 
operation, then biases the value of each byte up into the numeric range by adding an ASCII 0. 
7.	!7!  This IF-NOT-THEN statement uses the assignment form of an arithmetic expression as the condition. 
8.	!8!  This IF-THEN-ELSE statement moves the resulting character string from the buffer into the user's target string. 
9.	!9!  The RETURN statement returns to the calling procedure the number of characters moved. 
19-2 
~ 82581 AOO 3/85 
!1! 
! 2 ! 
! 3 ! 
!4! 
!INT PROC ASCII converts a binary INT value to an ASCII
! (base 10) value with a maximum length of six characters
! (including the sign), then returns the converted character ! string and its length to the calling procedure. 
-''f 82581 
AOO 3/85 
INT PROC Ascii(v,rjust,stg); INT v;
INT rjust; 
STRING .stg; BEGIN 
!INT value to convert !Right justify result flag !Target string 
STRING .b[0:5] INT n;
INT sgn := O; 
"],"O "];
!Number of digits converted 
!Nonzero if 'v' is negative !Index for converted digit 
!Value is negative 
!Set negative value flag !Take absolute value 
!While a value is left 
INT k 
IF v < 0 THEN 
BEGIN
sgn := 1; v := -v; END; 
: = 5; 
!5! WHILE v DO 
!6! 
BEGIN
b[k] := $UDBL(v) '\' 10 + "0"; !Convert a character 
v := v I 10; k := k - 1; END; 
IF sgn THEN 
BEGIN
b[k] := "-"., k := k - 1; END; 
!Compute remainder
!Count converted character 
!Number is negative 
!Insert the sign
!Count it as a character 
:= 
[5*[" 
Figure 19-1. Sample Procedure (Continued on Next Page) 
SAMPLE PROCEDURE 
19-3 
SAMPLE PROCEDURE 
19-4 
!Check for an overflow 
!Return 1 character in that case 
!Move the resultant string to the 
! user's target
stg[n-1] '=:' b[5] FOR n !Reverse move if right justified 
ELSE
stg ':=' b[6-n] FOR n; !Otherwise forward move 
!7! IF NOT {n:=5-k) THEN 
n := 1; 
!8! IF rjust THEN 
!9! RETURN n;
END !ascii! ; 
!Return the string's length 
Figure 19-1--{Continued) 
-''j 82581 
AOO 3/85 
This section describes: 
SECTION 20 
COMPILER OPERATION 
•	The compilation process 
•	The COMINT PARAM commands that TAL accepts 
•	The TAL run command 
•	TAL compiler directives 
COMPILATION PROCESS 
The input for a single run of the TAL compiler is a compilation unit. A compilation unit consists of one or more source files that contain declarations, statements, and compiler directives. Each compilation unit compiles into an object file that consists of relocatable code and data blocks. 
You can bind an object file with other object files to build a new object file called the target file. For a description of object files, see the BINDER Manual. 
The TAL compiler is integrated with two other processes, BINSERV and SYMSERV. Compiler directives govern all three processes. 
TAL Compiler Process 
TAL compiles source code, processes compiler directives, and starts BINSERV and SYMSERV for additional processing. TAL produces any listings that result from the three processes. 
..,. 82581 AOO 3/85 
20-1 
COMPILER OPERATION Compilation Process 
Compiler directives select compilation options and provide the compile-time interface to the BINDER, CROSSREF, and INSPECT program development tools. For example, the SYNTAX directive provides a syntax check without object-code generation, and the SEARCH directive lets you specify object files for BINSERV or BINDER to use for resolving external references. 
BINSERV Process 
BINSERV is the compile-time binder process. If the compilation is successful, BINSERV constructs the target file, resolving external references by binding code and data blocks from object files into the target file. 
If the SYNTAX directive is not in effect, BINSERV is present throughout the compilation until TAL detects an error in a source file. Thus, the first error prevents construction of an object file. If BINSERV is present, the output listing contains binder statistics. 
You can do further binding by using BINSERV or the standalone BINDER, described in the BINDER Manual. 
SYMSERV Process 
SYMSERV produces symbol tables for the object file. If the CROSSREF directive is in effect, SYMSERV also generates source-level cross- 
reference information. SYMSERV is present throughout the compilation. 
PARAM COMMANDS 
TAL accepts three COMINT PARAM commands (SAMECPU, SWAPVOL, and SPOOLOUT). These are summarized here and described further in the GUARDIAN Operating System Utili~~es Reference Manual. To take effect, these commands must precede the TAL run command. 
PARAM SAMECPU Command 
The PARAM SAMECPU command specifies that TAL, BINSERV, and SYMSERV all run in the same CPU. Specify a nonzero value with this command, as
in the following example: 
PARAM SAMECPU 1 
20-2 
Af'82581 AOO 3/85 
PARAM SWAPVOL Command 
The PARAM SWAPVOL specifies the volume that TAL, BINSERV, and SYMSERV use for temporary files. The form of this command is: 
PARAM SWAPVOL [ \<system>. ] $<volume> 
If you do not specify a volume, TAL uses the default volume; BINSERV and SYMSERV use the volume specified to receive the target file, which might be the default volume. Use the PARAM SWAPVOL conunand when: 
• The volumes normally used for temporary files might not have sufficient space. 
• The default volume or the volume to receive the object file is on a different system from the compiler. 
On a Nonstop system, if the PARAM SWAPVOL conunand specifies another system, TAL ignores the conunand and allocates temporary files on the volume on which it resides. 
PARAM SPOOLOUT Command 
The PARAM SPOOLOUT command causes significant decreases in elapsed time for compilations with listings, because TAL can use the Level 3 interface to the Spooler. The command form is: 
PARAM SPOOLOUT 1 
""1' 82581 AOO 3/85 
20-3 
COMPILER OPERATION PARAM Conunands 
COMPILER OPERATION TAL Run Command 
TAL RUN COMMAND 
The command to run the TAL compiler is: 
TAL [ I [ IN <source-file> ] [ , OUT [ <list-file> ] 
<comint-option-list> ] I ] [ <target-file-name> ] 
[ ; <directive> [ , <directive> ] ••• ] 
<source-file> 
is the name of a file (an edit-format disc file, terminal, magnetic tape unit, or process) containing TAL declarations, statements, and compiler directives. It is read as 132-byte 
records. The default value is the COMINT <command-file>; if COMINT is in interactive mode, this is the home terminal. 
<list-file> 
is the name of a file (terminal, line printer, magnetic tape unit, process, or disc file) to receive compiler output. In an unstructured disc file, each record has 132 characters; partial lines are blank-filled through column 132. 
If you specify OUT with no <list-file>, TAL suppresses output. If you omit OUT, the OUT file is that of the parent process; if you started the process under a COMINT, this is typically the home terminal. 
<comint-option-list> 
is one of the RUN command options documented in the GUARDIAN Operating System Utilities Reference Manual, such as: 
NAME [ <process-name> CPU <cpu-num>
PRI <priority>
NOWAIT 
The MEM option is valid but has no effect; TAL always uses 64 pages. 
20-4 
..,. 82581 AOO 3/85 
<target-file-name> 
is the name of the current target file in the form: 
[\<sysname>.][$<volname>.][<subvolname>.]<discfile-name> 
If you omit <target-file-name>, the default value is: 
\<default-system>.$<default-volume>.<default-subvol>.OBJECT 
<default-system> is the system specified in the current SYSTEM command, if you entered the command, or is the current system you are running on. 
BINSERV constructs the object file in a temporary file. If <target-file-name> cannot be purged, BINSERV renames the existing target file with a name in the form ZZBI<nnnn> 
(where <nnnn> is a random number). BINSERV then assigns the specified name to the current target file. 
<directive> 
is any compiler directive described in "Compiler Directives" in this section, except ASSERTION, DECS, DUMPCONS, ENDIF,
I F , IFNOT, PAGE, RP, SECTION, a n d SOURCE. 
Do not use "?" on the command line. 
Examples 
1. This example sets PARAM commands, then starts compilation of the source file "mysource". It directs the listing to $SPOOL (a spooler collector), names "myprog" as the target file, suppresses the symbol map, and requests code mnemonics and cross-reference listings: 
PARAM SAMECPU 1
PARAM SWAPVOL $ j u n k
PARAM SPOOLOUT 1
TAL /IN mysource, OUT $SPOOL/myprog;NOMAP,ICODE,CROSSREF 
~ 82581 AOO 3/85 
20-5 
COMPILER OPERATION TAL Run Command 
COMPILER OPERATION Compiler Directives 
2. This example starts compilation of the source file "talprg", suppresses output by giving a null list file, and sets a compilation toggle to control inclusion or exclusion of parts of the source text: 
TAL /IN talprg,OUT I SETTOG 3 
COMPILER DIRECTIVES 
Compiler directives specify additional input source code and options for listings, code generation, and building of the object file. 
Directive Line 
A directive line in the source text begins with "?" in column 1. TAL interprets and processes each directive at the point of occurrence. 
The general form of a directive line is: 
? <directive> [ , <directive> ] ••. 
? 
indicates a directive line; "?" must be in column 1. 
<directive> 
is a compiler directive described in this section. 
The following rules apply to directive lines: 
• The "?" is not part of the directive name; it appears only in column 1. 
• A directive and its arguments must be on a single line unless otherwise noted under the directive description. 
• Each continuation line for a list of directives begins with "?". 
20-6 
.,,82581 AOO 3/85 
COMPILER OPERATION Summary of Compiler Directives 
• Each continuation line for a single directive begins with "?". (SOURCE and SEARCH are examples of directives that can continue on 
multiple lines.) 
Summary of Compiler Directives 
This summary groups the directives by function and briefly describes each. The functional groups are: 
Input control 
Listing control 
• 
• 
• 
• 
• 
• 
• 
Diagnostic output control 
Code generation control 
Toggle control 
Internal control 
Object file control 
In the functional groups that follow, the default is underlined for 
directives that have a positive and a negative form. 
Input Control 
SECTION 
SOURCE 
Listing Control 
names part of a source file. 
specifies source to read from another input file. 
lists C-relative addresses. 
lists instructions in octal for procedures. 
cross references source identifier classes. 
ABSLIST 
CODE 
CROSSREF 
NOABSLIST 
NOCODE 
NOCROSSREF 
DEFEXPAND NODEFEXPAND lists invoked DEFIN:Es. 
GMAP NOGMAP prints global map. 
"'1' 82581 AOO 3/85 
20-7 
COMPILER OPERATION
Summary of Compiler Directives 
!CODE NOICODE lists mnemonics after each procedure. 
INNERLIST NOINNERLIST lists mnemonics after each source statement. 
20-8 
Aj82581 AOO 3/85 
T"'INES 
specifies maximum number of lines per page. 
lists source and enables other listings. 
selects BINSERV load maps. 
lists identifier map. 
causes page eject; specifies a header. 
selectively lists symbols. 
suppresses all but header, diagnostics, and trailer text. 
sets number of error messages to terminate TAL 
issues warnings for nonrelocatable globals (see "Object-File Control" directives). 
Selectively enables warnings. 
generates debugging aids. 
specifies Nonstop or Nonstop 1+ system. 
dumps constant table to code. 
LMAP NOLMAP 
MAP NOMAP 
PAGE 
PRINTSYM NOPRINTSYM 
SUPPRESS NOS UPP RESS 
Diagnostic Output Control 
ERRORS 
RELOCATE 
WARN 
NOWARN 
Code Generation Control 
ASSERTION 
CPU 
DUMPCONS 
NOLIST 
INHIBITXX NOINHIBITXX inhibits extended, indexed instruction emission. 
ROUND NOROUND 
SYNTAX 
specifies scalar rounding. 
checks syntax only; generates no code. 
Toggle Control 
ENDIF 
IF 
IFNOT 
RESETTOG 
SETTOG 
Internal Control 
DECS 
RP 
Object-File Control 
COMPILER OPERATION Summar~{ of Compiler Directives 
marks end of conditional source. 
allows conditional compilation. 
suppresses compilation. 
turns toggles off. 
turns toggles on. 
decrements S-register value of TAL. 
sets internal RP counter of TAL. 
terminates compilation if TAL cannot open source file. 
fills 32K gap in code area. 
defines size of data area. 
defines number of pages to add to existing stack size. 
selects default debugger (INSPECT or DEBUG). 
specifies Nonstop system user library for resolving run-time external reference. 
specifies PEP table size for BINSERV. 
issues messages if reference made to nonrelocatable global data. 
ABORT 
COMPACT 
DATAPAGES 
EXTENDSTACK 
INSPECT 
LIBRARY 
PEP 
RELOCATE 
NOABORT 
NOCOMPACT 
NOINSPECT 
SAVEABEND NOSAVEABEND directs INSPECT to create save file that contains process state if program ends 
abnormally. 
"1'82581 AOO 3/85 
20-9 
COMPILER OPERATION
Summary of Compiler Directives 
SEARCH 
STACK 
SYMBOLS 
NOSYMBOLS 
names object files from which to resolve external references; SEARCH with no file name negates search list. 
sets new stack size. 
generates INSPECT symbol table for symbolic debugging. 
DIRECTIVE DESCRIPTIONS 
The remaining pages of this section give descriptions of directives in alphabetic order. Unless otherwise noted, each directive applies to all Tandem systems. 
20-10 
/"f82581 AOO 3/85 
ABORT Directive 
The ABORT directive terminates compilation if TAL cannot open the file you specified in a SOURCE directive; it issues an error message to the out file, stating the name of the file that cannot be opened. 
The default is ABORT. 
The syntax for the ABORT directive is: 
[NO]ABORT 
The ABORT directive is not a feature of the NcmStop 1+ software. 
NOABORT causes TAL to attempt to prompt the home terminal when the file cannot be opened. 
Aft82581 AOO 3/85 
COMPILER OPERATION ABORT Directive 
20-11 
COMPILER OPERATION ABSLIST Directive 
ABSLIST Directive 
The ABSLIST directive specifies that TAL lists instruction locations relative to the base of the code area, location C[O]. {LIST must be enabled.) 
The default is NOABSLIST {that is, TAL lists addresses relative to the base of the procedure). 
The syntax for the ABSLIST directive is: 
[NO]ABSLIST 
To use ABSLIST, you must define the size of the PEP table to TAL before it encounters procedure statements in the source program. You can either: 
• Include a PEP directive at the beginning of the source program 
• Declare each internal procedure FORWARD or EXTERNAL before the first procedure body 
Limitations 
ABSLIST attempts to maintain an overall code address: however, at least some addresses are invalid if the file: 
• Has more than 32K of code 
• Has resident procedures after nonresident procedures 
• Does not supply enough PEP table space in the PEP directive or does not declare all procedures FORWARD 
If the 64K limit is reached, TAL disables ABSLIST, starts printing offsets from the procedure base, and emits a warning. 
Because of these limitations, Tandem does not recommend the use of the ABSLIST as a general practice. 
20-12 
Af'82581 AOO 3/85 
ASSERTION Directive 
The ASSERTION directive is a program debugging aid; it conditionally invokes a procedure when an event defined in an ASSERT statement 
occurs. 
The syntax for the ASSERTION directive is: 
ASSERTION [ = ] <assertion-level> , <procedure-name> 
<assertion-level> 
is an integer in the range 0 through 32767 that defines a numeric relationship to an ASSERT statement <assert-level>. 
<procedure-name> 
is the name of the procedure to invoke if the event defined in a ASSERT statement occurs and <assertion-level> is not 
greater than <assert-level>. The named procedure must not have parameters. 
The corresponding ASSERT statements have the form: 
ASSERT <assert-level> : <expression>; 
<expression> is a conditional expression that tests a program condition. 
For an example of the ASSERTION directive, see the ASSERT statement in Section 15. 
-'182581 AOO 3/85 
COMPILER OPERATION ASSERTION Directive 
20-13 
COMPILER OPERATION CODE Directive 
CODE Directive 
The CODE directive lists instruction codes in octal if LIST is also enabled. 
NOCODE suppresses the octal code listing. The default is CODE. 
The syntax for the CODE directive is: 
[NO]CODE 
The CODE listing for each procedure follows it in the out file. 
The CODE listing might not show final G-plus addresses for global variables. If a global variable is within a named data block, the G-plus address shown is relative to the start of the data block. At the end of the compilation, BINSERV creates the final G-plus address. To display the final addresses, use BINDER and INSPECT conunands. 
Other code locations affected by BINSERV are: 
• Fix-up cells to global read-only arrays 
• PCAL instructions 
20-14 
~ 82581 AOO 3/85 
COMPACT Directive 
The COMPACT directive directs BINSERV to move procedures if they fit into any gap below the 32K boundary of the code area. 
The default is COMPACT. 
The syntax for the COMPACT directive is: 
[NO]COMPACT 
You can use this directive any number of times: the last use of the directive sets the option for the compilation unit. 
-'182581 AOO 3/85 
COMPILER OPERATION COMPACT Directive 
20-15 
COMPILER OPERATION CPU Directive 
CPU Directive 
The CPU directive specifies whether the object code is to run on a Nonstop or a Nonstop 1+ system. 
The syntax for the CPU directive is: 
CPU { TNS } { TNS/II } 
TNS 
TNS/II 
indicates the object code is to run on a Nonstop system. 
If you do not use CPU, the default system type is the system on which you compile the code. Guidelines for using this directive are: 
• Specify the CPU directive either on the TAL run command line or in the source code before the first declaration. 
• Nonprivileged code containing Nonstop software features such as extended addressing can compile on .either system if you specify CPU TNS/II. Sections of code that use such features run correctly on a Nonstop system only. The remaining code runs correctly on either system. To determine system type, see the TOSVERSION procedure in the System Procedure Calls Reference Manual. 
• For nonprivileged code that can compile and run on either system, specify CPU TNS as documentation. 
The CPU directive also influences BINDER behavior, as described in the BINDER Manual. 
20-16 
indicates the object code is to run on a Nonstop 1+ system. Nonprivileged programs compiled in this mode can also run on a Nonstop system. 
.., 82581 AOO 3/85 
CROSSREF Directive 
The CROSSREF directive specifies that TAL lists source-level cross-reference information produced during compilation and specifies the identifier classes to process. 
The default is NOCROSSREF. 
The syntax for the CROSSREF directive is: 
[NO]CROSSREF [ <class>
[ ( <class> [ , <class> ] •.. ) 
<class> 
is one of: 
named and private data blocks unnamed constants
named text
names for use with GOTO statements named constants 
BLOCKS
CONSTANTS
DEFINES
LABELS
LITERALS
PROCEDURES
PROCPARAMS procedures that are formal parameters SUBPROCS 
TEMPLATES STRUCT (*) names
UNREF unreferenced identifiers VARIABLES 
The default class list includes all classes except CONSTANTS and UNREF. TAL does not support cross references for the CONSTANTS class. 
Generating Cross References 
To start generation of cross references for the default class list, specify CROSSREF with no parameters. To stop the generation, specify NOCROSSREF with no parameters. 
You can use CROSSREF or NOCROSSREF with no parameters for individual procedures or data blocks. These directives take effect at the beginning of the next procedure or data block. 
"1'82581 AOO 3/85 
20-17 
COMPILER OPERATION CROSSREF Directive 
COMPILER OPERATION CROSSREF Directive 
[NO]CROSSREF without parameters is effective for the entire program or until you respecify the directive. Entering [NO]CROSSREF to select a class list has no effect on starting or stopping cross-reference generation. 
Selecting Classes 
The CROSSREF directive entered to select a class list is effective for the entire program. Although you can respecify the class list, SYMSERV uses only the class list in effect at the end of compilation. 
To add classes to the previous list, specify: 
?CROSSREF, CROSSREF <add-list> 
To delete classes from the previous list, specify: 
?CROSSREF, NOCROSSREF <delete-list> 
CROSSREF Listing 
The compilation results in a single cross-reference list that follows the global map and precedes the load maps. 
CROSSREF causes cross references to be collected even if NOLIST is in effect for all or part of the compilation. To include the collected cross references in the listings, a LIST directive is required at the end of the source. (This is true only for LIST and CROSSREF.) 
The SUPPRESS directive turns off the cross-reference listing. 
It is recommended that you use the CROSSREF directive only for simple cross-reference listings. For other CROSSREF options, use the standalone command-driven CROSSREF process. See the CROSSREF Manual. 
Examples 
1. This example adds unreferenced names to the class lists in the printed output: 
?CROSSREF , CROSSREF UNREF 
20-18 
.,,82581 AOO 3/85 
COMPILER OPERATION CROSSREF Directive 
2. This example deletes LITERALS from the class list and prints the output: 
?CROSSREF , NOCROSSREF LITERALS 
3. This example suppresses part of the listing: 
-'182581 AOO 3/85 
?CROSSREF PROC p ; 
BEGIN 
END; 
?SUPPRESS PROC q; 
BEGIN 
END; ?NOSUPPRESS 
!Turn on SUPPRESS to suppress CROSSREF output 
!Turn off SUPPRESS to get CROSSREF output 
4. This example selectively collects cross references: 
?CROSSREF, CROSSREF UNREF, NOCROSSREF VARIABLES NAME test; 
INT i; 
?NOCROSSREF BLOCK PRIVATE; 
INT j; END BLOCK; 
!No cross references collected for BLOCK 
?CROSSREF, CROSSREF VARIABLES
!Variables shown; prior directive superseded 
PROC p MAIN; BEGIN 
END; 
20-19 
COMPILER OPERATION DATAPAGES Directive 
DATAPAGES Directive 
The DATAPAGES directive overrides the default number of data pages that BINSERV assigns for the object program. 
The syntax for the DATAPAGES directive is: 
DATAPAGES [ = ] <integer> 
<integer> 
is an integer in the range 0 through 64; if you specify an out-of-range value, BINSERV sets DATAPAGES to 64. 
If you omit DATAPAGES, BINSERV allocates sufficient pages for global data and enough stack space for procedure locals twice over. If you specify an insufficient amount, BINSERV uses the default algorithm. 
You can set DATAPAGES after compilation using the BINDER SET command o p t i o n s (DATA, STACK, o r EXTENDSTACK). 
You can increase data pages at run time using the RUN command MEM parameter or the memory-pages parameter of the NEWPROCESS procedure. 
20-20 
'1'82581 AOO 3/85 
DECS Directive 
The DECS directive decrements the TAL internal S-Register counter. 
The syntax for the DECS directive is: 
DECS [ = ] <sdec-value> 
<sdec-value> 
is an unsigned integer to subtract from the TAL S-Register counter. 
Use DECS when the source code manipulates the data stack. 
Example 
This example places the parameters for "procAname" on the data stack using a PUSH instruction (rather than a CALL statement). ?DECS 3 decrements the TAL internal S-Register setting by 3. 
SUBPROC s p ; BEGIN 
STACK paraml, param2, param3; !Loads parameters onto ! register stack 
CODE( PUSH %722); 
CODE( PCAL procAname); ?DECS 3 
END; 
!Pushes parameters onto ! memory stack
!Calls the procedure 
~ 82581 AOO 3/85 
20-21 
COMPILER OPERATION DECS Directive 
COMPILER OPERATION DEFEXPAND Directive 
DEFEXPAND Directive 
The DEFEXPAND directive causes the text of a DEFINE to appear in the listing when TAL translates the DEFINE. 
The default is NODEFEXPAND. 
The syntax for the DEFEXPAND directive is: 
[NO]DEFEXPAND 
When you specify DEFEXPAND, the text of the DEFINE appears in the listing on the lines following the name of the DEFINE. The text in the listing differs from the text in the DEFINE declaration as follows: 
• 
• 
• 
It contains no comments, line boundaries, or extra blanks. 
Parameters to the DEFINE appear as $<number>, where <number> is the sequence number of the parameter, starting at 1. 
Lowercase letters appear as uppercase. 
The DEFINE nesting level (starting at 1) appears in the left margin. 
20-22 
4J82581 AOO 3/85 
DUMPCONS Directive 
The DUMPCONS directive causes TAL to dump immediately all constants currently in the TAL constant table into the object code. 
The syntax for the DUMPCONS directive is: 
DUMPCONS 
TAL generates an unconditional branch around the dumped constants. DUMPCONS can be useful prior to writing CODE statements, since range requirements can force TAL to dump the constants within inline code. DUMPCONS can also avoid overflow of the TAL internal constant table. 
If you do not specify DUMPCONS, TAL inserts constants into the generated code after unconditional branches and at the end of procedures, if possible. 
/182581 AOO 3/85 
20-23 
COMPILER OPERATION DUMPCONS Directives 
COMPILER OPERATION ENDIF Directive 
ENDIF Directive 
The ENDIF directive terminates the range of the IF or IFNOT directive. ENDIF is useful with toggles and CPU type. Refer also to the IF toggle directive. 
The syntax for the ENDIF directive is: 
ENDIF { <toggle-number> { <cpu-type> 
<toggle-number> 
is an integer from 1 RESETTOG directive. 
<cpu-type> 
} } 
through 15, as specified by a SETTOG or 
is one of the following, as specified in the CPU directive: 
TNS The code executes on the Nonstop 1+ system. 
TNS/II The code executes on the Nonstop system. 
If other directives appear on the same line, the ENDIF directive must be last on the line. 
For an example, see the IF directive. 
20-24 
"'P82581 AOO 3/85 
ERRORS Directive 
The ERRORS directive sets the number of error messages at which to terminate the compilation. 
The syntax for the ERRORS directive is: 
ERRORS [ = ] <nnnnn> 
<nnnnn> 
is an integer in the range 0 through 32767 that specifies the number of error messages at which to terminate the compilation. 
TAL counts the number of error messages; a single error can cause many messages. If the count exceeds the maximum you specify, TAL 
terminates the compilation. (Warning messages do not affect the count.) 
If you do not specify ERRORS, TAL does not terminate the compilation because of the number of errors. 
Aft82581 AOO 3/85 
COMPILER OPERATION ERRORS Directive 
20-25 
COMPILER OPERATION EXTENDSTACK Directive 
EXTENDSTACK Directive 
The EXTENDSTACK directive specifies the number of pages to add to the BINDER's estimate of the stack size. 
The syntax for the EXTENDSTACK directive is: 
EXTENDSTACK < v a l u e > 
<value> 
is the number of pages to add to the stack size. 
If you omit this directive, the default is the stack size estimated by BINDER. 
Example 
This example extends the stack size by 20 pages. 
?EXTENDSTACK 20 
20-26 
-'182581 AOO 3/85 
GMAP Directive 
The GMAP directive instructs TAL to print a global map at the end of the compilation listing. 
NOGMAP suppresses the global map. The default is GMAP. 
The syntax for the GMAP directive is: 
[NO]GMAP 
The GMAP directive is a not a feature of the Nonstop 1+ software. 
GMAP is not effective unless the MAP directive is set. GMAP has no effect when the NOMAP option is in effect. However, if MAP is active you can suppress the global map by entering "?NOGMAP". 
Examples 
1. This example specifies that the global map is printed: 
?GMAP 
2. This example disables printing of the global map: 
?NOGMAP 
4't82581 AOO 3/85 
COMPILER OPERATION GMAP Directive 
20-27 
COMPILER OPERATION ICODE Directive 
!CODE Directive 
The !CODE directive causes listing of instruction code mnemonics if LIST is enabled. 
The default is NOICODE. 
The syntax for the !CODE directive is: 
[NO]ICODE 
The !CODE listing might not show final G-plus addresses for global variables. If a global variable is within a named data block, the G-plus address shown is relative to the start of the data block. At the end of the compilation, BINSERV creates the final Ci-plus address. To display the final addresses, use BINDER and INSPECT commands. 
Other code locations affected by BINSERV are: 
• Fix-up cells to global read-only arrays 
• PCAL instructions 
20-28 
~ !32581 AOO 3/85 
IF Directive 
The IF and IFNOT toggle directives specify selective compilation depending on the indicated condition. 
The syntax for the IF directive is: 
IF[NOT] { <toggle-number> } { <cpu-type> } 
<toggle-number> 
is an integer from 1 through 15, as specified in a SETTOG or RESETTOG directive. 
<cpu type> 
is specified by a CPU directive as one of the following: 
TNS The code executes on the Nonstop 1+ system. 
TNS/II The code executes on the Nonstop system. 
If other directives appear on the same line, the IF[NOT] directive must be last in the line. 
"IF <toggle-number>" directs TAL to ignore subsequent text unless the software toggle switch indicated by <toggle-number> is set by a SETTOG directive. 
"IFNOT <toggle-number>" directs TAL to ignore the text unless the toggle is not set by a SETTOG directive. 
Once skipping begins, it continues to the matching ENDIF directive. Thus, in the following fragment, TAL skips both parts if <n> is reset: 
?IF n
!Statements for true condition 
?IFNOT n
!Statements for false condition 
?ENDIF n 
-'182581 AOO 3/85 
COMPILER OPERATION IF Directive 
20-29 
COMPILER OPERATION IF Directive 
If you insert another ENDIF directive into this fragment, TAL skips only the first part if <n> is reset: 
?IF n
!Statements for true condition 
?ENDIF n ?IFNOT n 
!Statements for false condition ?ENDIF n 
Examples 
1. If CPU TNS/II is in effect, TAL compiles the code between IF TNS/II and ENDIF TNS/II and ignores the code between IFNOT and ENDIF: 
?IF TNS/II 
. 
CALL WRITE (term, buff , 67); 
?ENDIF TNS/II ?IFNOT TNS/II 
. 
CALL WRITE (term, buff2, 78); 
?ENDIF TNS/II 
!If the Nonstop system is the ! execution system • . • 
!If the Nonstop system is not ! the execution system 
2. This example tests the toggle number, finds it is ON (set by SETTOG), and causes TAL to include the procedure: 
20-30 
?SETTOG 1 
?IF 1
PROC some"'proc; BEGIN 
END; ?ENDIF 1 
!Turns toggle number 1 ON 
!Tests toggle number 1 !Toggle 1 is ON; executes ! procedure 
'1J82581 AOO 3/85 
INHIBITXX Directive 
The INHIBITXX directive suppresses generation of the extended, indexed ('XX') instructions (LWXX, SWXX, LBXX, and SBXX) for extended pointers relocated beyond the first 64 words of primary global data. 
The default is NOINHIBITXX. 
The syntax for the INHIBITXX directive is: 
[NO]INHIBITXX 
You should specify [NO]INHIBITXX before the global declarations occur. 
The 'XX' instructions assume that the extended pointer is located between G[O] and G[63] of the primary global data area. The 'XX' 
instructions are described in the System Description Manual for the Nonstop system. 
.., 82581 AOO 3/85 
COMPILER OPERATION INHIBITXX Directive 
20-31 
COMPILER OPERATION INNERLIST Directive 
INNERLIST Directive 
The INNERLIST directive lists the instruction code mnemonics generated by TAL after each statement if LIST is enabled. It also shows the TAL RP setting. 
The default is NOINNERLIST. 
The syntax for the INNERLIST directive is: 
[NO]INNERLIST 
The INNERLIST listing is less complete than the !CODE listing. Since TAL is a one-pass compiler, many instructions appear with skeleton or space-holder images that TAL or BINSERV modifies later. 
20-32 
Aj82581 AOO 3/85 
INSPECT Directive 
The INSPECT directive specifies that INSPECT is the default debugger for the object file. 
The default is NOINSPECT. 
The syntax for the INSPECT directive is: 
[NO] INSPECT 
The last [NO]INSPECT directive in a compilation unit takes effect for the object file. 
You can also set the default debugger after compilation using: 
• The SET INSPECT command of the BINDER 
• T h e COMINT SET INSPECT a n d RUN c o m m a n d s 
You cannot override INSPECT at run time. 
The INSPECT, SAVEABEND and SYMBOLS directives are interrelated. BINSERV and BIND automatically set INSPECT ON if the SAVEABEND directive specifies creation of a save file. The NOINSPECT directive causes BINSERV and BIND to set SAVEABEND OFF. 
To use the full symbolic debugging features of INSPECT, specify the SYMBOLS directive to generate the symbol table in the object file. You can turn the SYMBOLS directive on and off on a procedure-by- procedure or block-by-block basis. (Even if you do not specify SYMBOLS, INSPECT still recognizes procedure names in code locations.) 
4982581 AOO 3/85 
20-33 
COMPILER OPERATION INSPECT Directive 
COMPILER OPERATION INSPECT Directive 
Example 
This example requests INSPECT and SAVEABEND for the entire object file and SYMBOLS for part of the code: 
? INSPECT, SYMBOLS, SAVEABEND PROC a ; 
END;
? NOSYMBOLS PROC b ; 
END; 
20-34 
"fB2581 AOO 3/85 
LIBRARY Directive 
The LIBRARY directive specifies the name of the Nonstop software user library to be associated with the object file at run time. 
The syntax for the LIBRARY directive is: 
LIBRARY <file-name> 
<file-name> 
specifies a user library to search before the system library for satisfying external references. 
You can also change the library name either in a BIND session or by using the LIB parameter of the COMINT RUN command. 
-''f 82581 AOO 3/85 
20-35 
COMPILER OPERATION LIBRARY Directive 
COMPILER OPERATION LINES Directive 
LINES Directive 
The LINES directive sets the maximum number of output lines per page. 
The syntax for the LINES directive is: 
LINES <value> 
<value> 
is a decimal number in the range 10 through 32767. The default value is 60 lines per page. 
The LINES directive is not a feature of the Nonstop 1+ software. 
Example 
This example sets the maximum number of lines per page of output listing at 66 lines per page: 
?LINES 66 
20--36 
~ 82581 AOO 3/85 
LIST Directive 
The LIST directive specifies that each source image is written to the list file and enables other list options. 
The default is NOLIST. 
The syntax for the LIST directive is: 
[NO]LIST 
You can specify the LIST directive anywhere in the source text. 
The ABSLIST, CODE, !CODE, INNERLIST, MAP, LMAP, GMAP, and PAGE directives require the LIST directive. 
The SUPPRESS directive overrides LIST. 
-'182581 AOO 3/85 
COMPILER OPERATION LIST Directive 
20-37 
COMPILER OPERATION I.MAP Directive 
LMAP Directive 
The LMAP directive specifies the types of load-map and cross-reference information requested from BINSERV. 
NOLMAP cancels LMAP. The default is LMAP ALPHA. 
The syntax for the LMAP directive is: 
{ <!map-option> } [NO]LMAP { ( <!map-option> [ , <!map-option> ] ... ) } {*} 
<!map-option> 
specifies the type of map: it is one of: 
ALPHA 
specifies load maps of procedures and data blocks sorted by name. 
LOC 
specifies load maps of procedures and data blocks sorted by starting address. 
XREF 
specifies an entry point and data block cross reference for the object file. This differs from source-level cross references produced by the CROSSREF directive. 
* 
NOLMAP with options specifies that, if LMAP is in effect, the stated options are turned off. NOLMAP without options suppresses the map entirely. 
In releases before TAL EOl, LMAP (ALPHA, LOC) is equivalent to LMAP * Now LMAP * means the output listings contain the ALPHA and LOC maps 
specifies ALPHA and LOC maps and the cross-reference listings. LMAP* is equivalent to LMAP * 
20-38 Aj82581 AOO 3/85 
and the cross-reference data that BINSERV collects. The XREF information listed includes an entry-point cross reference and a 
common data-block cross reference. 
Example 
This example illustrates the LMAP directive: 
?LMAP (LOC, XREF) !Adds LOC and XREF to ALPHA default 
. 
?NOLMAP (XREF) !Deletes only XREF from the listing 
"182581 AOO 3/85 
COMPILER OPERATION LMAP Directive 
20-39 
COMPILER OPERATION MAP Directive 
MAP Directive 
The MAP directive controls the display of identifier maps in the listing, if LIST is enabled. 
NOMAP cancels MAP. The default is MAP. 
The syntax for the MAP directive is: 
[NO]MAP 
MAP displays sublocal identifiers following each subprocedure, local identifiers following each procedure, and global identifiers following the last procedure in the source program. 
The MAP directive requires the LIST directive. The GMAP directive requires the MAP directive. 
20--40 
-'f82581 AOO 3/85 
PAGE Directive 
The PAGE directive causes a page eject on the listing file after the first PAGE directive, prints the optional heading, then skips two lines before listing continues. 
The syntax for the PAGE directive is: 
PAGE [ " <heading-string> " ] 
<heading-string> 
is a character string that contains a maximum of 61 characters on a single line, enclosed in quotation marks. 
PAGE is effective only if you specify the LIST directive. 
The first PAGE directive in a source program does not cause a page eject. Rather, it specifies an initial heading string. 
A subsequent <heading-string> replaces the previous header. 
The quotation marks are required delimiters; they are not printed. If the string is too long, TAL truncates the extra characters. 
If the list file is not a line printer or a process, TAL ignores the PAGE directive. 
'1'f 82581 AOO 3/85 
20-41 
COMPILER OPERATION PAGE Directive 
COMPILER OPERATION PEP Directive 
PEP Directive 
The PEP directive specifies the anticipated size, in words, of the PEP table. 
The syntax for the PEP directive is: 
PEP [ = ] <pep-table-size> 
<pep-table-size> 
is an integer in the range 3 through 512 to use as the size of the PEP table. 
The <pep-table-size> must be at least large enough to contain the PEP, that is, one word per entry point that is not external. It can be a larger value. 
You can respecify the PEP size at any time (without causing a warning from TAL), or it can be insufficient for the program: in either case, the ABSLIST addresses produced are invalid. 
You should use the PEP directive if you use the ABSLIST directive so that TAL knows how much space BINSERV allocates for the PEP. (ABSLIST 
means TAL lists code-relative addresses for instruction locations). 
Example 
The following example illustrates the PEP directive: 
?PEP 60 
20-42 
4'82581 AOO 3/85 
PRINTSYM Directive 
The PRINTSYM directive enables the printing of a symbol or group of symbols as part of the output listing. 
The default is PRINTSYM. NOPRINTSYM disables PRINTSYM. 
The syntax for the PRINTSYM directive is: 
[NO]PRINTSYM 
The PRINTSYM directive is not a feature of the Nonstop 1+ software. 
You can use the PRINTSYM directive for global, local, or sublocal declarations. 
Example 
This example suppresses printing in the global map of variables "i" and "j", which are declared between the NOPRINTSYM directive and the PRINTSYM directive: 
?NOPRINTSYM INT i; 
INT j; ?PRINTSYM 
INT k; 
4J82581 AOO 3/85 
COMPILER OPERATION PRINTSYM Directive 
20-43 
COMPILER OPERATION RELOCATE Directive 
RELOCATE Directive 
The RELOCATE directive directs TAL to list BINSERV warnings for declarations that depend on absolute addresses in the primary global data area. 
The syntax for the RELOCATE directive is: 
RELOCATE 
The binder process issues warnings for references to nonrelocatable data during the target-file build (whether at compile time or in command-driven mode.) 
TAL checks for nonrelocatable data only if RELOCATE appears. 
Since RELOCATE is only effective for the source code that follows it, be sure to specify it at the beginning of the compilation. 
Use the RELOCATE directive when the primary global data area (the area below word 256) is relocatable. If you are using the separate compilation features of TAL or binding TAL code with code written 
in other languages, the primary global data must be relocatable. 
An example of a nonrelocatable data declaration is: 
INT i = 'G' + 22; 
References to "i" produce a warning when RELOCATE is in effect. 
20-44 
..,, 82581 AOO 3/85 
RESETTOG Directive 
The RESETTOG directive turns the specified toggles to OFF. 
The syntax for the RESETTOG directive is: 
RESETTOG [ <toggle-number> [ , <toggle-number> ] ..• ] 
<toggle-number> 
is an integer from 1 through 15. If you do not specify a <toggle-number>, TAL resets all toggles to OFF. 
If other directives appear on the same line, RESETTOG must be the last directive on the line. 
The IF, ENDIF, IFNOT, and SETTOG directives also control the toggles. For more information, refer to the SETTOG directive. 
Example 
This example tests the toggle, finds it is reset, and causes TAL to skip over the source text between "IF 1" and "?ENDIF 1": 
?RESETTOG 1 
?If 1 
PROC some"'proc: BEGIN 
END; 
?ENDIF 1 
!Turns toggle number 1 OFF 
!Tests toggle, finds it turned OFF 
!TAL skips procedure 
4"82581 AOO 3/85 
COMPILER OPERATION RESETTOG Directive 
20-45 
COMPILER OPERATION ROUND Directive 
ROUND Directive 
The ROUND directive specifies that rounding occurs when a FIXED value is assigned to a FIXED variable with a smaller <fpoint> value. 
The default is NOROUND. 
The syntax for the ROUND directive is: 
[NO]ROUND 
ROUND scales the value of the operand, if necessary, to match the <fpoint> of the assignment variable. If the <fpoint> of the operand 
is greater than that of the variable, the operand is first scaled, if necessary, so that its <fpoint> is one greater than the variable. The sca~ed operand is rounded as shown below: 
(IF operand < 0 THEN operand - 5 ELSE operand + 5) I 10 
That is, if the operand is negative, 5 is subtracted: if positive,
5 is added. Then, an integer divide by 10 rounds the operand and scales it down by a factor of 10. Therefore, if the absolute value of the least significant digit of the operand after initial scaling is 5 or more, one is added to the absolute value of the final least significant digit. 
NOROUND specifies that rounding does not occur when a FIXED value is assigned to a FIXED variable with a smaller <fpoint> value. The value of the operand assigned to the variable is scaled, if necessary, to match the <fpoint> value of the variable. If the <fpoint> value of the operand is greater than that of the variable, the operand is scaled down and some precision is lost. 
20-46 
'1f82581 AOO 3/85 
RP Directive 
The RP directive sets the register stack RP count that TAL uses as the current value. 
The syntax for the RP directive is: 
RP [ = ] <register-number> 
<register-number> 
specifies the number to which TAL sets its internal RP count.
If you specify 7, TAL considers the register stack to be empty. 
The RP value is that of the top element in the register stack. Use it to manipulate the register stack within the source text. Refer to the System Description Manual for register stack information. 
You can use the RP directive only within a procedure. 
Following each high-level statement (not CODE, STACK, or STORE), the TAL internal RP setting is always 7. 
Example 
This example informs TAL that five elements are loaded and, therefore, the current RP setting is 4: 
FORi :=0TO4DOSTACK( i ); ?RP = 4 
~ 82581 AOO 3/85 
20-47 
COMPILER OPERATION RP Directive 
COMPILER OPERATION SAVEABEND Directive 
SAVEABEND Directive 
The SAVEABEND directive causes INSPECT to generate a save file if the process abnormally terminates during execution. 
The default is NOSAVEABEND. 
The syntax for the SAVEABEND directive is: 
[NO]SAVEABEND 
For this option to be effective at run time, INSPECT must be available on the system that runs the process. 
This directive can appear anywhere in the source program. BINSERV uses the last specification when building the object file. 
If you use SAVEABEND, BINSERV automatically sets the INSPECT directive ON. {NOSAVEABEND does not affect the INSPECT directive.) 
The save file contains data area and file-status information at the time of failure. You can examine the save file during an INSPECT session. INSPECT assigns the save file a name of the form ZZSA<nnnn>, where <nnnn> is an integer. The defaults for volume and subvolume are the object program's volume and subvolume. {You can specify a name for the save file using INSPECT.) Refer to the INSPECT Interactive Symbolic Debugger User's Manual for information on the save file. 
You can respecify the SAVEABEND option for a process using either the BINDER or RUN options. 
20-48 
.., 82581 AOO 3/85 
SEARCH Directive 
The SEARCH directive directs TAL to construct a list of object files from which BINSERV can resolve unsatisfied external references and validate parameter lists at the end of compilation. 
The default is SEARCH with no file-name list, which means BINSERV does not attempt to satisfy remaining external references: no search
occurs. 
The syntax for the SEARCH directive is: 
SEARCH <object-file-name> ] ( <object-file-name> [ , <object-file-name> ] .•• ) ] 
<object-file-name> 
is a valid file name for an object file: TAL provides automatic file name expansion. Specify the names in the order you want the search to take place. 
A SEARCH directive can extend to continuation lines, each beginning with "?" in column 1. SEARCH directives can appear anywhere in the source code. 
The search list is an ordered list that BINSERV uses to retrieve object code at bind time for inclusion in the object file. 
If multiple SEARCH directives with file names occur, BINSERV appends the file names to the search list in the order specified. The order
is important if more than one file contains a procedure or entry-point name that resolves an external reference. BINSERV includes the first occurrence and ignores any subsequent occurrences. 
A SEARCH directive with no file names clears the search list. BINSERV can only satisfy external references using files that remain on the search list at the end of compilation. 
~ 82581 AOO 3/85 
20-49 
COMPILER OPERATION SEARCH Directive 
COMPILER OPERATION SECTION Directive 
SECTION Directive 
The SECTION directive gives a name to a section of a source file for use in a SOURCE directive. 
The syntax for the SECTION directive is: 
SECTION <text-name> 
<text-name> 
is a valid TAL identifier to associate with all source text that follows the SECTION directive until another SECTION 
directive or the end of the source file occurs. 
The SECTION directive must be the only directive on the directive line. 
Example 
This example gives a section name to each procedure in a source library: 
!File name "appllib"
?SECTION sortAproc
PROC sortAonAkey(keyl, key2, key3, length); 
INT . keyl, •key2, . key3, length~ BEGIN 
END;
?SECTION next~procedure 
Another source file includes the previous file name and a section name in a SOURCE directive: 
?SOURCE appllib (sortAproc) 
20-50 
"'82581 AOO 3/85 
SETTOG Directive 
The SETTOG directive turns on all specified toggles. 
The syntax for the SETTOG directive is: 
SETTOG [<toggle-number> [ , <toggle-number>] ..• ] 
<-toggle-number> 
is an integer from 1 to 15; if you omit <toggle-number>, all toggles are turned on. 
If other directives appear on the same line, SETTOG must be the last directive on the line. 
The IF, ENDIF, IFNOT, and RESETTOG directives also control the toggles. 
Example 
This example tests the toggle, finds it is set, and causes TAL to compile the source text between "IF 1" and "?ENDIF 1": 
?SETTOG 1 
?If 1
PROC some"'proc; BEGIN 
END; ?ENDIF 1 
!Turns toggle number 1 ON 
!Tests toggle, finds it turned ON !TAL compiles procedure 
4J82581 AOO 3/85 
20-51 
COMPILER OPERATION SETTOG Directive 
COMPILER OPERATION SOURCE Directive 
SOURCE Directive 
'I'he SOURCE directive specifies a file and optional section from which to read source statements. 
The syntax for the SOURCE directive is: 
SOURCE <file-name> [ ( <section-name> 
[ , <section-name> ] .•. ) ] 
<file-name> 
specifies the name of the disc file from which TAL reads source statements. 
<section-name> 
is a name specified in a SECTION directive within the source file <file-name>. If TAL does not find <section-name> in the specified file, it issues a warning. 
TAL processes the source file until an end of file occurs (or until TAL reads all the sections in the section list). TAL then begins reading at the line following the SOURCE directive. The maximum number of source files you can have open at a time (nested SOURCE directives) is four. 
If you include other directives on the same line, the SOURCE directive must be last in the line. The list of section names can extend to continuation lines, each of which must begin with a "?" in column 1. 
Example 
This example of the SOURCE directive includes an entire file: 
?SOURCE $src.current.routines 
20-52 
4J82581 AOO 3/85 
STACK Directive 
The STACK directive specifies the number of pages you want as the stack size instead of the estimated size. 
The syntax for the STACK directive is: 
STACK <value> 
<value> 
is the data stack size in pages. 
If you omit this directive, the default is the space estimated by BINSERV for local storage. 
The total number of data pages is equal to the number of pages specified plus the space required for global data blocks. 
Example 
This example sets the stack size to 20 pages: 
?STACK 20 
"'82581 AOO 3/85 
COMPILER OPERATION STACK Directive 
20-53 
COMPILER OPERATION SUPPRESS Directive 
SUPPRESS Directive 
The SUPPRESS directive is a master override of the listing directives. 
The default is NOSUPPRESS. 
The syntax for the SUPPRESS directive is: 
[NO]SUPPRESS 
SUPPRESS overrides the CODE, CROSSREF, GMAP, !CODE, INNERLIST, LIST, LMAP, MAP, and PAGE directives. 
It suppresses all compilation listing output except the compiler leader text, diagnostic messages, and the trailer text. That is, TAL and BINSERV produce diagnostic and trailer text, but BINSERV does not produce the load maps. 
Specifying SUPPRESS on the TAL run command line suppresses the listing without altering the source text. 
Both SUPPRESS and NOSUPPRESS can appear in the source text. 
20-54 
-''f 132581 AOO 3 / 8 5 
SYMBOLS Directive 
The SYMBOLS directive directs TAL to include a symbol table {for INSPECT symbolic debugging) in the object file. 
The default is NOSYMBOLS. 
The syntax for the SYMBOLS directive is: 
[NO]SYMBOLS 
You can specify the SYMBOLS directive on a procedure-by-procedure or a block-by-block basis. For symbols in a procedure, specify SYMBOLS before the PROC declaration. For symbols i~ a global data block, specify SYMBOLS before the BLOCK declaration or the first global declaration in an implicit block. 
After debugging the program, you can delete symbol tables from the object file by using the BINDER. BINDER provides two methods: 
1. This method creates a new object file without symbols and copies it to the target file. The old object file remains intact. 
ADD * FROM oldobj SET SYMBOLS OFF BUILD newobj 
2. This method deletes both symbol and BINDER tables from the old object file and does not copy it to the target file. You can no 
longer use a binder process to examine or modify the file. Before deleting the tables, you can save the file by using the BACKUP program described in the GUARDIAN Operating System User's Guide. 
STRIP oldobj 
Refer to the BINDER Manual for more information. 
-'f82581 AOO 3/85 
20-55 
COMPILER OPERATION SYMBOLS Directive 
COMPILER OPERATION SYMBOLS Directive 
E:xample 
This example includes symbols in a procedure and a global data block: 
20-56 
Af'82581 AOO 3/85 
NAME the"unit; ?SYMBOLS 
INT a ; STRING b; 
?NOSYMBOLS 
BLOCK global"data; FIXED c ; 
STRING d; END BLOCK; 
?SYMBOLS PROC u x b ; BEGIN 
END; 
!Include symbols in implicit block 
!Stop symbols 
!Include symbols in procedure 
SYNTAX Directive 
The SYNTAX directive requests a syntax check of the source text without object code generation. 
The syntax for the SYNTAX directive is: 
SYNTAX 
Specifying SYNTAX does not affect the CROSSREF directive. TAL can generate a cross-reference listing even if it produces no object file. 
TAL automatically starts BINSERV, which is not needed if TAL produces no object file. To prevent TAL from starting BINSERV, specify SYNTAX on the command line, or to stop BINSERV, specify SYNTAX early in the source text. 
~ 82581 AOO 3/85 
20-57 
COMPILER OPERATION SYNTAX Directive 
COMPILER OPERATION WARN Directive 
WARN Directive 
For Nonstop software, the WARN directive prints a selected warning
or all warnings. For Nonstop 1+ software, it prints on all warnings. 
NOWARN prevents printing of warnings. The default is WARN. 
The syntax for the WARN directive is: 
[NO]WARN [ < v a l u e > ] 
<value> 
is the number of a warning message; <value> applies only to Nonstop software. 
Even if NOWARN is in effect, the total count of warninqs that appears in the trailer includes all warnings, whether printed or not. 
Using NOWARN to suppress a warning is useful when your compilation produces a warning and you have determined that no real problem
exists. Precede the source line that produces the message with NOWARN and the number of the warning message you want suppressed. 
To print selected warnings, you must first specify WARN. If you enter NOWARN first, any subsequent WARN <value> diectives have no effect. 
Example 
1. This example disables the printing of all warning messages: 
?NOWARN 
2. This example, which applies only to Nonstop software, disables the printing of warning message 12: 
?NOWARN 12 
20-58 
.-,. 82581 AOO 3/85 
SECTION 21 
COMPILER LISTING 
This section describes the TAL listing and gives brief samples of the information. A TAL listing can consist of: 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
Header 
Banner 
Compiler Messages 
Source Listing 
Local or Sublocal Map 
CODE Listing 
ICODE Listing 
Global Map 
Cross-Reference Listings 
LMAP Listings 
Compilation Statistics 
-'1' 82581 AOO 3/85 
21-1 
COMPILER LISTING Header 
HEADER 
The header for each page consists of: 
• The listing page number 
• The name of the current source file 
• The sequence number for the current source file 
• The date and time of compilation in the form mm/dd/yy hh:mm:ss
(not shown in the examples that follow) in the right-hand corner of 
all pages after the first 
• An optional page heading caused by the PAGE directive or by TAL 
In a listing for multiple source files, the pages containing load maps, cross references, and statistics show the name and number of the 
first file. The sample headers in Figure 21-1 show the case of a multisource file listing. 
21-2 
page num 
PAGE 1 PAGE 2 PAGE 3 PAGE 4 PAGE 59 PAGE 66 PAGE 70 
source file name 
$VOL.PROG1.SOURCE1S $VOL.PROG1.SOURCE2S $VOL.PROG1.SOURCE2S $SHR.MSGXX.IMSGSHRS $VOL.PROG1.SOURCE1S $VOL.PROG1.SOURCE1S $VOL.PROG1.SOURCE1S 
num optional heading 
[1] [2] [2] [3] [1] [1] [1] 
MY ROOT SOURCE FILE MY ROOT SOURCE F I L E 
INTERPROCESS MESSAGES
GLOBAL MAP
LOAD MAPS
BINDER AND COMPILER STATISTICS 
Figure 21-1. Page Headers 
" ' f 8~~581 A O O 3 / 8 5 
BANNER 
The first page of the listing contains a banner with the heading: 
• Compiler version 
• Date and time at the start of this compilation 
• Language and target machine 
• Default options 
Figure 21-2 shows a two-line sample banner that is folded only for illustration. 
TAL - T 9 2 5 0 B O O - 2 8 J A N 8 5 SOURCE LANGUAGE: TAL -
TARGET MACHINE: TANDEM NONSTOP I I SYSTEM 
DATE - TIME : 2/11/85 - 13:47:47
DEFAULT OPTIONS: ON (LIST,CODE,MAP, WARN,LMAP) - 
COMPILER MESSAGES 
OFF (ICODE,INNERLIST) 
Figure 21-2. Banner 
When TAL detects unusual conditions, it issues diagnostic messages conditions interleaved with source statements. (See Appendix C for compiler error and warning messages.) 
BINSERV diagnostic messages appear during and after the source listing. (See the BINDER Manual for BINSERV messages.) 
4l82581 AOO 3/85 
COMPILER LISTING Banner 
21-3 
COMPILER LISTING Source Listing 
SOURCE LISTING 
If the LIST directive is in effect (the default), the source text for each procedure is listed line by line. Each line consists of: 
• The edit-file line number 
• The offset from the procedure base of the generated code 
• Lexical (nesting) level of source text 
• BEGIN-END pair counter 
• Text line from source file 
Edit-File Line Number 
An edit-file line number precedes each line of source text. Directives entered in the command line appear before the contents of the edit file without line numbers. For text read in response to a SOURCE directive, the edit-file line numbers correspond to the file named in the SOURCE directive. 
Code-Address Field 
The code address is a six-digit octal number. Depending on the line of source text, it represents an instruction offset or a secondary global count. 
For a line of data declarations, the code-address value is a cumulative count of the amount of secondary global storage allocated for the program. The count is relative to the beginning of the secondary global storage. The beginning address is one greater than the last address assigned to primary global storage. 
For a line of instructions, the code-address value is the address of the first instruction generated from the TAL source statement on the line. Normally, the octal value is the offset from the base of the current procedure: the instruction at the base has an offset of zero. Adding the offset to the procedure base address yields the code-relative address of the instruction. The procedure base address is listed in the entry-point load map (described later in this 
sect ion) . 
21-4 
"1'82581 AOO 3/85 
COMPILER LISTING Source Listing 
If the ABSLIST directive is in effect, TAL attempts to list the address for each line relative to location C[O]. The limitations on the use of ABSLIST are given in the description of the directive in Section 20. 
If a procedure or subprocedure has initialized data declarations, TAL emits code to initialize the data at the start of the procedure or subprocedure. The offset or address listed for the first instruction is greater than one to allow for the initialization code. 
Lexical-Level Counter 
The lexical-level counter is a single-digit number. It represents the compiler's interpretation of the current'source line, as follows: 
Value 
Lexical Level 
1.	0  Global level 
2.	1  Procedure level 
3.	2  Subprocedure level 
BEGIN-END Pair Counter 
The BEGIN-END pair counter indicates nesting of procedures and subprocedures. 
TAL counts BEGIN keywords and matches each BEGIN with an END keyword in STRUCT declarations and in instruction-generating code by incrementing the counter for each BEGIN and decrementing it for each 
END. TAL displays the value of the counter for each line of source text. 
Figure 21-3 is a sample listing page in which TAL reads text from another file (see SOURCE directive in line 4). 
4982581 AOO 3/85 
21-5 
COMPILER LISTING Source Listing 
2. 000000 3. 000000 4. 000000 1. 000000 
2.	000000 
3.	000000 
4.	000000 
5.	000000 
6.	000000 
7.	000000 
5. 000000 
. 
24.	000000 
25.	000000 
26.	000000 
27.	000004 
28.	000004 
. 
31.	000021 
32.	000023 
33.	000032 
34. 000033 
. 
37. 000051
38. 000051 1 2 39. 000051 1 1 
?!CODE, SYMBOLS, SAVEABEND, INSPECT 
NAME outAf ileAhandler: 
?SOURCE o u t d
!Out file size declarations 
BLOCK out"'data: LITERAL 
outblklen = 1024, 
out"'rec"'len == 256: END BLOCK; > 
PROC outAfileAinit: BEGIN 
llf
STRING ext"'name [0:7] := [ TPR "] : 
INT internal"'name [0:11]; INT length, error: 
IF length THEN BEGIN
CALL OPEN {internalAname, out"'file): 
21-6 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 1 0 1 1 1 1 1 1 
1 1 1 2 1 2 1 3 
I F 
< THEN BEGIN
CALL FILEOPEN {out"'file, error); 
1 3 
END: END 
ELSE BEGIN 
Lt__ BEGIN-END Pair Counter Lexical-Level Counter
Code Address Field 
Line Number From Edit File 
Figure 21-3. Source Listing 
4182581 AOO 3/85 
LOCAL OR SUBLOCAL MAP 
If the MAP directive in effect (the default), the map of local or sublocal identifiers follows the corresponding source listing. This map gives the following information: 
• Class--VARIABLE, SUBPROC, ENTRY, LABEL, DEFINE, or LITERAL 
For STRUCT variables, it is "VARIABLE,<n>" (where <n> is an octal value giving the length in bytes). 
• Type--The contents of this field depend on the identifier class: 
--For the VARIABLE class~ the type is STRING, INT, INT(32), REAL, REAL(64), FIXED, STRUCT, STRUCT-I, SUBSTRUCT, or TEMPLATE (bytes 
in octal). STRUCT-I means an INT structure pointer. 
--For the SUBPROC, LABEL, ENTRY, and DEFINE classes, this field is blank. 
• The next field is one of: 
--Address Mode (DIRECT or INDIRECT) 
--Offset of SUBPROC, ENTRY, or LABEL in the form "%nnnnnn" 
The offset is relative to the base of the mapped PROC or SUBPROC. For nested subprocedures, the base corresponds to the current map. 
--Value declared for a LITERAL or DEFINE 
TAL prints DEFINE values to the end of the listing line, then truncates the rest. 
• Relative Address--For data, it consists of the base (L+, L-, P+, or X) and the offset from the base in octal: 
--L+<nnn> for local variables 
--L-<nnn> for parameters 
--P+<nnn> for read-only (P-relative) arrays 
--X OO<n> for index registers 
...,. 82581 AOO 3/85 
21-7 
COMPILER LISTING Local or Sublocal Map 
COMPILER LISTING CODE Listing 
Figure 21-4 shows a local map corresponding to the following function procedure: 
INT PROC computeAhash ( name, tableAlength ); INT .name;
INT(32) tableAlength; 
BEGIN
INT intAtableAlength := $INT(tableAlength); INT hashAval := O; 
USE name"' index; USE nameA lim it: 
nameAlimit := name.<8:14>;
FOR nameAindex := 0 TO nameAlimit DO 
hashAval := ((hashAval '<<' 3) LOR hashAval.<0:2>)
XOR name[ nameAindex ]; 
RETURN $UDBL($INT (hashAval '*' 23971)) '\' intAtable"'length; END; !computeAhash 
Identifer Name 
HASW'VAL INTATABLE"'LENGTH 
NAME
NAME"' INDEX NAME"' LIMIT TABLE ALENGTH 
CODE LISTING 
Class 
VARIABLE VARIABLE VARIABLE VARIABLE VARIABLE VARIABLE 
Type Address Mode 
INT DIRECT INT DIRECT INT INDIRECT INT DIRECT INT DIRECT INT(32) DIRECT 
Relative Address 
L+002 L+OOl L-005 x 007 x 006 L-004 
21-8 
Figure 21-4. Local Map 
If CODE (the default) and LIST are in effect, TAL produces an octal code listing following the local map if one exists. 
I~igure 21-5 shows a sample CODE listing corresponding to the previous hash procedure. The octal address in the left-hand column is the dffset from the procedure base. (If ABSLIST is in effect, TAL attempts to list code-relative addresses.) Each octal address is followed by eight words of instructions to the end of the procedure. 
.,.82581 AOO 3/85 
._, 82581 
AOO 3/85 
21-9 
Address Octal Instruction Words 
00000 060704 000110 100000 024711 140705 030101 006177 000116 00010 103777 000136 010410 040402 030003 040402 030115 000011 
00020 143705 000012 044402 013767 100000 040402 005135 004243 00030 000202 000111 040401 000203 000100 125006 
Figure 21-5. CODE Listing 
ICODE LISTING 
If !CODE and LIST are in effect, TAL produces a instruction mnemonic listing. Figure 21-6 shows a sample !CODE listing that is equivalent to the CODE sample. 
Address 
Instruction Mnemonics 
000000 1 LDD 7 PUSH 
000006 0 ANRI 0 LDRA 
000014 1 LLS 1 LOR 
000022 0 STOR 1 LOAD 
L-004 711 
+177 6 
03 
L+002 L+002 
0 0 
7 0 
STAR01 LOAD L-005,I 0 
STAR67 BUN +010 1 
LDI +000 
000030 2
1 LDIV 
2 LOAD L + 0 0 2 2 2 LOAD L-005,I,7 1 
7 BOX -011,7 0 2LDLI +135 2 
1STAR 1 2 0STRP 0 0 
LRS 
LDXI LOAD 
LRS XOR 
LDI ORRI 
LOAD EXIT 
0 1 
-001,7 L+002 
15 
+000 243 
L+OOl 06 
LMPY 
Figure 21-6. ICODE Listing 
COMPILER LISTING ICODE Listing 
COMPILER LISTING Global Map 
GLOBAL MAP 
If MAP is in effect, the global map lists all identifiers in the compilation unit. For Nonstop software, GMAP must also be in effect. NOMAP specified at the end of the source file suppresses the global 
map but not the local maps. global map. 
Identifier Class 
ABEND PROC ABENDPARAM DEFINE AB"OPENERR DEFINE ACCESSAJNK DEFINE 
Figure 21-7 shows sample E~ntries of a 
21-10 
Af'82581 AOO 3/85 
ACCESS"' INFO 1 INCLALEN 1 AC 
ACAINFO"'DEF ADDA ALLAFCB AP"'BLOCK APAFILE"OK BLIST"'CTL CODAPTR COMPRS DIMEN"'INFO 
1 NUM
1 DOUCE 1 DIM"T 
2 LOWAC 2 UP"'C 
2 LOW"'B 
2 UPAB FILE INFO 
TEMPLATE,402 
PROC FNAMECOLLAPSE PROC 
EXTERNAL EXTERNAL 
Type 
VARIABLE
0,2 INT 
2,2 INT 
DEFINE
LITERAL INT DEFINE
BLOCK
PROC INT 
Class-Specific Information 
EXTERNAL OPTIONS.<10:10> %B00000000001D ASSIGN.OPTIONl.<05:05> 
VARIABLE,4 VARIABLE VARIABLE VARIABLE 
0,2 2,2 4,12 4,1 5,1 6,4 
12,4 
EXTERNAL STRUCT INDIRECT 
INT(32) DIRECT INT DIRECT 
TEMPLATE,16 INT
INT 
BLST"P=OOl AP"BLOCK+002 AP"BLOCK+Oll 
SUBSTRUCT STRING STRING 
INT"(32) INTA(32) 
Figure 21-7. Global Map 
BEGIN INT INCL"LEN; INT AC[O: %000021 INT.$l[O:FSIZE-l]:=[FSIZE,%000 
CROSS-REFERENCE LISTINGS 
If CROSSREF and LIST are in effect, the cross-reference listings follow the global map. These listings are: 
• Source-file cross-reference listing (the first page) 
• Identifier cross-reference listing (subsequent pages) 
Source-File Cross References 
Figure 21-8 shows the source-file cross-reference listing. It gives the following information for each source file in the compilation: 
•	File sequence number in the compilation 
•	File name from either the IN <source-file> of the TAL run command or from a SOURCE directive 
•	Name of the source file that contained the SOURCE directive, if one appears 
•	Edit-file line number of the SOURCE directive, if one appears 
CROSSREF - CROSS-REFERENCE PROGRAM - T9622A00 - (010CT82) 
F I L E 
[1] 
[2] [3] [4] [5] 
NO. 
FILENAME.
$VOL.PROG1.SOURCE1S
$VOL.PROG1.SOURCE2S
$SYSTEM.SYSTEM.GPLDEFS
$VOL.PROG1.SOURCE4S
$SYSTEM.SYSTEM.EXTDECS SOURCElS[l] 8 
/182581 AOO 3/85 
21-11 
Figure 21-8. Source-File Cross-Reference Listing 
COMPILER LISTING Cross-Reference Listings 
SOURCElS[l] 0.1 SOURCE2S[2] 2 SOURCElS[l] 7 
COMPILER LISTING Cross-Reference Listings 
Identifier Cross References 
The identifier cross-reference listing gives the following information about each specified identifier class: 
• Identifier qualifiers 
• Compiler attributes 
• Declaring source file 
• Reference lines 
Identifier Qualifiers 
An item declared within a STRUCT, SUBPROC, or PROC can have from none to three levels of qualifiers (listed immediately following the identifier name). The general form shows the ordering of qualifier levels: 
OF <struct-name> [ OF <subproc-name> ] OF <proc-name> 
The qualifier field varies according to the following rules: 
• If an identifier has no qualifier, it is a global item. 
• If an identifier has one qualifier, it is declared in a global STRUCT o r a PROC. 
• If an identifier has two qualifiers, it is declared in either a STRUCT o r a SUBPROC w i t h i n a PROC 
• If an identifier has three qualifiers, it is declared in a STRUCT within a SUBPROC within a PROC. 
Examples of identifiers are: 
1 f f 
2 . 
3 . 
4 . 
GLOBAL"'X 
ITEM"'A 
ITEM"'B 
ITEM"'C 
OF PROC""P 
21-12 
4J82581 AOO 3/85 
OF SUBLOC"'STRUCT 
Compiler Attributes 
Compiler attributes are class (as specified in the CROSSREF directive) and type modifiers: 
Class Modifiers 
BLOCK DEFINE ENTRY LABEL LITERAL PROC SUBPROC TEMPLATE VARIABLE UNDEFINED 
none
none
type
none
type
type, EXTERNAL type 
none
type, DIRECT or INDIRECT n o n e 
Types that apply to the ENTRY, PROC, SUBPROC, and LITERAL classes are STRING, INT, INT(32), REAL, REAL(64), and FIXED. Type FIXED includes the scale if it is nonzero. 
Types for the VARIABLE class are those listed above plus STRUCT, SUBSTRUCT, STRUCT-I, and STRUCT-S. 
Declaring Source File 
The abbreviated edit-file name of the declaring source file appears
on the same line as the identifier name. The sequence number assigned to the source file appears in brackets. The line number where the declaration starts accompanies the file name. An example is: 
SOURCE1S[23] 137 
Reference Lines 
Reference lines include an entry for each reference in the
compilation. Except for read references, an alphabetic code indicates the type of reference. Codes are D (definition), I (invocation), P 
(parameter), W (write), and M (other). Refer to the CROSSREF Manual for additional information. 
.-,. 82581 AOO 3/85 
COMPILER LISTING Cross-Reference Listings 
21-13 
COMPILER LISTING LMAP Listings 
Identifier Cross-Reference Example 
The identifier cross-reference pages begin with the format shown in Figure 21-9. The header line (only on the first page of references) lists the total number of symbols referenced and the total number of references. 
1 5 2 TOTAL SYMBOLS 
ALLOCATE"CBS GPLDEFS[3] 
ALLOCATE"FCB SOURCE2S[2] 
COLLECTED WITH 
6 1 
TOTAL 
REFERENCES COLLECTED 
GPLDEF'S [ 3 ] 15 
GPLDEF'S[3] 27 
GPLDEF'S[3] 81 
SOURCE4S[4] 2 
ASSIGN"BLOCKLENGTH GPLDEFS[3] 81.1 135 
198 
5 
DEFINE 
DEFINE 
DEFAULT"VOL INT DIRECT VARIABLE SOURCElS[l] 14 w 
INT LITERAL 
MESSAGE OF STARTUP INT INDIRECT VARIABLE SOURCElS[l] 12 
SOURCElS[l] MSG"'CLOSE 
11D14
EXTERNAL PROC SOURCE4S[4] 10 
RUCB 
SOURCElS[l] 
SOURCElS[l] 
28 I 
18 p 
INT INDIRECT VARIABLE SOURCE2S[2] 5 
Figure 21-9. Identifier Cross-Reference Listing 
LMAP LISTINGS 
By default, BINSERV produces an alphabetic load map for entry points and another for data blocks, both ordered by name. If LMAP LOC is in effect, BINSERV produces load maps ordered by location in place of the alphabetic maps. For LMAP*, it produces load maps ordered by name and by location and cross-reference listings. 
The load maps are different on the Nonstop and the Nonstop 1+ system. The sample listings shown in the remainder of this section are for the Nonstop system. For sample listings produced on another system type or those showing multiple code segments, see the BINDER Manual. 
21-14 
~ 82581 AOO 3/85 
Entry-Point Load Map 
Figure 21-10 shows a sample entry-point load map by name. The fields shown for each entry point are: 
SP Code segment (space) number of the entry point 
PEP Sequence number of the entry point in the PEP table 
BASE Base address of the procedure defining the entry point 
LIMIT End address of the procedure defining the entry point 
ENTRY Address of executable code for the entry point 
ATTRS Attributes of the entry point: C (CALLABLE), E (EXTENSIBLE), I (INTERRUPT), M (MAIN), 
P (PRIVILEGED), R (RESIDENT), V (VARIABLE) 
NAME Entry-point name 
DATE Date of compilation 
TIME Timestamp of the compilation 
LANGUAGE Source language of the procedure 
SOURCE FILE File name of the source code for the procedure 
ENTRY POINT MAP BY NAME 
SP PEP 
00 031 
00 073 
00 020 
00 367 
BASE LIMIT ENTRY ATTRS NAME 
-'1J82581 AOO 3/85 
DATE TIME 
010345 043630 0010420 2/11/85 18:13 
032224 032636 032224 v 2/11/85 10:29 
000736 001072 000736 M 2/11/85 13:38 
131432 131441 131432 E 2/11/85 18:14 
LANGUAGE SOURCE F I L E 
Figure 21-10. Entry-Point Load Map by Name 
TAL 
TAL 
TAL 
TAL 
APROC $JNK.PRG1.SRCE1S 
APROC"VAR"PARAM $JNK.PRG1.SRCE2S 
MAIN"PROC $JNK.PRG1.MAINS 
SORT"PROC $JNK.PRG1.SORTS 
COMPILER LISTING LMAP Listings 
21-15 
COMPILER LISTING I~MAP Listings 
pata-Block Load Maps 
On the Nonstop system, BINSERV produces a data-block map and a read-only data-block map for primary and secondary global blocks. These maps include information from NAME and BLOCK declarations 
described in Section 22, "Separate Compilation." 
The data-block map lists the following kinds of data blocks: 
• Named BLOCK constructs, listed by the declared name 
• BLOCK PRIVATE constructs, listed by the name TAL derives from the NAME declaration prefixed with # 
• #GLOBAL and .#GLOBAL (compiler-assigned names for global data declared outside the above blocks) 
The read-only data-block map lists global read-only arrays, listed by the declared name. 
Both maps give the following information for each data block: 
BASE 
LIMIT 
TYPE 
MODE 
NAME 
DATE 
TIME 
LANGUAGE 
Base address of the block 
End address of the block (blank if block is empty) 
BINDER data-block type (own, common, or special); for TAL code, ony common blocks can occur 
Word or byte addressing 
Data-block name (see above) 
Date of compilation in the form mm/dd/yy 
Timestamp for the compilation in the form hh:mm 
Source language of the block 
SOURCE FILE Edit-file name of the source file containing the declaration of the block 
21-16 
~ 82581 AOO 3/85 
COMPILER LISTING LMAP Listings 
Figure 21-11 illustrates a data-block map by location. Figure 21-12 shows the corresponding read-only data-block map: it includes the "SP" column, which gives the code segment number specifier for each read-only array. 
DATA BLOCK MAP BY LOCATION 
BASE 
0 0 0 0 0 0 
000015 
L I M I T 
0 0 0 0 1 4 
000015 
TYPE MODE DATE TIME 
COMMON WORD 2/11/85 13:38 
COMMON WORD 
NAME 
LANGUAGE GLOBAL"' 
TAL LISW'PUB 
SOURCE F I L E 
$VOL.PRG.GLBS 
CODE 
S P 
0 0 
0 0 
SPACE 
BASE 
0 0 0 0 2 5 
0 0 0 0 5 5 
0 0 
""f82581 AOO 3/85 
Figure 21-11. Data-Block Load Map by Location 
READ-ONLY DATA BLOCK MAP BY LOCATION 
L I M I T 
0 0 0 4 1 7 
0 0 0 4 4 2 
TYPE MODE DATE TIME 
COMMON WORD 2/11/85 10:48 
COMMON WORD 2/11/85 10:48 
NAME LANGUAGE 
HASH TAL 
F I N D " ' T A B TAL 
SOURCE 
F I L E 
Figure 21-12. Read-Only Data-Block Load Map by Location 
$VOL.PRG.SRC1S 
$VOL.PRG.SRC1S 
21-17 
COMPILER LISTING Compilation Statistics 
COMPILATION STATISTICS 
TAL prints compilation statistics at the end of each compilation. If SYNTAX is in effect or if source errors occur, TAL does not print any other statistics. Figure 21-13 shows the statistics emitted when source errors stop the compilation. 
PAGE 3 $TRMNL [ 0 ] BINDER AND COMPILER 
S1~ATISTICS 
Number of compiler errors = 5
Last compiler error on page # 2 IN PROC C Number of compiler warnings = 1
Last compiler warning on page # 1
Maximum symbol table space used was = Number of source lines= 22
Elapsed time - 00:02:58 
562 bytes 
Figure 21-13. Compiler Statistics 
Object-File Statistics 
If an object file results from the compilation, TAL prints the following BINSERV statistics preceding the compiler statistics: 
• Name of the constructed object file 
• Number of binder error messages issued 
• Number of binder warning messages issued 
• Number of words of primary data area 
• Number of words of secondary data area 
• Number of resident pages required for total code space allocation 
• Minimum number of pages required for data space allocation 
• Number of code spaces (segments) 
21-18 
~ 82581 AOO 3/85 
Figure 21-14 shows sample BINSERV statistics: 
PAGE 91 \SYS.$VOL.SUBV.SRC [1] BINDER AND COMPILER STATISTICS 
BINDER - OBJECT FILE BINDER - T9621BOO - (28JAN85) SYSTEM \XXX Object file name is $XVOL.XSUBVOL.OFILE
Number of Binder errors = 0
Number of Binder warnings = 1 
Primary data = 184 words Secondary data = 10026 words Code area size = 45 pages Resident code size = 0 pages Data area size = 64 pages Number of code spaces = 1 space 
The object file will run on a TNS/II, but may not run on a TNS Number of compiler errors = 0
Number of compiler warnings = 0
Maximum symbol table space used was = 128338 bytes 
Number of source lines = 6467 Elapsed time - 00:07:47 
Figure 21-14. Object-File Statistics 
Since the compilation unit includes SEARCH directives that cause previously compiled object code to be bound with the source code, the number of source lines is small compared to the generated code. 
If a compilation ends due to a BINSERV error, TAL prints statistics including the BINSERV banner and the number of BINSERV errors and 
warnings. 
-'1J82581 AOO 3/85 
COMPILER LISTING Compilation Statistics 
21-19 
SECTION 22 
SEPARATE COMPILATION 
TAL supports modular programming with separate compilation and relocatable global data blocks. You can compile any module consisting of one or more procedures as a separate compilation unit. You can then bind the separately compiled object files into an executable 
object file called the target file by using BINSERV (compile-time binder process) or BINDER (stand-alone binder). 
This section describes the features that support separate compilation and the data-space image that results. It describes: 
• The NAME declaration for naming a compilation unit 
• The BLOCK declaration for declaring relocatable global data blocks 
• Binding compilation units 
• Data-space image 
• Sample modules 
"1'82581 AOO 3/85 
22-1 
SEPARATE COMPILATION NAME Declaration 
NAME DECLARATION 
The NAME declaration assigns a name to a compilation unit and to its private data block if it has one. 
The syntax for the NAME declaration is: 
NAME <identifier> 
<identifier> 
is the name of the compilation unit. If it has a private data block, no other compilation unit in the target file can use the same name at the global level. If this compilation unit has no private block, the name is global within this unit only. 
If a compilation unit has a BLOCK declaration, the NAME declaration must be the first declaration in the compilation unit. NAME is a 
reserved word only in the first declaration; you can use "name" elsewhere as an identifier. 
A compilation unit that has a NAME declaration as its first declaration is called a named compilation unit. 
Example 
The following example names a compilation unit: 
NAME calc"mod; 
22-2 
Af'82581 AOO 3/85 
BLOCK DECLARATION 
The BLOCK declaration lets you group global data declarations into a named or private relocatable global data block. 
The syntax for the BLOCK declaration is: 
BLOCK { <identifier> } { PRIVATE } 
<data-declaration> ] ... END BLOCK~ 
<identifier> 
is the name of the data block. The name must be unique among all BLOCK and NAME declarations in the target file.
A named data block is accessible to other compilation units. 
PRIVATE 
indicates a private global data block that is accessible only to this compilation unit. 
<data-declaration> 
is a global data declaration of any variable described in Sections 8 through 12. 
If you use the BLOCK declaration, the first declaration in the compilation unit must be the NAME declaration. In a named compilation unit, BLOCK and PRIVATE are reserved words. 
You can declare only one private block in a compilation unit. TAL gives the private block the name you specify in the NAME declaration for this compilation unit. 
You can declare any number of named data blocks in a compilation unit. 
-'f82581 AOO 3/85 
22-3 
SEPARATE COMPILATION BLOCK Declaration 
SEPARATE COMPILATION
Rules for Coding Data Blocks 
Examples 
1. This example declares a private global data block: 
BLOCK PRIVATE;
INT term"num;
LITERAL msg"buf = 79; 
END BLOCK; 
2. This example declares a named global data block: 
BLOCK default"vol;
INT .vol"array [0:7], 
.out"array [0:34]; END BLOCK; 
Rules for Coding Data Blocks 
• The correct order of global declarations is: 
--NAME declaration 
--Unblocked global data declarations 
--Named blocks and the private block 
--PROC declaration 
• All unblocked global declarations (those not contained in BLOCK declarations) must appear before the first BLOCK declaration. TAL treats the unblocked declarations as an implicit data block and gives it the name #GLOBAL. A compilation unit can have only one 
implicit block. 
If more than one compilation unit in a binding session has an implicit block, binding does not combine the implicit blocks. 
BINSERV binds in only the implicit block in the source code, not those in search lists. You can use BINDER commands to replace the implicit block in the target file. 
• The sum of the primary global blocks in the target file must not exceed 256 words. 
• All variables referenced in a data block must be declared in the same block. For example, the following declarations must appear in the same block: 
INT .var;
INT .ptr := @var; 
22-4 
'4P82581 AOO 3/85 
SEPARATE COMPILATION Sharing Data Blocks 
• The length of any shared data block must match in all compilation units; use a separate source file for each block. 
Sharing Data Blocks 
The SECTION and SOURCE directives allows sharing of global data blocks among compilation units. In the compilation unit that declares the data block, use the SECTION directive to give the block a section
name. In compilation units that need to include the data block, specify the section name in a SOURCE directive. 
If you change any data block declaration, you must recompile all compilation units that use the changed data block. 
The following example shows a compilation unit that declares global data blocks and a second compilation unit that specifies the blocks: 
!Source file name "calcAsrc" NAME calcAunit; 
?SECTION unblockedAglobals LITERAL true = -1, false = O: 
!First compilation unit 
!Name of first section !Implicit data block 
STRING readAonlyAarray = 'P' := " ","COBOL", "FORTRAN", "MUMPS", "TAL"]: 
?SECTION default BLOCK defaultAvol: 
INT .volAarray (0:7], .outAarray (0:34]; 
END BLOCK; 
?SECTION msglits BLOCK msgAliterals; 
!Name of second section !Declares named block 
!Name of third section !Declares named block 
!Ends msglits section 
LITERAL msgAeof 
msgAopen 
msg"'read END BLOCK: 
?SECTION dummy 
0' 1 , 
2' 
!----------------------------------------------------------! 
NAME inputAf ile; !Second compilation unit 
?SOURCE calcAsrc(unblockedAglobals) !Specifies implicit block ?SOURCE calcAsrc(default) !Specifies a named block 
~ 82581 AOO 3/85 
22-5 
SEPARATE COMPILATION Binding Compilation Units 
BINDING COMPILATION UNITS 
You can bind compilation units: 
• In a compilation session 
• After compilation using BINDER commands 
• At run time (library binding) 
Compile-Time Binding 
After a successful compilation, BINSERV binds the new object file with external procedures from the search list that resolve external references. If the external procedure also contains references to other external procedures or to data blocks, BINSERV tries to resolve those from the search list. (A compilation unit must declare all data in that unit.) The object files produced by BINSERV can serve as 
input to further binding operations by BINSERV, BINDER, or the operating system. 
SEARCH directives must list file names in the order in which BINSERV is to search them. Source files that contain additional SEARCH 
directives can alter the apparent order. The order might be significant if a procedure or entry-point name occurs in more than one search file. BINSERV binds only the first occurrence. 
The following example shows SEARCH directives for a search in the order "filelo," "file2o," "file3o," and "file4o": 
?SEARCH (filelo, file2o) ?SEARCH (file3o, file4o) 
The following example shows SEARCH directives for external procedures: 
22-6 
..,. 82581 
AOO 3/85 
?SEARCH partxo PROC proC'"X; EXTERNAL; 
?SEARCH partyo PROC proc"y; EXTERNAL; 
PROC procAz; BEGIN 
CALL procAx; 
CALL proc"y; END; 
!Object file containing proc"x 
!Object file containing procAy 
Interactive Binding 
After compilation, you can bind object files independently of the compiler by using the BINDER. The BINDER Manual describes 
interactive binding and lists the commands you can use. 
For example, you can use the BINDER to build a target file from separate object files, display object-file contents, reorder target-file code blocks, produce optional load maps and cross-reference listings, specify a user run-time library (Nonstop systems only), and modify the contents of named global data and code blocks in the target file. 
Run-Time Library Binding 
On Nonstop systems, you can build a run-time library of procedures to share among applications or to extend a single application's code space. Do not bind the procedures in a run-time library with the program file. Instead, store them in a separate file, then associate them with the program file by using any of the following methods: 
• A LIBRARY directive in the source file 
• A BINDER command 
• The COMINT RUN command 
The operating system performs run-time binding of a library file to the program file. The BINDER Manual describes user libraries. 
DATA-SPACE IMAGE 
TAL constructs relocatable blocks of code and data that are bound into the object file. A procedure is the smallest relocatable code block. A global data block is the smallest relocatable unit of data. 
Relocatable Global Data Blocks 
Data blocks in separate compilations and in mixed-language programs must be relocatable. TAL allocates 'G' relative offsets to 
relocatable data blocks and places read-only arrays in the user code segment in which you reference them. The primary global space occupies the first 256 words of the data space. 
"'P82581 AOO 3/85 
SEPARATE COMPILATION Data-Space Image 
22-7 
SEPARATE COMPILATION Data-Space Image 
TAL creates the following relocatable blocks, as needed: 
Unnamed Compilation Unit 
rmplicit primary global data rmplicit secondary global data 
Named Compilation Unit 
Implicit primary global data Implicit secondary global data 
Explicit primary global data Explicit secondary global data 
For primary data, TAL names the implicit block #GLOBAL and gives the private block the name used in the NAME declaration. F'or secondary data, TAL uses names made up of the primary block names plus a period symbol, as in .#GLOBAL. 
Data-Space Image Example 
Figure 22-1 shows the data-space image resulting from binding two separately compiled units, "unitAl" and "unitA2". 
The compilation units contain global declarations for an implicit data block, five named data blocks, and two private data blocks. The figure assumes that G[O] is available for compiled global data. 
22-8 
"1"82581 AOO 3/85 
Primary Area 
#GLOBAL 
block"'l 
. ~ . 
block"'5 
unit"l 
unit"2 
~ 
SEPARATE COMPILATION Data-Space Image 
~Implicit B l o c k Named Blocks 
Private Blocks 
Secondary Area 
.#GLOBAL 
.block"l 
.unit"l 
Figure 22-1. Global Data-Space Allocation 
Address Assignments 
During compilation, TAL assigns each direct variable and pointer an offset from the beginning of each relocatable block. TAL allocates storage according to the type and size of the individual data declarations in each block. 
When you bind the object code, the BINDER uses the address of the data block and the offset within the block to construct addresses for 
indirect data in the secondary data space. 
"182581 AOO 3/85 
22-9 
SEPARATE COMPILATION
Separate Compilation Sample Program 
Directives for Relocatable Data 
The RELOCATE and INHIBITXX compiler directives help you manage relocatable data: 
• RELOCATE--This directive causes TAL warnings if declarations
depend on 'G' relative addresses (such declarations might not give the correct results if data relocation occurs); it also causes BINSERV warnings if references to nonrelocatable global data occur. 
• 
INHIBITXX--This directive prevents TAL from generating indexed extended instructions for extended pointers, since relocation of the data blocks can result in an extended pointer outside the first 64 words of primary global space. 
For more information on these directives, see Section 20. 
SEPARATE COMPILATION SAMPLE PROGRAM 
This example is a utility program that converts records in the input file to a different format and length by reordering fields and adding fields to records. The example includes: 
• A brief description of program characteristics 
• Partial listings of module code 
• Load maps for the program file 
• Compilation statistics (compile and bind) for the program file 
Selected listings show the handling of data and program structure. BLOCK contents appear only in the module that declares them~ In modules that reference the blocks, NOLIST directives prevent listing of block contents. 
Compilation maps and statistics are not shown for each module. Load maps show entries for blocks that do not exist after compilation such as LITERALS. The mainline load map does not refer to these blocks. 
Program Structure 
The program consists of five modules, each of which performs a single operation. The structure of the modules and their procedures allows changes to one operation without the need to recompile the others. 
22-10 
~ 82581 AOO 3/85 
SEPARATE COMPILATION Separate Compilation Sample Program 
Information is accessible across modules on an as-needed basis. They share named global data blocks and pass information as parameters and local data such as a pointer to the locally declared record buffer. The named global data block "defaultAvol" contains shared run-time data. Other named blocks declare structure templates for record definitions and LITERAL declarations, which use no memory. 
Procedures within a module share global data in private blocks. 
Table 22-1 summarizes the blocks used by each module. In the table, the symbol (P) means a private block. 
Table 22-1. Data Blocks by Module 
Module Name Blocks Defined 
tprAconvert recordAdefs 
initializationAmodule defaultAvol 
message"'module msg"'literals messageAmodule (P) 
Blocks Referenced 
msgAliterals 
none 
default"'vol 
msg"'literals def aul t-Avol 
defaultAvol msg"'literals 
inAf ile"'handler 
outAf ile"'handler 
File Naming Conventions 
inAdata
in"'f ileAhandler (P) 
out"'data
outAf ileAhandler (P) 
The example uses the following file naming conventions: 
•	Source file names end with the character "s". 
•	Object file names correspond to source file names and end with "o". For instance, the object file built from the source file "ins" is named "ino". 
•	Data file names end in "d" if they belong to a specific module. For instance, "ind" is the source file that contains LITERAL declarations for "ins". 
•	File names ending with "p" contain EXTERNAL declarations of the procedures in the module with the corresponding name. A module that calls an external procedure includes a SOURCE directive for 
~ 82581 AOO 3/85 
22-11 
SEPARATE COMPILATION
Separate Compilation Sample Program 
the "p" file. For instance, the source for "messageAmodule" is file "msgs", and source file "msgp" declares each EXTERNAL PROC in "msgs". The modules that call "messageAmodule" specify "rnsgp" in a SOURCE directive. 
If any external declarations change, you must recompile both the "p" file and any module that calls a changed external procedure. The "p" file enables compile-time consistency checking between procedure 
declarations and the corresponding external declarations. 
A module also uses a "p" file for its external procedure declarations. Module "xxxAs" uses a SOURCE directive to specify "xxxAp", which contains EXTERNAL declarations for its procedures. (Otherwise,
the consistency check is possible only during a later binding.) 
Mainline Module 
Although the mainline module was compiled last because it contains a search list for the other modules, it is listed first to illustrate the overall logic. 
The record-definition STRUCTs are not listed because they are translations of the Data Definition Language (DDL) source code into TAL. 
22-12 
NAME tprAconvert: 
BLOCK recordAdefs; ?NOLIST, SOURCE inrec ?NOLIST, SOURCE outrec END BLOCK: 
?NOLIST, SOURCE msglit 
?NOLIST,SOURCE inp ?NOLIST,SOURCE outp ?NOLIST,SOURCE msgp ?NOLIST,SOURCE initp 
?SEARCH ino ?SEARCH auto ?SEARCH msgo ?SEARCH inito 
PROC outAinit (outArec);
STRUCT .outArec (outArecAdef); 
BEGIN ?NOLI ST END; 
!STRUCT (*) "inArecAdef" !STRUCT (*) "outArecAdef" 
!BLOCK "msgAliterals" 
!EXTERNAL PROC declarations: "inAfileAhandler"
"outAf ileAhandler" "messageAmodule" "initializationAmodule" 
!Search file list: "inAfileAhandler" "outAfileAhandler" "messageAmodule" "initializationAmodule" 
!Initializes output record 
"''f 82581 
AOO 3/85 
SEPARATE COMPILATION Separate Compilation Sample Program 
PROC recordAconvert (inArec, outArec); 
STRUCT .inArec (inArecAdef); 
STRUCT .outArec (outArecAdef); BEGIN 
?NOLI ST END; 
PROC convert; BEGIN 
!Converts between two records 
INT recordAcount := O;
STRUCT .inAbuffer (inArecAdef); STRUCT .outAbuffer (outArecAdef); 
WHILE (readAin (inAbuffer)) <> 1 DO
BEGIN !Reads record, returns EOF 
CALL outAinit (outAbuffer); !Initializes output CALL recordAconvert (inAbuffer, outAbuffer);
CALL writeAout (outAbuffer);
recordAcount := recordAcount + 1; 
END; !Of WHILE loop !EOF 
CALL msg (msgAEof, recordAcount); END; !Of "convert" 
PROC tprconv MAIN; BEGIN 
CALL fileAinit; CALL fileAinit; CALL convert; CALL closeAall; 
END; ?NOMAP 
Initialization Module 
!In "initializationAmodule" 
This module defines a primary global data block, defaultAvol. The block is accessible to all procedures in the modules that declare the block for reference. 
NAME initializationAmodule; 
?SECTION default BLOCK defaultAvol; 
INT defaultAvolAsubvol [0:7]; END BLOCK; 
!Default volume, subvolurne 
?NOLIST,SOURCE $SYSTEM.SYSTEM.EXTDECS (INITIALIZER)
!EXTERNAL PROC declarations: 
?NOLIST,SOURCE outp ?NOLIST,SOURCE inp ?NOLIST,SOURCE msgp 
"outAfileAhandler" "inAfileAhandler" "messageAmodule" 
-'f82581 AOO 3/85 
22-13 
SEPARATE COMPILATION
Separate Compilation Sample Program 
?NOLIST,SOURCE initp "initializationAmodule" (for consistency checks) 
PROC startup (rucb, passthru, message, meslen, match) VARIABLE; INT .rucb, .passthru, .message, meslen, match; 
BEGIN
defaultAvolAsubvol ':=' message[!] FOR 8; 
END; 
PROC fileAinit; BEGIN 
CALL INITIALIZER (,,startup); CALL msgAinit;
CALL inAfileAinit;
CALL outAfileAinit; 
END; 
PROC closeAall; BEGIN 
CALL inAclose; CALL outAclose; CALL msgAclose; 
END; ?NOMAP 
Input File Module 
The input file handler contains all procedures that manipulate that file. Therefore, if I/0 changes are required, only this module needs to be recompiled. The initialization module, for example, calls a procedure in this module. 
This module declares a private block that is accessible! only to the procedures in this module. It is allocated in primary global storage. 
22-14 
?SECTION ind BLOCK inAdata; 
LITERAL
inblklen = 1536, inArecAlen = 555; 
END BLOCK; 
?NOLIST, SOURCE default 
!In-file declarations 
?NOLIST, SOURCE 
BLOCK PRIVATE; INT inAf ile; 
END BLOCK; 
m s g l i t 
!Input file 
number 
Af'82581 AOO 3/85 
SEPARATE COMPILATION Separate Compilation Sample Program 
?NOLIST,SOURCE $SYSTEM.SYSTEM.EXTDECS (ABEND, CLOSE, FILEINFO) ?NOLIST,SOURCE $SYSTEM.SYSTEM.EXTDECS (FNAMEEXPAND, OPEN, READ) 
?NOLIST,SOURCE msgp ?NOLIST,SOURCE inp 
PROC in"'file"'init; BEGIN 
!EXTERNAL PROC declarations: "message"'module" 
! "in"'file"'handler"
! (consistency checks) 
STRING ext"'name [0:7] := ["OLDTPR "]: INT int"'name [0:11];
INT length, error; 
length := FNAMEEXPAND (ext"'name, int"'name, default"'vol"'subvol); IF length THEN 
BEGIN
CALL OPEN (int"'name, in"'file); 
I F 
END ELSE 
< THEN BEGIN 
CALL FILEINFO (in"'file, error); CALL msg (msg"'in"'open, error); CALL ABEND; 
END;
!Of THEN clause 
BEGIN
CALL msg (msg"'in"'name, 0) ; CALL ABEND 
END; !Of ELSE clause END; !Of "f ile"'init" 
INT PROC read"'in (rec); INT .rec; 
BEGIN
INT error; 
CALL READ (in"'file, rec, in"'rec"'len); I F < THEN 
BEGIN
CALL FILEINFO (in"'file, error); CALL msg (msg"'read, error); 
END;
RETURN I F > THEN 1 
ELSE O; END; !Of "read"'in" 
PROC in"'close; BEGIN 
CALL CLOSE (in"'file); END; 
?NOMAP 
~ 82581 AOO 3/85 
22-15 
SEPARATE COMPILATION
Separate Compilation Sample Program 
Output File Module 
The private block declared in this module is allocated in primary global storage and is accessible only to procedures in this module. Some of the parallel code to the input file handler is not listed. 
22-16 
NAME out"'f ile"'handler; 
?SECTION outd BLOCK out"'data; 
LITERAL
outblklen = 1024, out"'rec"'len = 256; 
END BLOCK;
?NOLIST, SOURCE default ?NOLIST, SOURCE msglit 
BLOCK PRIVATE; INT out"'f ile; 
END BLOCK; ?NOLI ST 
PROC out"'f ile"'init; BEGIN 
STRING ext"'name [0:7] := [ "CURR INT int"'name [0:11];
INT length,error; 
?NOLI ST END; 
PROC write"'out (rec); INT .rec; 
BEGIN
INT error; 
!Out-file declarations 
!BLOCK "default"'vol" !BLOCK "msg"'literals" 
" ]; 
CALL WRITE (out"'file, rec, outArec"'len); I F < THEN 
BEGIN
CALL FILEINFO (out"'file, error); CALL msg (msg"'write, error); 
END;
END; !Of "write"'out" 
PROC out"'close; BEGIN 
CALL CLOSE (out"'file); END; 
?NOMAP 
·"82581 AOO 3/85 
Message Module 
The terminal number in the private block is allocated in primary global storage and is accessible only to procedures in this module. 
NAME messageAmodule: 
?SECTION msglit BLOCK msgAliterals: 
msgAinAopen msgAinAname 
tDefines BLOCK "msgAliterals" 
LITERAL msgAEof 
=0, = 1, 2, msg"read 3, 
msg"out"open = msg"out"name msgAwrite 
END BLOCK: 
4' 5' 
6: 
BLOCK PRIVATE:
INT term"f ileAnumber: LITERAL' msg"bufAend = 79; 
END BLOCK: 
?NOLIST,SOURCE $SYSTEM.SYSTEM.EXTDECS (CLOSE, MYTERM, OPEN) ?NOLIST,SOURCE $SYSTEM.SYSTEM.EXTDECS (NUMOUT,WRITE) 
PROC msgAinit: BEGIN 
INT .termAname (0:11]: 
CALL MYTERM (term"name): 
CALL OPEN (term"name, term"file"number): END; 
PROC msg (mnumber, altnum); INT mnumber, altnum; 
BEGIN
STRING .buffer [O:msg"buf"end]; 
INT .ibuffer :=@buffer '>>' 1; STRING .bufptr; 
-'f82581 AOO 3/85 
22-17 
SEPARATE COMPILATION Separate Compilation Sample Program 
SEPARATE COMPILATION
Separate Compilation Sample Program 
22-18 
~ 82581 AOO 3/85 
CASE mnumber OF BEGIN 
!msg"eof ! buffer ':=' " 
!msg"in"open! buffer ':=' " 
!msg"in"name! buffer ':=' II 
*** End of l.,ile "
*** In file open failed -> @bufptr; 
!msg"read! buffer ':=' 
II 
*** Read error 
fl 
*** Bad in file name II 
-> @bufptr; 
-> @bufptr; 
!msg"out"open!
buffer':=' "***Out file open failed"-> @bufptr; 
!msg"out"name!
buffer ':=' 11 ***Bad out file name 11 
!msg"'write!
buffer I:=' II *** Write error n OTHERWISE; 
END; 
IF altnum <> 0 THEN BEGIN 
CALL NUMOUT (bufptr, altnum, 10, 5); 
@bufptr := @bufptr + 5; END; 
-> @bufptr; 
-> @bufptr; 
CALL WRITE (term"'file"'number, ibuffer, @bufptr - @buffer); 
END; !Of 
11 
msg" 
PROC msg"'close; BEGIN 
CALL CLOSE (term"file"number); END; 
?NOMAP 
II 
-> @bufptr; 
Compilation Maps and Statistics 
SP PEP BASE 
00 012 000737 
00 004 000266 
00 011 000721 
00 017 001133 
00 015 000767 
00 010 000421 
00 021 001147 
00 014 000751 
00 020 001141 
00 016 001051 
00 002 000022 
00 006 000340 
00 003 000122 
00 013 000743 
00 005 000332 
00 007 000373 
L I M I T ENTRY DATE TIME 
000742 000737 2/11/85 13:5 
000331 000266 2/11/85 13:5 
000736 000721 2/11/85 13:5 
001140 001133 2/11/85 12:5 
001050 000773 2/11/85 12:5 
000720 000421 2/11/85 12:5 
001154 001147 2/11/85 12:5 
000766 000751 2/11/85 12:5 
001146 001141 2/11/85 12:5 
001132 001055 2/11/85 12:59 
000111 000022 2/11/85 13:54 
000372 000340 2/11/85 12:59 
000265 000122 2/11/85 13:54 000750 000743 v 2/11/85 13:52 
ATTRS NAME
LANGUAGE SOURCE F I L E 
000337 000332 M 2/11/85 13:54 TAL 
000420 000373
2/11/85 12:59 TAL 
SEPARATE COMPILATION Separate Compilation Sample Program 
Figures 22-2, 22-3, and 22-4 show the entry-point load map, data-block load map, and statistics for the mainline compilation. 
ENTRY POINT MAP BY NAME 
=-~---- __,----- Figure 22-2. Entry-Point Load Map of Mainline Compilation 
"f82581 AOO 3/85 
22-19 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
TAL 
CLOSE"' ALL $VOL.PRG.INITS 
CONVERT $VOL.PRG.CONVERTS 
FILE"'INIT $VOL.PRG.INITS 
IN"'CLOSE $VOL.PRG.INS 
IN"'FILE"'INIT $VOL. PRG. INS 
MSG 
$VOL.PRG.MSGS MSG"' CLOSE 
$VOL.PRG.MSGS MSG"' I NIT 
$VOL.PRG.MSGS OUT"'CLOSE 
$VOL.PRG.OUTS OUT"'FILE"'INIT 
$VOL.PRG.OUTS OUT"'INIT 
$VOL.PRG.CONVERTS READ"' IN 
$VOL. PRG. INS RECORD"'CONVERT 
$VOL.PRG.CONVERTS STARTUP 
$VOL.PRG.INITS TPRCONV 
$VOL.PRG.CONVERTS WRITE"'OUT 
$VOL.PRG.OUTS 
SEPARATE COMPILATION
Separate Compilation Sample Program 
22-20 
..,82581 AOO 3/85 
DATA BLOCK MAP BY NAME 
BASE LIMIT 
000003 000012 
000000 000000 
000002 000002 
000000 
000001 000001 
000000 000000 
TYPE DATE 
WORD 2/11/85 12:59 
COMMON WORD 2/11/85 12:59 
COMMON WORD 2/11/85 12:58 
COMMON WORD 2/11/85 12:58 
COMMON 
COMMON 2/11/85 
COMMON
2/11/85 12:59 
MODE TIME 
NAME
LANGUAGE SOURCE FILE 
DEFAULT
TAL ~;voL.PRG.INS 
IN"'FI LE"'HANDLER
TAL $VOL.PRG.INS 
MESSAGE"'MODUL,E
TAL $VOL.PRG.MSGS 
MESSAGE"' LITERALS
TAL $VOL.PRG.MSGS 
OUT"'FILE"'HANDLER
TAL ~:voL. PRG. OUTS 
IN"'FILE"'HANDLER
TAL $VOL.PRG.INS 
WORD 12:59 
WORD 
Figure 22-3. Data-Block Load Map 
BINDER - OBJECT FILE BINDER - T9621BOO - (28JAN85) SYSTEM \XX Object file name is $VOL.PRG.CONVO
Number of Binder errors = 0
Number of Binder warnings = 0 
Primary data = 11 words
Code area size = 1 pages Resident code size = 0 pages Data area size = 2 pages
Number of code spaces = 1 space 
The object file will run on a TNS/II, but may not run on a TNS Number of compiler errors = 0
Number of compiler warnings = 0
Maximum symbol table space used was 9938 bytes 
Number of source lines= 221 Elapsed time - 00:01:24 
Figure 22-4. Compilation Statistics 


