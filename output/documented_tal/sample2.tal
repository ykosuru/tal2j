Documented Code
! ===========================================================================
! Comprehensive TAL Program Sample
! Demonstrates arrays, pointers, subprocs, global variables, external callouts,
! assignments, byte array operations, bit manipulation, and other TAL features
! ===========================================================================

! Define the program name for linking and identification
NAME inventory_system;

! Forward declarations allow referencing procedures and structures before their full definition
! Declare the print_error procedure signature before its definition
FORWARD PROC print_error;
! Declare the customer_record structure name before its definition
FORWARD STRUCT customer_record;

! Declare procedures defined in external modules or libraries
! Procedure to log transaction details
EXTERNAL PROC log_transaction;
! Procedure to retrieve customer information
EXTERNAL PROC fetch_customer_data;

! Define global constants using LITERAL declarations
! Maximum number of items the inventory can hold
LITERAL max_items = 1000;
! Maximum number of customers the system can handle
LITERAL max_customers = 500;
! Standard buffer size for I/O operations
LITERAL buffer_size = 4096;
! Status code for successful operation
LITERAL success = 0;
! Error code for file not found errors
LITERAL error_file_not_found = 1;
! Error code for invalid user input
LITERAL error_invalid_input = 2;
! Error code for general system errors
LITERAL error_system = 3;

! Define basic data types for clarity and potential future modification
! Define an integer type for item identifiers
INT item_id;
! Define a string type for item names (length determined at usage)
STRING item_name;

! Define global data structures
! Structure template for an inventory item record
STRUCT item_record;
BEGIN
  ! Unique identifier for the item
  INT item_id;
  ! Name of the item (up to 31 characters)
  STRING item_name[0:30];
  ! Price of the item (fixed-point with 2 decimal places)
  FIXED(2) item_price;
  ! Current quantity in stock
  INT quantity_on_hand;
  ! Minimum quantity before reordering
  INT reorder_level;
  ! Identifier for the item's supplier
  INT supplier_id;
  ! Date the record was last updated (YYYY-MM-DD format)
  STRING last_updated[0:10];
END;

! Structure template for a customer record
STRUCT customer_record;
BEGIN
  ! Unique identifier for the customer
  INT customer_id;
  ! Name of the customer (up to 51 characters)
  STRING customer_name[0:50];
  ! First line of the customer's address
  STRING address_line1[0:30];
  ! Second line of the customer's address
  STRING address_line2[0:30];
  ! Customer's city
  STRING city[0:20];
  ! Customer's state (2-character code)
  STRING state[0:2];
  ! Customer's zip code
  STRING zip_code[0:9];
  ! Customer's current account balance (fixed-point with 2 decimal places)
  FIXED(2) account_balance;
  ! Filler bytes to ensure proper memory alignment for subsequent fields
  FILLER 2;
  ! Bit flags for customer attributes (packed into a single word)
  ! Flag indicating if the customer account is active (1 bit)
  UNSIGNED(1) is_active;
  ! Flag indicating if the customer has credit privileges (1 bit)
  UNSIGNED(1) has_credit;
  ! Flag indicating if the customer is tax-exempt (1 bit)
  UNSIGNED(1) tax_exempt;
  ! Reserved bits for future use (13 bits)
  UNSIGNED(13) reserved;
END;

! Declare pointers to system global variables (managed by the OS/environment)
! Pointer to the system time variable
INT .SG system_time;

! Declare global variables accessible throughout the program
! Global variable to store the most recent error code, initialized to 0 (success)
INT error_code := 0;
! Array of error message strings, indexed by error_code. 'P' indicates read-only data in program space.
STRING error_messages[0:3] = 'P' := ["Success", "File not found", "Invalid input", "System error"];
! Counter for the number of transactions processed, initialized to 0
INT transaction_count := 0;
! Array to hold all inventory item records, sized by max_items
STRUCT item_record inventory[0:max_items-1];
! Counter for the current number of items in the inventory array, initialized to 0
INT inventory_count := 0;

! Declare pointer variables
! External pointer to the global error_code (could be used by external modules)
INT .EXT error_ptr;
! Pointer to the currently active customer record
STRUCT customer_record .current_customer;
! Pointer to a general-purpose buffer (likely for I/O)
STRING .buffer;

! Declare read-only arrays initialized in program space ('P')
! Array of numeric codes corresponding to commands
INT command_codes[0:5] = 'P' := [1, 2, 3, 4, 5, 6];
! Array of string names corresponding to commands
STRING command_names[0:5] = 'P' := ["ADD", "DELETE", "UPDATE", "QUERY", "REPORT", "EXIT"];

! Declare equivalenced variables (aliases for other variables or memory locations)
! last_error is an alias for the global variable error_code
INT last_error = error_code;
! buffer_length is an alias for a specific system global location ('G'[10]), often used for I/O lengths
INT buffer_length = 'G'[10];

! Declare global block variables (structured data areas often used for I/O or shared data)
! Block for inventory file I/O related data
BLOCK inventory_io;
  ! Name of the inventory file
  STRING filename[0:30];
  ! Status code from file operations
  INT file_error;
  ! Count of records processed during I/O
  INT record_count;
END BLOCK;

! ===========================================================================
! Main procedure - Program execution begins here
! ===========================================================================
! Define the main procedure, returning an integer status code. MAIN designates it as the entry point.
INT PROC main_proc, MAIN;
  ! Declare local variables for the main procedure
  ! Loop counter variable
  INT i;
  ! Variable to hold status codes from function calls
  INT status;
  ! Buffer to hold user input
  STRING input_buffer[0:100];
  ! Temporary string variable for various operations
  STRING temp_str[0:50];
  ! Another loop counter or index variable
  INT j;
BEGIN
  ! Initialize the global buffer pointer to point to a newly allocated buffer filled with spaces
  buffer := buffer_size * [" "];

  ! Call the subprocedure to populate the inventory array with initial sample data
  CALL initialize_inventory;

  ! Main command processing loop
  ! Initialize command variable
  cmd := 0;
  ! Loop continues until the user enters the exit command (6)
  WHILE cmd <> 6 DO
    ! Display the command menu to the user
    CALL display_menu;
    ! Read the user's command input (implementation assumed in read_command subproc)
    CALL read_command(cmd); ! Assuming read_command updates the 'cmd' variable

    ! Process the entered command using a CASE statement
    CASE cmd OF
    BEGIN
      ! Command 1: Add a new item
      1: CALL add_item;
      ! Command 2: Delete an existing item
      2: CALL delete_item;
      ! Command 3: Update an existing item
      3: CALL update_item;
      ! Command 4: Query item information
      4: CALL query_item;
      ! Command 5: Generate an inventory report
      5: CALL generate_report;
      ! Command 6: Exit the program (do nothing here, loop condition handles exit)
      6: ;
      ! Handle any invalid command numbers
      OTHERWISE
        ! Set the error code to indicate invalid input
        error_code := error_invalid_input;
        ! Call the procedure to print the corresponding error message
        CALL print_error;
    END; ! End of CASE statement

    ! Log the transaction unless the command was to exit
    IF cmd <> 6 THEN
      ! Increment the global transaction counter
      transaction_count := transaction_count + 1;
      ! Call the external procedure to log the transaction details
      CALL log_transaction(cmd, transaction_count);
    ENDIF;
  ENDWHILE; ! End of main processing loop

  ! Perform cleanup operations before exiting
  ! Set the external error pointer to point to the global error_code variable
  error_ptr := @error_code;
  ! Check if the error code is non-zero (indicating an error occurred at some point)
  IF error_ptr <> 0 THEN
    ! Print the final error status if an error exists
    CALL print_error;
  ENDIF;

  ! Example of bit manipulation on a customer record
  ! Check if there are any items in the inventory (to avoid accessing invalid data)
  IF inventory_count > 0 THEN
    ! Point current_customer to a customer_record (likely needs allocation or fetching first - simplified example)
    ! NOTE: This assumes @customer_record points to valid memory, which might need explicit allocation/fetching
    current_customer := @customer_record;
    ! Set the 'is_active' bit flag to 1 (true)
    current_customer.is_active := 1;
    ! Set the 'tax_exempt' bit flag to 1 (true)
    current_customer.tax_exempt := 1;
    ! Clear the reserved bits
    current_customer.reserved := 0;
  ENDIF;

  ! Return a success status code to the operating system/caller
  RETURN success;
END; ! End of main_proc

! ===========================================================================
! Subprocedures - Modular blocks of code performing specific tasks
! ===========================================================================

! Subprocedure to initialize the inventory array with some sample data
PROC initialize_inventory;
  ! Declare local loop counter
  INT i;
BEGIN
  ! Set the global inventory count to reflect the number of sample items being added
  inventory_count := 3;

  ! Populate the first inventory record (index 0)
  inventory[0].item_id := 1001;
  inventory[0].item_name := "Widget A";
  inventory[0].item_price := 19.99F; ! F suffix denotes FIXED literal
  inventory[0].quantity_on_hand := 150;
  inventory[0].reorder_level := 25;
  inventory[0].supplier_id := 101;
  inventory[0].last_updated := "2025-04-01";

  ! Populate the second inventory record (index 1)
  inventory[1].item_id := 1002;
  inventory[1].item_name := "Widget B";
  inventory[1].item_price := 29.99F;
  inventory[1].quantity_on_hand := 75;
  inventory[1].reorder_level := 15;
  inventory[1].supplier_id := 102;
  inventory[1].last_updated := "2025-04-01";

  ! Populate the third inventory record (index 2)
  inventory[2].item_id := 1003;
  inventory[2].item_name := "Widget C";
  inventory[2].item_price := 39.99F;
  inventory[2].quantity_on_hand := 50;
  inventory[2].reorder_level := 10;
  inventory[2].supplier_id := 101;
  inventory[2].last_updated := "2025-04-01";
END; ! End of initialize_inventory

! Subprocedure to display the main menu options to the user
PROC display_menu;
  ! Declare local loop counter
  INT i;
BEGIN
  ! Prepare the menu title string in the buffer
  buffer := "==== Inventory System Menu ====";
  ! Call a hypothetical procedure to write the buffer content (30 chars) to the output device
  CALL write_line(buffer, 30); ! Assuming write_line handles output

  ! Loop through the command codes and names to display menu options
  FOR i := 0 TO 5 DO
    ! Prepare the buffer for a menu line (e.g., "  1. ADD")
    ! Start with indentation
    buffer := "  ";
    ! Place the command code (converted to character if needed, simplified here)
    buffer[2] := command_codes[i]; ! Assumes direct assignment works or conversion happens
    ! Add formatting
    buffer[3] := ". ";
    ! Append the command name
    buffer[5] := command_names[i];
    ! Write the formatted menu line (approx 15 chars)
    CALL write_line(buffer, 15); ! Assuming write_line handles output
  ENDFOR;

  ! Prepare the prompt string in the buffer
  buffer := "Enter command: ";
  ! Write the prompt to the output device without a newline (assuming 'write' does this)
  CALL write ! Assuming write handles output without newline
  ! (Code to read input would typically follow here, handled by read_command in main)
END; ! End of display_menu

! --- Other subprocedures (print_error, read_command, add_item, etc.) would follow ---