Documented Code
! ===========================================================================
! Comprehensive TAL Program Sample
! Demonstrates arrays, pointers, subprocs, global variables, external callouts,
! assignments, byte array operations, bit manipulation, and other TAL features
! ===========================================================================

! Define the program name for linking and identification
NAME inventory_system;

! ===========================================================================
! Forward Declarations
! ===========================================================================
! Declare procedures and structures defined later in the code or in other modules
! This allows them to be referenced before their full definition.

! Forward declaration for the error printing procedure
FORWARD PROC print_error;
! Forward declaration for the customer record structure
FORWARD STRUCT customer_record;

! ===========================================================================
! External Procedure Declarations
! ===========================================================================
! Declare procedures defined in external modules or libraries

! Declare an external procedure to log transaction details
EXTERNAL PROC log_transaction;
! Declare an external procedure to fetch customer data (presumably from a database or file)
EXTERNAL PROC fetch_customer_data;

! ===========================================================================
! Global Literal Declarations (Constants)
! ===========================================================================
! Define named constants for use throughout the program

! Maximum number of items the inventory can hold
LITERAL max_items = 1000;
! Maximum number of customers the system can handle
LITERAL max_customers = 500;
! Standard buffer size for I/O operations
LITERAL buffer_size = 4096;
! Status code for successful operations
LITERAL success = 0;
! Error code for file not found errors
LITERAL error_file_not_found = 1;
! Error code for invalid user input
LITERAL error_invalid_input = 2;
! Error code for general system errors
LITERAL error_system = 3;

! ===========================================================================
! Type Definitions
! ===========================================================================
! Define basic data types (though these are standard TAL types,
! this section could define user-defined types if needed)

! Define a standard integer type for item identifiers
INT item_id;
! Define a standard string type for item names
STRING item_name;

! ===========================================================================
! Global Structure Definitions
! ===========================================================================

! Define the structure for an inventory item record
STRUCT item_record;
BEGIN
  ! Unique identifier for the item
  INT item_id;
  ! Name of the item (up to 31 characters)
  STRING item_name[0:30];
  ! Price of the item (fixed-point with 2 decimal places)
  FIXED(2) item_price;
  ! Current quantity in stock
  INT quantity_on_hand;
  ! Minimum quantity before reordering
  INT reorder_level;
  ! Identifier for the item's supplier
  INT supplier_id;
  ! Date the record was last updated (YYYY-MM-DD format, 11 chars)
  STRING last_updated[0:10];
END; ! End of item_record structure

! Define the structure for a customer record
STRUCT customer_record;
BEGIN
  ! Unique identifier for the customer
  INT customer_id;
  ! Name of the customer (up to 51 characters)
  STRING customer_name[0:50];
  ! First line of the customer's address (up to 31 characters)
  STRING address_line1[0:30];
  ! Second line of the customer's address (up to 31 characters)
  STRING address_line2[0:30];
  ! Customer's city (up to 21 characters)
  STRING city[0:20];
  ! Customer's state (2 characters)
  STRING state[0:2];
  ! Customer's zip code (up to 10 characters)
  STRING zip_code[0:9];
  ! Customer's current account balance (fixed-point with 2 decimal places)
  FIXED(2) account_balance;
  ! Add 2 bytes of padding to ensure proper memory alignment for subsequent fields
  FILLER 2;
  ! Define bit flags within a single word for customer attributes
  ! Bit 0: Flag indicating if the customer account is active (1 = active)
  UNSIGNED(1) is_active;
  ! Bit 1: Flag indicating if the customer has credit enabled (1 = has credit)
  UNSIGNED(1) has_credit;
  ! Bit 2: Flag indicating if the customer is tax-exempt (1 = exempt)
  UNSIGNED(1) tax_exempt;
  ! Bits 3-15: Reserved for future use
  UNSIGNED(13) reserved;
END; ! End of customer_record structure

! ===========================================================================
! System Global Pointer Declarations
! ===========================================================================
! Declare pointers to system-level global variables (often defined by the OS or environment)

! Pointer to the system time variable (assuming it's an integer representation)
INT .SG system_time;

! ===========================================================================
! Global Variable Declarations
! ===========================================================================
! Declare variables accessible throughout the program

! Global variable to store the last error code, initialized to 0 (success)
INT error_code := 0;
! Global array of strings holding error messages corresponding to error codes
! 'P' indicates the array is initialized in the program's data segment
STRING error_messages[0:3] = 'P' := ["Success", "File not found", "Invalid input", "System error"];
! Global counter for the number of transactions processed, initialized to 0
INT transaction_count := 0;
! Global array to hold all inventory item records, sized by max_items
STRUCT item_record inventory[0:max_items-1];
! Global counter for the current number of items in the inventory array, initialized to 0
INT inventory_count := 0;

! ===========================================================================
! Global Pointer Declarations
! ===========================================================================
! Declare global pointers used to reference data

! External pointer to an integer (potentially used for shared error handling)
INT .EXT error_ptr;
! Pointer to the currently active customer record structure
STRUCT customer_record .current_customer;
! Pointer to a general-purpose string buffer
STRING .buffer;

! ===========================================================================
! Read-only Array Declarations
! ===========================================================================
! Declare arrays initialized at compile time and typically not modified

! Read-only array of integer command codes corresponding to menu options
! 'P' indicates initialization in the program's data segment
INT command_codes[0:5] = 'P' := [1, 2, 3, 4, 5, 6];
! Read-only array of string command names corresponding to menu options
! 'P' indicates initialization in the program's data segment
STRING command_names[0:5] = 'P' := ["ADD", "DELETE", "UPDATE", "QUERY", "REPORT", "EXIT"];

! ===========================================================================
! Equivalenced Variable Declarations
! ===========================================================================
! Create aliases or alternative names for existing variables or memory locations

! Alias 'last_error' to refer to the same memory location as 'error_code'
INT last_error = error_code;
! Alias 'buffer_length' to refer to a specific global memory location (Guardian specific?)
! 'G'[10] likely refers to a system global or specific memory address.
INT buffer_length = 'G'[10];

! ===========================================================================
! Global Block Declarations
! ===========================================================================
! Define named blocks of related global variables, often used for I/O control

! Define a block for inventory file I/O related variables
BLOCK inventory_io;
  ! Name of the inventory file being processed
  STRING filename[0:30];
  ! Status code related to file operations within this block
  INT file_error;
  ! Count of records processed during I/O operations
  INT record_count;
END BLOCK; ! End of inventory_io block

! ===========================================================================
! Main procedure - Program Entry Point
! ===========================================================================
! The main execution logic of the inventory system program
INT PROC main_proc, MAIN;
  ! Declare local integer variable for loop control
  INT i;
  ! Declare local integer variable to hold status codes from calls
  INT status;
  ! Declare local string buffer for user input
  STRING input_buffer[0:100];
  ! Declare local temporary string variable
  STRING temp_str[0:50];
  ! Declare another local integer variable (purpose determined by usage)
  INT j;
BEGIN ! Start of main procedure logic

  ! Initialize the global string buffer pointer to point to a newly allocated
  ! buffer of 'buffer_size' bytes, filled with spaces.
  buffer := buffer_size * [" "];

  ! Call the subprocedure to populate the inventory array with initial sample data
  CALL initialize_inventory;

  ! Initialize command variable before entering the loop
  cmd := 0;
  ! Main command processing loop, continues until the user chooses to exit (command 6)
  WHILE cmd <> 6 DO
    ! Display the main menu options to the user
    CALL display_menu;
    ! Read the command entered by the user (implementation assumed in read_command)
    CALL read_command(cmd); ! 'cmd' is passed by reference to be updated

    ! Process the command entered by the user
    CASE cmd OF
    BEGIN
      ! Command 1: Add a new item
      1: CALL add_item;
      ! Command 2: Delete an existing item
      2: CALL delete_item;
      ! Command 3: Update an existing item
      3: CALL update_item;
      ! Command 4: Query item details
      4: CALL query_item;
      ! Command 5: Generate an inventory report
      5: CALL generate_report;
      ! Command 6: Exit the program (do nothing here, loop condition handles exit)
      6: ;
      ! Handle any command code not listed above
      OTHERWISE
        ! Set the global error code to indicate invalid input
        error_code := error_invalid_input;
        ! Call the procedure to print the corresponding error message
        CALL print_error;
    END; ! End of CASE statement

    ! Log the transaction unless the user chose to exit
    IF cmd <> 6 THEN
      ! Increment the global transaction counter
      transaction_count := transaction_count + 1;
      ! Call the external procedure to log the transaction details
      CALL log_transaction(cmd, transaction_count);
    ENDIF;
  ENDWHILE; ! End of main processing loop

  ! Perform cleanup actions before exiting
  ! Set the external error pointer to point to the global error code variable
  error_ptr := @error_code;
  ! Check if the error code (via the pointer) indicates an error occurred
  IF error_ptr <> 0 THEN
    ! Print the final error message if an error is pending
    CALL print_error;
  ENDIF;

  ! Example of bit manipulation using the customer record structure
  ! Check if there is at least one item in inventory before proceeding
  IF inventory_count > 0 THEN
    ! Point the global customer pointer to a customer record (likely needs allocation or fetching)
    ! NOTE: This assumes @customer_record provides a valid address. In a real scenario,
    ! this might involve fetching data or allocating memory.
    current_customer := @customer_record;
    ! Set the 'is_active' bit flag to 1 (true)
    current_customer.is_active := 1;
    ! Set the 'tax_exempt' bit flag to 1 (true)
    current_customer.tax_exempt := 1;
    ! Ensure the reserved bits are cleared (set to 0)
    current_customer.reserved := 0;
  ENDIF;

  ! Return a success status code to the operating system or calling process
  RETURN success;
END; ! End of main_proc

! ===========================================================================
! Subprocedures (Helper Functions)
! ===========================================================================

! ---------------------------------------------------------------------------
! Procedure to initialize the inventory with some sample data
! ---------------------------------------------------------------------------
PROC initialize_inventory;
  ! Declare local integer variable for loop control (if needed, currently unused)
  INT i;
BEGIN ! Start of initialize_inventory procedure

  ! Set the global inventory count to reflect the number of items being added
  inventory_count := 3;

  ! Populate the first inventory record (index 0)
  inventory[0].item_id := 1001;
  inventory[0].item_name := "Widget A";
  inventory[0].item_price := 19.99F; ! 'F' denotes a FIXED literal
  inventory[0].quantity_on_hand := 150;
  inventory[0].reorder_level := 25;
  inventory[0].supplier_id := 101;
  inventory[0].last_updated := "2025-04-01";

  ! Populate the second inventory record (index 1)
  inventory[1].item_id := 1002;
  inventory[1].item_name := "Widget B";
  inventory[1].item_price := 29.99F;
  inventory[1].quantity_on_hand := 75;
  inventory[1].reorder_level := 15;
  inventory[1].supplier_id := 102;
  inventory[1].last_updated := "2025-04-01";

  ! Populate the third inventory record (index 2)
  inventory[2].item_id := 1003;
  inventory[2].item_name := "Widget C";
  inventory[2].item_price := 39.99F;
  inventory[2].quantity_on_hand := 50;
  inventory[2].reorder_level := 10;
  inventory[2].supplier_id := 101;
  inventory[2].last_updated := "2025-04-01";
END; ! End of initialize_inventory procedure

! ---------------------------------------------------------------------------
! Procedure to display the main menu to the user
! ---------------------------------------------------------------------------
PROC display_menu;
  ! Declare local integer variable for loop control
  INT i;
BEGIN ! Start of display_menu procedure

  ! Prepare the menu header string in the global buffer
  buffer := "==== Inventory System Menu ====";
  ! Call a procedure (assumed external or system) to write the buffer content as a line
  CALL write_line(buffer, 30); ! Assuming 30 is the length to write

  ! Loop through the command codes and names to display menu options
  FOR i := 0 TO 5 DO
    ! Start building the menu item line with indentation
    buffer := "  ";
    ! Place the command code (integer) into the buffer (requires implicit conversion or specific handling in TAL)
    buffer[2] := command_codes[i];
    ! Add separator string
    buffer[3] := ". ";
    ! Concatenate the command name string
    buffer[5] := command_names[i];
    ! Write the constructed menu item line
    CALL write_line(buffer, 15); ! Assuming 15 is approx length
  ENDFOR; ! End of menu item loop

  ! Prepare the prompt string in the buffer
  buffer := "Enter command: ";
  ! Call a procedure (assumed external or system) to write the prompt without a newline
  CALL write ! Assuming 'write' outputs without newline, unlike 'write_line'
  ! (Code snippet ends here)